/* tslint:disable */
/* eslint-disable */
/**
 * Resolution Center
 * Simple, yet elegant web interfaces for your convenience. One request away from your first automated resolution.
 *
 * The version of the OpenAPI document: 2.0.208
 * Contact: noc@tripartie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccessError
 */
export interface AccessError {
    /**
     * 
     * @type {string}
     * @memberof AccessError
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessError
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessError
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {number}
     * @memberof Address
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'gateOrPortalOrInboxCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'updatedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiClientPostCreationRead
 */
export interface ApiClientPostCreationRead {
    /**
     * 
     * @type {string}
     * @memberof ApiClientPostCreationRead
     */
    'identifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiClientPostCreationRead
     */
    'secret'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiClientPostCreationRead
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ApiClientRead
 */
export interface ApiClientRead {
    /**
     * 
     * @type {string}
     * @memberof ApiClientRead
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof ApiClientRead
     */
    'createdAt': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiClientRead
     */
    'scopes'?: Array<ApiClientReadScopesEnum>;
    /**
     * 
     * @type {string}
     * @memberof ApiClientRead
     */
    'name'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiClientReadScopesEnum {
    DisputeRead = 'DISPUTE_READ',
    DisputeWrite = 'DISPUTE_WRITE',
    PersonaRead = 'PERSONA_READ',
    PersonaWrite = 'PERSONA_WRITE',
    PersonaAuth = 'PERSONA_AUTH',
    OfferRead = 'OFFER_READ',
    OfferWrite = 'OFFER_WRITE',
    OrganizationRead = 'ORGANIZATION_READ',
    InternalWrite = 'INTERNAL_WRITE'
}

/**
 * 
 * @export
 * @interface ApiClientWrite
 */
export interface ApiClientWrite {
    /**
     * 
     * @type {string}
     * @memberof ApiClientWrite
     */
    'referenceName'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiClientWrite
     */
    'desiredScopes'?: Array<ApiClientWriteDesiredScopesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiClientWriteDesiredScopesEnum {
    OfferRead = 'OFFER_READ',
    OfferWrite = 'OFFER_WRITE',
    DisputeRead = 'DISPUTE_READ',
    DisputeWrite = 'DISPUTE_WRITE',
    OrganizationRead = 'ORGANIZATION_READ',
    PersonaRead = 'PERSONA_READ',
    PersonaWrite = 'PERSONA_WRITE',
    PersonaAuth = 'PERSONA_AUTH'
}

/**
 * 
 * @export
 * @interface AuthError
 */
export interface AuthError {
    /**
     * 
     * @type {number}
     * @memberof AuthError
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface DisputeAddressIndependentWrite
 */
export interface DisputeAddressIndependentWrite {
    /**
     * 
     * @type {string}
     * @memberof DisputeAddressIndependentWrite
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeAddressIndependentWrite
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeAddressIndependentWrite
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeAddressIndependentWrite
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeAddressIndependentWrite
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeAddressIndependentWrite
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeAddressIndependentWrite
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeAddressIndependentWrite
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeAddressIndependentWrite
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * Access directly our resolution center without having used the safe-checkout feature.
 * @export
 * @interface DisputeCollectionRead
 */
export interface DisputeCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'ulid': string;
    /**
     * 
     * @type {DisputeTransactionCollectionRead}
     * @memberof DisputeCollectionRead
     */
    'transaction'?: DisputeTransactionCollectionRead;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'status': DisputeCollectionReadStatusEnum;
    /**
     * The dispute may concern only PART of the package. Specify it there.
     * @type {number}
     * @memberof DisputeCollectionRead
     */
    'itemCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'issueType'?: DisputeCollectionReadIssueTypeEnum | null;
    /**
     * To be set only in conjunction of issueType = NOT_AS_DESCRIBED.
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'issueInDescriptionType'?: DisputeCollectionReadIssueInDescriptionTypeEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeCollectionRead
     */
    'issueMentionedInOffer'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'complainantStake'?: DisputeCollectionReadComplainantStakeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'inferredStake'?: DisputeCollectionReadInferredStakeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'chosenSolution'?: DisputeCollectionReadChosenSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeCollectionRead
     */
    'chosenPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'platformSolution'?: DisputeCollectionReadPlatformSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeCollectionRead
     */
    'platformPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeCollectionRead
     */
    'platformApproval'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'platformActorType'?: DisputeCollectionReadPlatformActorTypeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'updatedAt'?: string | null;
    /**
     * Yield if eligible the date-time at which the dispute state expire.
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'statusExpiration'?: string | null;
    /**
     * Determine who is awaited (actor) for the next transition
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'awaitedParty'?: DisputeCollectionReadAwaitedPartyEnum;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'iri'?: string;
    /**
     * 
     * @type {number}
     * @memberof DisputeCollectionRead
     */
    'messageCount'?: number;
    /**
     * Determine who won the case, if not specified, then it is ongoing.
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'closedInFavorOf'?: DisputeCollectionReadClosedInFavorOfEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadStatusEnum {
    Created = 'CREATED',
    Submitted = 'SUBMITTED',
    Opened = 'OPENED',
    Abandoned = 'ABANDONED',
    Objected = 'OBJECTED',
    PendingShipment = 'PENDING_SHIPMENT',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Returned = 'RETURNED',
    Dismissed = 'DISMISSED',
    Resolved = 'RESOLVED',
    Pending = 'PENDING'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadIssueTypeEnum {
    NotAsDescribed = 'NOT_AS_DESCRIBED',
    DoesNotWork = 'DOES_NOT_WORK',
    IsIncomplete = 'IS_INCOMPLETE',
    DeliveryIssue = 'DELIVERY_ISSUE',
    AllegedFraud = 'ALLEGED_FRAUD',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadIssueInDescriptionTypeEnum {
    WrongColour = 'WRONG_COLOUR',
    DamagedOrUsed = 'DAMAGED_OR_USED',
    IncorrectFormatOrSize = 'INCORRECT_FORMAT_OR_SIZE',
    DifferentMaterial = 'DIFFERENT_MATERIAL',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadComplainantStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadInferredStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadChosenSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadPlatformSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadPlatformActorTypeEnum {
    Ruling = 'RULING',
    Ai = 'AI',
    CustomerCare = 'CUSTOMER_CARE',
    PlatformSupport = 'PLATFORM_SUPPORT',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadAwaitedPartyEnum {
    Buyer = 'BUYER',
    Platform = 'PLATFORM',
    Seller = 'SELLER'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadClosedInFavorOfEnum {
    Buyer = 'BUYER',
    Seller = 'SELLER'
}

/**
 * Access directly our resolution center without having used the safe-checkout feature.
 * @export
 * @interface DisputeDisputeRead
 */
export interface DisputeDisputeRead {
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'ulid': string;
    /**
     * 
     * @type {TransactionDisputeRead}
     * @memberof DisputeDisputeRead
     */
    'transaction'?: TransactionDisputeRead;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'status': DisputeDisputeReadStatusEnum;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'redirectUrl'?: string | null;
    /**
     * The dispute may concern only PART of the package. Specify it there.
     * @type {number}
     * @memberof DisputeDisputeRead
     */
    'itemCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'issueType'?: DisputeDisputeReadIssueTypeEnum | null;
    /**
     * To be set only in conjunction of issueType = NOT_AS_DESCRIBED.
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'issueInDescriptionType'?: DisputeDisputeReadIssueInDescriptionTypeEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeDisputeRead
     */
    'issueMentionedInOffer'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'issueDetails'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeDisputeRead
     */
    'complainantTruthfulnessScore': number;
    /**
     * 
     * @type {number}
     * @memberof DisputeDisputeRead
     */
    'sellerTruthfulnessScore': number;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'complainantStake'?: DisputeDisputeReadComplainantStakeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'inferredStake'?: DisputeDisputeReadInferredStakeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'recommendedSolution'?: DisputeDisputeReadRecommendedSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeDisputeRead
     */
    'recommendedPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'chosenSolution'?: DisputeDisputeReadChosenSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeDisputeRead
     */
    'chosenPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'counterSolution'?: DisputeDisputeReadCounterSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeDisputeRead
     */
    'counterPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'sellerNotes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'sellerRejectionReason'?: DisputeDisputeReadSellerRejectionReasonEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeDisputeRead
     */
    'complainantApproval'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeDisputeRead
     */
    'sellerApproval'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'platformSolution'?: DisputeDisputeReadPlatformSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeDisputeRead
     */
    'platformPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeDisputeRead
     */
    'platformApproval'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'platformActorType'?: DisputeDisputeReadPlatformActorTypeEnum | null;
    /**
     * Explicit additional information about the platform decision. Could be written by AI, Ruling or Customer Care.
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'platformReasoning'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'arbitrationBy'?: string | null;
    /**
     * 
     * @type {Array<ParcelDisputeRead>}
     * @memberof DisputeDisputeRead
     */
    'parcels': Array<ParcelDisputeRead>;
    /**
     * 
     * @type {Array<ViewDisputeRead>}
     * @memberof DisputeDisputeRead
     */
    'views': Array<ViewDisputeRead>;
    /**
     * 
     * @type {Array<MetadataDisputeRead>}
     * @memberof DisputeDisputeRead
     */
    'metadata': Array<MetadataDisputeRead>;
    /**
     * 
     * @type {Array<WorkflowEventDisputeRead>}
     * @memberof DisputeDisputeRead
     */
    'events'?: Array<WorkflowEventDisputeRead>;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'updatedAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeDisputeRead
     */
    'viewCount'?: number;
    /**
     * Yield if eligible the date-time at which the dispute state expire.
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'statusExpiration'?: string | null;
    /**
     * Determine who is awaited (actor) for the next transition
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'awaitedParty'?: DisputeDisputeReadAwaitedPartyEnum;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'iri'?: string;
    /**
     * 
     * @type {number}
     * @memberof DisputeDisputeRead
     */
    'messageCount'?: number;
    /**
     * Determine who won the case, if not specified, then it is ongoing.
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'closedInFavorOf'?: DisputeDisputeReadClosedInFavorOfEnum;
    /**
     * Total amount disbursed by the buyer to acquire the item.
     * @type {number}
     * @memberof DisputeDisputeRead
     */
    'disbursedByBuyer'?: number | null;
    /**
     * How much the buyer can actually receive back in case of a full refund.
     * @type {number}
     * @memberof DisputeDisputeRead
     */
    'maxRefundableForBuyer'?: number | null;
}

/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadStatusEnum {
    Created = 'CREATED',
    Submitted = 'SUBMITTED',
    Opened = 'OPENED',
    Abandoned = 'ABANDONED',
    Objected = 'OBJECTED',
    PendingShipment = 'PENDING_SHIPMENT',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Returned = 'RETURNED',
    Dismissed = 'DISMISSED',
    Resolved = 'RESOLVED',
    Pending = 'PENDING'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadIssueTypeEnum {
    NotAsDescribed = 'NOT_AS_DESCRIBED',
    DoesNotWork = 'DOES_NOT_WORK',
    IsIncomplete = 'IS_INCOMPLETE',
    DeliveryIssue = 'DELIVERY_ISSUE',
    AllegedFraud = 'ALLEGED_FRAUD',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadIssueInDescriptionTypeEnum {
    WrongColour = 'WRONG_COLOUR',
    DamagedOrUsed = 'DAMAGED_OR_USED',
    IncorrectFormatOrSize = 'INCORRECT_FORMAT_OR_SIZE',
    DifferentMaterial = 'DIFFERENT_MATERIAL',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadComplainantStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadInferredStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadRecommendedSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadChosenSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadCounterSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadSellerRejectionReasonEnum {
    UnjustifiedRequest = 'UNJUSTIFIED_REQUEST',
    AbusiveRequest = 'ABUSIVE_REQUEST',
    FraudAttempt = 'FRAUD_ATTEMPT',
    Other = 'OTHER',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadPlatformSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadPlatformActorTypeEnum {
    Ruling = 'RULING',
    Ai = 'AI',
    CustomerCare = 'CUSTOMER_CARE',
    PlatformSupport = 'PLATFORM_SUPPORT',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadAwaitedPartyEnum {
    Buyer = 'BUYER',
    Platform = 'PLATFORM',
    Seller = 'SELLER'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadClosedInFavorOfEnum {
    Buyer = 'BUYER',
    Seller = 'SELLER'
}

/**
 * Access directly our resolution center without having used the safe-checkout feature.
 * @export
 * @interface DisputeIndependentWrite
 */
export interface DisputeIndependentWrite {
    /**
     * 
     * @type {DisputeTransactionIndependentWrite}
     * @memberof DisputeIndependentWrite
     */
    'transaction': DisputeTransactionIndependentWrite;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof DisputeIndependentWrite
     */
    'redirectUrl'?: string | null;
    /**
     * 
     * @type {Array<DisputeMetadataIndependentWrite>}
     * @memberof DisputeIndependentWrite
     */
    'metadata'?: Array<DisputeMetadataIndependentWrite>;
}
/**
 * 
 * @export
 * @interface DisputeMediaRead
 */
export interface DisputeMediaRead {
    /**
     * 
     * @type {string}
     * @memberof DisputeMediaRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface DisputeMetadataIndependentWrite
 */
export interface DisputeMetadataIndependentWrite {
    /**
     * 
     * @type {string}
     * @memberof DisputeMetadataIndependentWrite
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeMetadataIndependentWrite
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface DisputeMetadataRead
 */
export interface DisputeMetadataRead {
    /**
     * 
     * @type {string}
     * @memberof DisputeMetadataRead
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeMetadataRead
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface DisputeOfferCollectionRead
 */
export interface DisputeOfferCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof DisputeOfferCollectionRead
     */
    'ulid': string;
    /**
     * If specified, there would be not need for you to fill-in details. Must be accessible over WAN.
     * @type {string}
     * @memberof DisputeOfferCollectionRead
     */
    'publicUrl'?: string | null;
    /**
     * If the seller is actually YOUR organization, set it to NULL.
     * @type {DisputePersonaCollectionRead}
     * @memberof DisputeOfferCollectionRead
     */
    'seller': DisputePersonaCollectionRead;
    /**
     * 
     * @type {string}
     * @memberof DisputeOfferCollectionRead
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof DisputeOfferCollectionRead
     */
    'unitPrice'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeOfferCollectionRead
     */
    'currencyCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeOfferCollectionRead
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof DisputeOfferCollectionRead
     */
    'condition'?: DisputeOfferCollectionReadConditionEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum DisputeOfferCollectionReadConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}

/**
 * 
 * @export
 * @interface DisputeOfferIndependentWrite
 */
export interface DisputeOfferIndependentWrite {
    /**
     * If specified, there would be not need for you to fill-in details. Must be accessible over WAN.
     * @type {string}
     * @memberof DisputeOfferIndependentWrite
     */
    'publicUrl'?: string | null;
    /**
     * If the seller is actually YOUR organization, set it to NULL.
     * @type {DisputePersonaIndependentWrite}
     * @memberof DisputeOfferIndependentWrite
     */
    'seller': DisputePersonaIndependentWrite;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {string}
     * @memberof DisputeOfferIndependentWrite
     */
    'nature': DisputeOfferIndependentWriteNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof DisputeOfferIndependentWrite
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeOfferIndependentWrite
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeOfferIndependentWrite
     */
    'unitPrice'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeOfferIndependentWrite
     */
    'currencyCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeOfferIndependentWrite
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof DisputeOfferIndependentWrite
     */
    'condition'?: DisputeOfferIndependentWriteConditionEnum;
    /**
     * 
     * @type {number}
     * @memberof DisputeOfferIndependentWrite
     */
    'weightInGram'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeOfferIndependentWrite
     */
    'eanCode'?: string | null;
    /**
     * 
     * @type {Array<DisputeMetadataIndependentWrite>}
     * @memberof DisputeOfferIndependentWrite
     */
    'metadata'?: Array<DisputeMetadataIndependentWrite>;
}

/**
    * @export
    * @enum {string}
    */
export enum DisputeOfferIndependentWriteNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeOfferIndependentWriteConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}

/**
 * 
 * @export
 * @interface DisputeOfferRead
 */
export interface DisputeOfferRead {
    /**
     * 
     * @type {string}
     * @memberof DisputeOfferRead
     */
    'ulid': string;
    /**
     * If specified, there would be not need for you to fill-in details. Must be accessible over WAN.
     * @type {string}
     * @memberof DisputeOfferRead
     */
    'publicUrl'?: string | null;
    /**
     * 
     * @type {DisputeOrganizationRead}
     * @memberof DisputeOfferRead
     */
    'organization'?: DisputeOrganizationRead | null;
    /**
     * If the seller is actually YOUR organization, set it to NULL.
     * @type {DisputePersonaRead}
     * @memberof DisputeOfferRead
     */
    'seller': DisputePersonaRead;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {string}
     * @memberof DisputeOfferRead
     */
    'nature': DisputeOfferReadNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof DisputeOfferRead
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeOfferRead
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeOfferRead
     */
    'unitPrice'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeOfferRead
     */
    'currencyCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeOfferRead
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof DisputeOfferRead
     */
    'condition'?: DisputeOfferReadConditionEnum;
    /**
     * 
     * @type {Array<DisputeMediaRead>}
     * @memberof DisputeOfferRead
     */
    'medias': Array<DisputeMediaRead>;
}

/**
    * @export
    * @enum {string}
    */
export enum DisputeOfferReadNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeOfferReadConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}

/**
 * 
 * @export
 * @interface DisputeOrganizationRead
 */
export interface DisputeOrganizationRead {
    /**
     * 
     * @type {string}
     * @memberof DisputeOrganizationRead
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeOrganizationRead
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeOrganizationRead
     */
    'customBaseUrl'?: string | null;
    /**
     * 
     * @type {DisputeMediaRead}
     * @memberof DisputeOrganizationRead
     */
    'icon'?: DisputeMediaRead | null;
    /**
     * 
     * @type {DisputeMediaRead}
     * @memberof DisputeOrganizationRead
     */
    'logo'?: DisputeMediaRead | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeOrganizationRead
     */
    'primaryColor'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeOrganizationRead
     */
    'directNotificationToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeOrganizationRead
     */
    'personaAuthPortalToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeOrganizationRead
     */
    'counterProposalToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeOrganizationRead
     */
    'flatRateEnabled'?: boolean;
}
/**
 * 
 * @export
 * @interface DisputeParcelIndependentWrite
 */
export interface DisputeParcelIndependentWrite {
    /**
     * 
     * @type {string}
     * @memberof DisputeParcelIndependentWrite
     */
    'carrier'?: DisputeParcelIndependentWriteCarrierEnum;
    /**
     * 
     * @type {string}
     * @memberof DisputeParcelIndependentWrite
     */
    'identifier'?: string;
    /**
     * 
     * @type {number}
     * @memberof DisputeParcelIndependentWrite
     */
    'price'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeParcelIndependentWrite
     */
    'refundable': boolean;
    /**
     * 
     * @type {string}
     * @memberof DisputeParcelIndependentWrite
     */
    'currency'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum DisputeParcelIndependentWriteCarrierEnum {
    SwissPost = 'SwissPost',
    MondialRelay = 'MondialRelay',
    Colissimo = 'Colissimo',
    Dhl = 'Dhl',
    Chronopost = 'Chronopost',
    ColisPrive = 'ColisPrive',
    Dpd = 'Dpd',
    Ups = 'Ups',
    FedEx = 'FedEx',
    RelaisColis = 'RelaisColis'
}

/**
 * 
 * @export
 * @interface DisputeParcelRead
 */
export interface DisputeParcelRead {
    /**
     * 
     * @type {string}
     * @memberof DisputeParcelRead
     */
    'carrier': DisputeParcelReadCarrierEnum;
    /**
     * 
     * @type {string}
     * @memberof DisputeParcelRead
     */
    'identifier': string;
    /**
     * 
     * @type {number}
     * @memberof DisputeParcelRead
     */
    'price'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeParcelRead
     */
    'refundable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DisputeParcelRead
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeParcelRead
     */
    'status'?: DisputeParcelReadStatusEnum | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeParcelRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeParcelRead
     */
    'updatedAt'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum DisputeParcelReadCarrierEnum {
    SwissPost = 'SwissPost',
    MondialRelay = 'MondialRelay',
    Colissimo = 'Colissimo',
    Dhl = 'Dhl',
    Chronopost = 'Chronopost',
    ColisPrive = 'ColisPrive',
    Dpd = 'Dpd',
    Ups = 'Ups',
    FedEx = 'FedEx',
    RelaisColis = 'RelaisColis'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeParcelReadStatusEnum {
    Created = 'CREATED',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Delivered = 'DELIVERED',
    Error = 'ERROR',
    Accepted = 'ACCEPTED',
    Refused = 'REFUSED',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface DisputePersonaCollectionRead
 */
export interface DisputePersonaCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof DisputePersonaCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DisputePersonaCollectionRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputePersonaCollectionRead
     */
    'lastName'?: string;
}
/**
 * 
 * @export
 * @interface DisputePersonaIndependentWrite
 */
export interface DisputePersonaIndependentWrite {
    /**
     * 
     * @type {string}
     * @memberof DisputePersonaIndependentWrite
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof DisputePersonaIndependentWrite
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof DisputePersonaIndependentWrite
     */
    'gender': DisputePersonaIndependentWriteGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof DisputePersonaIndependentWrite
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof DisputePersonaIndependentWrite
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputePersonaIndependentWrite
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputePersonaIndependentWrite
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {DisputeAddressIndependentWrite}
     * @memberof DisputePersonaIndependentWrite
     */
    'address'?: DisputeAddressIndependentWrite | null;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof DisputePersonaIndependentWrite
     */
    'externalPurchaseCount'?: number;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof DisputePersonaIndependentWrite
     */
    'externalSellCount'?: number;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<DisputeMetadataIndependentWrite>}
     * @memberof DisputePersonaIndependentWrite
     */
    'metadata'?: Array<DisputeMetadataIndependentWrite>;
}

/**
    * @export
    * @enum {string}
    */
export enum DisputePersonaIndependentWriteGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * 
 * @export
 * @interface DisputePersonaRead
 */
export interface DisputePersonaRead {
    /**
     * 
     * @type {number}
     * @memberof DisputePersonaRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DisputePersonaRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputePersonaRead
     */
    'lastName'?: string;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof DisputePersonaRead
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputePersonaRead
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputePersonaRead
     */
    'mobilePhoneNumber'?: string | null;
}
/**
 * Access directly our resolution center without having used the safe-checkout feature.
 * @export
 * @interface DisputePostCreationRead
 */
export interface DisputePostCreationRead {
    /**
     * 
     * @type {string}
     * @memberof DisputePostCreationRead
     */
    'ulid'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputePostCreationRead
     */
    'url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DisputePostCreationRead
     */
    'buyerId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DisputePostCreationRead
     */
    'sellerId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputePostCreationRead
     */
    'offerUlid'?: string | null;
}
/**
 * Access directly our resolution center without having used the safe-checkout feature.
 * @export
 * @interface DisputeRead
 */
export interface DisputeRead {
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'ulid': string;
    /**
     * 
     * @type {DisputeTransactionRead}
     * @memberof DisputeRead
     */
    'transaction'?: DisputeTransactionRead;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'status': DisputeReadStatusEnum;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof DisputeRead
     */
    'redirectUrl'?: string | null;
    /**
     * The dispute may concern only PART of the package. Specify it there.
     * @type {number}
     * @memberof DisputeRead
     */
    'itemCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'issueType'?: DisputeReadIssueTypeEnum | null;
    /**
     * To be set only in conjunction of issueType = NOT_AS_DESCRIBED.
     * @type {string}
     * @memberof DisputeRead
     */
    'issueInDescriptionType'?: DisputeReadIssueInDescriptionTypeEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeRead
     */
    'issueMentionedInOffer'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'issueDetails'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeRead
     */
    'complainantTruthfulnessScore': number;
    /**
     * 
     * @type {number}
     * @memberof DisputeRead
     */
    'sellerTruthfulnessScore': number;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'complainantStake'?: DisputeReadComplainantStakeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'inferredStake'?: DisputeReadInferredStakeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'recommendedSolution'?: DisputeReadRecommendedSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeRead
     */
    'recommendedPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'chosenSolution'?: DisputeReadChosenSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeRead
     */
    'chosenPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'counterSolution'?: DisputeReadCounterSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeRead
     */
    'counterPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'sellerNotes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'sellerRejectionReason'?: DisputeReadSellerRejectionReasonEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeRead
     */
    'complainantApproval'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeRead
     */
    'sellerApproval'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'platformSolution'?: DisputeReadPlatformSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeRead
     */
    'platformPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeRead
     */
    'platformApproval'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'platformActorType'?: DisputeReadPlatformActorTypeEnum | null;
    /**
     * Explicit additional information about the platform decision. Could be written by AI, Ruling or Customer Care.
     * @type {string}
     * @memberof DisputeRead
     */
    'platformReasoning'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'arbitrationBy'?: string | null;
    /**
     * 
     * @type {Array<DisputeParcelRead>}
     * @memberof DisputeRead
     */
    'parcels': Array<DisputeParcelRead>;
    /**
     * 
     * @type {Array<DisputeViewRead>}
     * @memberof DisputeRead
     */
    'views': Array<DisputeViewRead>;
    /**
     * 
     * @type {Array<DisputeMetadataRead>}
     * @memberof DisputeRead
     */
    'metadata': Array<DisputeMetadataRead>;
    /**
     * 
     * @type {Array<DisputeWorkflowEventRead>}
     * @memberof DisputeRead
     */
    'events'?: Array<DisputeWorkflowEventRead>;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'updatedAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeRead
     */
    'viewCount'?: number;
    /**
     * Yield if eligible the date-time at which the dispute state expire.
     * @type {string}
     * @memberof DisputeRead
     */
    'statusExpiration'?: string | null;
    /**
     * Determine who is awaited (actor) for the next transition
     * @type {string}
     * @memberof DisputeRead
     */
    'awaitedParty'?: DisputeReadAwaitedPartyEnum;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'iri'?: string;
    /**
     * 
     * @type {number}
     * @memberof DisputeRead
     */
    'messageCount'?: number;
    /**
     * Determine who won the case, if not specified, then it is ongoing.
     * @type {string}
     * @memberof DisputeRead
     */
    'closedInFavorOf'?: DisputeReadClosedInFavorOfEnum;
    /**
     * Total amount disbursed by the buyer to acquire the item.
     * @type {number}
     * @memberof DisputeRead
     */
    'disbursedByBuyer'?: number | null;
    /**
     * How much the buyer can actually receive back in case of a full refund.
     * @type {number}
     * @memberof DisputeRead
     */
    'maxRefundableForBuyer'?: number | null;
}

/**
    * @export
    * @enum {string}
    */
export enum DisputeReadStatusEnum {
    Created = 'CREATED',
    Submitted = 'SUBMITTED',
    Opened = 'OPENED',
    Abandoned = 'ABANDONED',
    Objected = 'OBJECTED',
    PendingShipment = 'PENDING_SHIPMENT',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Returned = 'RETURNED',
    Dismissed = 'DISMISSED',
    Resolved = 'RESOLVED',
    Pending = 'PENDING'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadIssueTypeEnum {
    NotAsDescribed = 'NOT_AS_DESCRIBED',
    DoesNotWork = 'DOES_NOT_WORK',
    IsIncomplete = 'IS_INCOMPLETE',
    DeliveryIssue = 'DELIVERY_ISSUE',
    AllegedFraud = 'ALLEGED_FRAUD',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadIssueInDescriptionTypeEnum {
    WrongColour = 'WRONG_COLOUR',
    DamagedOrUsed = 'DAMAGED_OR_USED',
    IncorrectFormatOrSize = 'INCORRECT_FORMAT_OR_SIZE',
    DifferentMaterial = 'DIFFERENT_MATERIAL',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadComplainantStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadInferredStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadRecommendedSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadChosenSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadCounterSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadSellerRejectionReasonEnum {
    UnjustifiedRequest = 'UNJUSTIFIED_REQUEST',
    AbusiveRequest = 'ABUSIVE_REQUEST',
    FraudAttempt = 'FRAUD_ATTEMPT',
    Other = 'OTHER',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadPlatformSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadPlatformActorTypeEnum {
    Ruling = 'RULING',
    Ai = 'AI',
    CustomerCare = 'CUSTOMER_CARE',
    PlatformSupport = 'PLATFORM_SUPPORT',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadAwaitedPartyEnum {
    Buyer = 'BUYER',
    Platform = 'PLATFORM',
    Seller = 'SELLER'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadClosedInFavorOfEnum {
    Buyer = 'BUYER',
    Seller = 'SELLER'
}

/**
 * 
 * @export
 * @interface DisputeTransactionCollectionRead
 */
export interface DisputeTransactionCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof DisputeTransactionCollectionRead
     */
    'ulid': string;
    /**
     * 
     * @type {DisputeOfferCollectionRead}
     * @memberof DisputeTransactionCollectionRead
     */
    'offer': DisputeOfferCollectionRead;
    /**
     * 
     * @type {DisputePersonaCollectionRead}
     * @memberof DisputeTransactionCollectionRead
     */
    'buyer': DisputePersonaCollectionRead;
}
/**
 * 
 * @export
 * @interface DisputeTransactionIndependentWrite
 */
export interface DisputeTransactionIndependentWrite {
    /**
     * 
     * @type {DisputeOfferIndependentWrite}
     * @memberof DisputeTransactionIndependentWrite
     */
    'offer': DisputeOfferIndependentWrite;
    /**
     * 
     * @type {DisputePersonaIndependentWrite}
     * @memberof DisputeTransactionIndependentWrite
     */
    'buyer': DisputePersonaIndependentWrite;
    /**
     * 
     * @type {number}
     * @memberof DisputeTransactionIndependentWrite
     */
    'fees'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeTransactionIndependentWrite
     */
    'refundableFees'?: boolean;
    /**
     * 
     * @type {Array<DisputeMetadataIndependentWrite>}
     * @memberof DisputeTransactionIndependentWrite
     */
    'metadata'?: Array<DisputeMetadataIndependentWrite>;
    /**
     * 
     * @type {Array<DisputeParcelIndependentWrite>}
     * @memberof DisputeTransactionIndependentWrite
     */
    'parcels'?: Array<DisputeParcelIndependentWrite>;
}
/**
 * 
 * @export
 * @interface DisputeTransactionRead
 */
export interface DisputeTransactionRead {
    /**
     * 
     * @type {string}
     * @memberof DisputeTransactionRead
     */
    'ulid': string;
    /**
     * 
     * @type {DisputeOfferRead}
     * @memberof DisputeTransactionRead
     */
    'offer': DisputeOfferRead;
    /**
     * 
     * @type {DisputePersonaRead}
     * @memberof DisputeTransactionRead
     */
    'buyer': DisputePersonaRead;
    /**
     * 
     * @type {number}
     * @memberof DisputeTransactionRead
     */
    'fees'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeTransactionRead
     */
    'refundableFees'?: boolean;
    /**
     * 
     * @type {Array<DisputeMetadataRead>}
     * @memberof DisputeTransactionRead
     */
    'metadata'?: Array<DisputeMetadataRead>;
    /**
     * 
     * @type {Array<DisputeParcelRead>}
     * @memberof DisputeTransactionRead
     */
    'parcels'?: Array<DisputeParcelRead>;
}
/**
 * Access directly our resolution center without having used the safe-checkout feature.
 * @export
 * @interface DisputeUpdate
 */
export interface DisputeUpdate {
    /**
     * The dispute may concern only PART of the package. Specify it there.
     * @type {number}
     * @memberof DisputeUpdate
     */
    'itemCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeUpdate
     */
    'issueType'?: DisputeUpdateIssueTypeEnum | null;
    /**
     * To be set only in conjunction of issueType = NOT_AS_DESCRIBED.
     * @type {string}
     * @memberof DisputeUpdate
     */
    'issueInDescriptionType'?: DisputeUpdateIssueInDescriptionTypeEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeUpdate
     */
    'issueMentionedInOffer'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeUpdate
     */
    'issueDetails'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeUpdate
     */
    'complainantStake'?: DisputeUpdateComplainantStakeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeUpdate
     */
    'chosenSolution'?: DisputeUpdateChosenSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeUpdate
     */
    'chosenPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeUpdate
     */
    'counterSolution'?: DisputeUpdateCounterSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeUpdate
     */
    'counterPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeUpdate
     */
    'sellerNotes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeUpdate
     */
    'sellerRejectionReason'?: DisputeUpdateSellerRejectionReasonEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeUpdate
     */
    'complainantApproval'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeUpdate
     */
    'sellerApproval'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeUpdate
     */
    'platformSolution'?: DisputeUpdatePlatformSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeUpdate
     */
    'platformPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeUpdate
     */
    'platformApproval'?: boolean | null;
    /**
     * Explicit additional information about the platform decision. Could be written by AI, Ruling or Customer Care.
     * @type {string}
     * @memberof DisputeUpdate
     */
    'platformReasoning'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum DisputeUpdateIssueTypeEnum {
    NotAsDescribed = 'NOT_AS_DESCRIBED',
    DoesNotWork = 'DOES_NOT_WORK',
    IsIncomplete = 'IS_INCOMPLETE',
    DeliveryIssue = 'DELIVERY_ISSUE',
    AllegedFraud = 'ALLEGED_FRAUD',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeUpdateIssueInDescriptionTypeEnum {
    WrongColour = 'WRONG_COLOUR',
    DamagedOrUsed = 'DAMAGED_OR_USED',
    IncorrectFormatOrSize = 'INCORRECT_FORMAT_OR_SIZE',
    DifferentMaterial = 'DIFFERENT_MATERIAL',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeUpdateComplainantStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeUpdateChosenSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeUpdateCounterSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeUpdateSellerRejectionReasonEnum {
    UnjustifiedRequest = 'UNJUSTIFIED_REQUEST',
    AbusiveRequest = 'ABUSIVE_REQUEST',
    FraudAttempt = 'FRAUD_ATTEMPT',
    Other = 'OTHER',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeUpdatePlatformSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface DisputeViewRead
 */
export interface DisputeViewRead {
    /**
     * 
     * @type {number}
     * @memberof DisputeViewRead
     */
    'hitCount': number;
    /**
     * 
     * @type {string}
     * @memberof DisputeViewRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeViewRead
     */
    'namedSource'?: DisputeViewReadNamedSourceEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum DisputeViewReadNamedSourceEnum {
    Buyer = 'BUYER',
    Platform = 'PLATFORM',
    Seller = 'SELLER',
    Other = 'OTHER'
}

/**
 * 
 * @export
 * @interface DisputeWorkflowEventRead
 */
export interface DisputeWorkflowEventRead {
    /**
     * 
     * @type {string}
     * @memberof DisputeWorkflowEventRead
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof DisputeWorkflowEventRead
     */
    'from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeWorkflowEventRead
     */
    'to'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeWorkflowEventRead
     */
    'event'?: DisputeWorkflowEventReadEventEnum | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeWorkflowEventRead
     */
    'occurredAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeWorkflowEventRead
     */
    'initiator'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum DisputeWorkflowEventReadEventEnum {
    DisputeOpened = 'dispute.opened',
    DisputeSubmitted = 'dispute.submitted',
    DisputeCreated = 'dispute.created',
    DisputeAbandoned = 'dispute.abandoned',
    DisputeSettlement = 'dispute.settlement',
    DisputeClosed = 'dispute.closed',
    DisputeExpired = 'dispute.expired',
    DisputeManualArbitrationRequired = 'dispute.manual_arbitration_required',
    DisputeUpdated = 'dispute.updated',
    DisputeReminder = 'dispute.reminder',
    OfferCreated = 'offer.created',
    OfferExpired = 'offer.expired',
    OfferUpdated = 'offer.updated',
    OfferCrawlFailure = 'offer.crawl_failure',
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionReconciled = 'offer.transaction.reconciled',
    OfferTransactionAbandoned = 'offer.transaction.abandoned',
    OfferClosed = 'offer.closed',
    OfferTransactionRefund = 'offer.transaction.refund',
    PersonaAdded = 'persona.added',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface EvaluationRead
 */
export interface EvaluationRead {
    /**
     * 
     * @type {number}
     * @memberof EvaluationRead
     */
    'rating': number;
    /**
     * 
     * @type {string}
     * @memberof EvaluationRead
     */
    'comment'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EvaluationRead
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface EvaluationWrite
 */
export interface EvaluationWrite {
    /**
     * 
     * @type {number}
     * @memberof EvaluationWrite
     */
    'rating': number;
    /**
     * 
     * @type {string}
     * @memberof EvaluationWrite
     */
    'comment'?: string | null;
}
/**
 * 
 * @export
 * @interface Evidence
 */
export interface Evidence {
    /**
     * 
     * @type {number}
     * @memberof Evidence
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Evidence
     */
    'dispute'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Evidence
     */
    'owner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Evidence
     */
    'status': EvidenceStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Evidence
     */
    'media'?: string | null;
    /**
     * Description of what the evidence actually is.
     * @type {string}
     * @memberof Evidence
     */
    'additionalInformation'?: string;
    /**
     * 
     * @type {string}
     * @memberof Evidence
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Evidence
     */
    'updatedAt'?: string | null;
    /**
     * Shortcut to whomever sent the evidence
     * @type {string}
     * @memberof Evidence
     */
    'publisher'?: EvidencePublisherEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum EvidenceStatusEnum {
    Submitted = 'SUBMITTED',
    Correlated = 'CORRELATED',
    Unrelated = 'UNRELATED',
    Pending = 'PENDING',
    Tempered = 'TEMPERED',
    Rejected = 'REJECTED'
}
/**
    * @export
    * @enum {string}
    */
export enum EvidencePublisherEnum {
    Buyer = 'BUYER',
    Platform = 'PLATFORM',
    Seller = 'SELLER'
}

/**
 * 
 * @export
 * @interface EvidenceMediaRead
 */
export interface EvidenceMediaRead {
    /**
     * 
     * @type {string}
     * @memberof EvidenceMediaRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface EvidenceRead
 */
export interface EvidenceRead {
    /**
     * 
     * @type {number}
     * @memberof EvidenceRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EvidenceRead
     */
    'status': EvidenceReadStatusEnum;
    /**
     * 
     * @type {EvidenceMediaRead}
     * @memberof EvidenceRead
     */
    'media'?: EvidenceMediaRead | null;
    /**
     * Description of what the evidence actually is.
     * @type {string}
     * @memberof EvidenceRead
     */
    'additionalInformation'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceRead
     */
    'updatedAt'?: string | null;
    /**
     * Shortcut to whomever sent the evidence
     * @type {string}
     * @memberof EvidenceRead
     */
    'publisher'?: EvidenceReadPublisherEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum EvidenceReadStatusEnum {
    Submitted = 'SUBMITTED',
    Correlated = 'CORRELATED',
    Unrelated = 'UNRELATED',
    Pending = 'PENDING',
    Tempered = 'TEMPERED',
    Rejected = 'REJECTED'
}
/**
    * @export
    * @enum {string}
    */
export enum EvidenceReadPublisherEnum {
    Buyer = 'BUYER',
    Platform = 'PLATFORM',
    Seller = 'SELLER'
}

/**
 * 
 * @export
 * @interface EvidenceWrite
 */
export interface EvidenceWrite {
    /**
     * Description of what the evidence actually is.
     * @type {string}
     * @memberof EvidenceWrite
     */
    'additionalInformation': string;
}
/**
 * 
 * @export
 * @interface GenericError
 */
export interface GenericError {
    /**
     * 
     * @type {string}
     * @memberof GenericError
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericError
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericError
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface InvalidQueryError
 */
export interface InvalidQueryError {
    /**
     * 
     * @type {string}
     * @memberof InvalidQueryError
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidQueryError
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidQueryError
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface Media
 */
export interface Media {
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'extension': string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'filename': string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'fingerprint': string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'publicUrl': string;
    /**
     * 
     * @type {File}
     * @memberof Media
     */
    'file'?: File | null;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'b64EncodedTmpFile'?: string | null;
    /**
     * Associated 374x374 pixels small thumbnail
     * @type {string}
     * @memberof Media
     */
    'thumbnail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'original'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'owner'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Media
     */
    'offers'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'thumbnailUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface MediaDisputeRead
 */
export interface MediaDisputeRead {
    /**
     * 
     * @type {string}
     * @memberof MediaDisputeRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface MediaRead
 */
export interface MediaRead {
    /**
     * 
     * @type {string}
     * @memberof MediaRead
     */
    'publicUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaRead
     */
    'thumbnailUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface MediaUserRead
 */
export interface MediaUserRead {
    /**
     * 
     * @type {string}
     * @memberof MediaUserRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface MessageError
 */
export interface MessageError {
    /**
     * 
     * @type {string}
     * @memberof MessageError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * 
     * @type {number}
     * @memberof Metadata
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'persona'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'dispute'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'offer'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'transaction'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface MetadataDisputeRead
 */
export interface MetadataDisputeRead {
    /**
     * 
     * @type {string}
     * @memberof MetadataDisputeRead
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetadataDisputeRead
     */
    'value'?: string | null;
}
/**
 * This error can occurs when you reference objects in the query that does not exist.
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
    /**
     * 
     * @type {string}
     * @memberof NotFoundError
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotFoundError
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotFoundError
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface NotificationRead
 */
export interface NotificationRead {
    /**
     * 
     * @type {string}
     * @memberof NotificationRead
     */
    'type'?: NotificationReadTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationRead
     */
    'seen': boolean;
    /**
     * 
     * @type {string}
     * @memberof NotificationRead
     */
    'createdAt'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum NotificationReadTypeEnum {
    DisputeStateUpdate = 'DISPUTE_STATE_UPDATE',
    DisputeReminder = 'DISPUTE_REMINDER',
    MessageSent = 'MESSAGE_SENT',
    DisputeSettlement = 'DISPUTE_SETTLEMENT',
    DisputeArbitrationRequired = 'DISPUTE_ARBITRATION_REQUIRED',
    DisputeResolved = 'DISPUTE_RESOLVED'
}

/**
 * 
 * @export
 * @interface NotificationUpdate
 */
export interface NotificationUpdate {
    /**
     * 
     * @type {boolean}
     * @memberof NotificationUpdate
     */
    'seen': boolean;
}
/**
 * 
 * @export
 * @interface OfferDisputeRead
 */
export interface OfferDisputeRead {
    /**
     * 
     * @type {string}
     * @memberof OfferDisputeRead
     */
    'ulid': string;
    /**
     * If specified, there would be not need for you to fill-in details. Must be accessible over WAN.
     * @type {string}
     * @memberof OfferDisputeRead
     */
    'publicUrl'?: string | null;
    /**
     * 
     * @type {OrganizationDisputeRead}
     * @memberof OfferDisputeRead
     */
    'organization'?: OrganizationDisputeRead | null;
    /**
     * If the seller is actually YOUR organization, set it to NULL.
     * @type {PersonaDisputeRead}
     * @memberof OfferDisputeRead
     */
    'seller': PersonaDisputeRead;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {string}
     * @memberof OfferDisputeRead
     */
    'nature': OfferDisputeReadNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof OfferDisputeRead
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferDisputeRead
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferDisputeRead
     */
    'unitPrice'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OfferDisputeRead
     */
    'currencyCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferDisputeRead
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof OfferDisputeRead
     */
    'condition'?: OfferDisputeReadConditionEnum;
    /**
     * 
     * @type {Array<MediaDisputeRead>}
     * @memberof OfferDisputeRead
     */
    'medias': Array<MediaDisputeRead>;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferDisputeReadNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferDisputeReadConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}

/**
 * 
 * @export
 * @interface OrganizationAddressUpdate
 */
export interface OrganizationAddressUpdate {
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * 
 * @export
 * @interface OrganizationCollectionRead
 */
export interface OrganizationCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof OrganizationCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCollectionRead
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCollectionRead
     */
    'vatNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCollectionRead
     */
    'commercialRegistryNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCollectionRead
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {OrganizationMediaCollectionRead}
     * @memberof OrganizationCollectionRead
     */
    'icon'?: OrganizationMediaCollectionRead | null;
    /**
     * 
     * @type {OrganizationMediaCollectionRead}
     * @memberof OrganizationCollectionRead
     */
    'logo'?: OrganizationMediaCollectionRead | null;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationCollectionRead
     */
    'directNotificationToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationCollectionRead
     */
    'internalMessagingToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationCollectionRead
     */
    'personaAuthPortalToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationCollectionRead
     */
    'automatedReturnToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationCollectionRead
     */
    'counterProposalToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationCollectionRead
     */
    'flatRateEnabled'?: boolean;
}
/**
 * 
 * @export
 * @interface OrganizationDisputeRead
 */
export interface OrganizationDisputeRead {
    /**
     * 
     * @type {string}
     * @memberof OrganizationDisputeRead
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDisputeRead
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDisputeRead
     */
    'customBaseUrl'?: string | null;
    /**
     * 
     * @type {MediaDisputeRead}
     * @memberof OrganizationDisputeRead
     */
    'icon'?: MediaDisputeRead | null;
    /**
     * 
     * @type {MediaDisputeRead}
     * @memberof OrganizationDisputeRead
     */
    'logo'?: MediaDisputeRead | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDisputeRead
     */
    'primaryColor'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationDisputeRead
     */
    'directNotificationToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationDisputeRead
     */
    'personaAuthPortalToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationDisputeRead
     */
    'counterProposalToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationDisputeRead
     */
    'flatRateEnabled'?: boolean;
}
/**
 * 
 * @export
 * @interface OrganizationMediaCollectionRead
 */
export interface OrganizationMediaCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof OrganizationMediaCollectionRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface OrganizationMediaRead
 */
export interface OrganizationMediaRead {
    /**
     * 
     * @type {string}
     * @memberof OrganizationMediaRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface OrganizationRead
 */
export interface OrganizationRead {
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'vatNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'commercialRegistryNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'customBaseUrl'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationRead
     */
    'domainVerified': boolean;
    /**
     * 
     * @type {OrganizationMediaRead}
     * @memberof OrganizationRead
     */
    'icon'?: OrganizationMediaRead | null;
    /**
     * 
     * @type {OrganizationMediaRead}
     * @memberof OrganizationRead
     */
    'logo'?: OrganizationMediaRead | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'primaryColor'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationRead
     */
    'directNotificationToggle': boolean;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'anonymityLevel': OrganizationReadAnonymityLevelEnum;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationRead
     */
    'internalMessagingToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationRead
     */
    'personaAuthPortalToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationRead
     */
    'automatedReturnToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationRead
     */
    'counterProposalToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationRead
     */
    'flatRateEnabled'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum OrganizationReadAnonymityLevelEnum {
    Complete = 'COMPLETE',
    PartialFirstName = 'PARTIAL_FIRST_NAME',
    Transparent = 'TRANSPARENT'
}

/**
 * 
 * @export
 * @interface OrganizationUpdate
 */
export interface OrganizationUpdate {
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'vatNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'commercialRegistryNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'customBaseUrl'?: string | null;
    /**
     * 
     * @type {OrganizationAddressUpdate}
     * @memberof OrganizationUpdate
     */
    'billingAddress'?: OrganizationAddressUpdate | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'primaryColor'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationUpdate
     */
    'directNotificationToggle'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'anonymityLevel'?: OrganizationUpdateAnonymityLevelEnum;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationUpdate
     */
    'internalMessagingToggle'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationUpdate
     */
    'personaAuthPortalToggle'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationUpdate
     */
    'automatedReturnToggle'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationUpdate
     */
    'counterProposalToggle'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationUpdate
     */
    'flatRateEnabled'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum OrganizationUpdateAnonymityLevelEnum {
    Complete = 'COMPLETE',
    PartialFirstName = 'PARTIAL_FIRST_NAME',
    Transparent = 'TRANSPARENT'
}

/**
 * 
 * @export
 * @interface OrganizationUserRead
 */
export interface OrganizationUserRead {
    /**
     * 
     * @type {number}
     * @memberof OrganizationUserRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUserRead
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationUserRead
     */
    'domainVerified': boolean;
    /**
     * 
     * @type {MediaUserRead}
     * @memberof OrganizationUserRead
     */
    'icon'?: MediaUserRead | null;
    /**
     * 
     * @type {MediaUserRead}
     * @memberof OrganizationUserRead
     */
    'logo'?: MediaUserRead | null;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationUserRead
     */
    'internalMessagingToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationUserRead
     */
    'personaAuthPortalToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationUserRead
     */
    'automatedReturnToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationUserRead
     */
    'counterProposalToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationUserRead
     */
    'flatRateEnabled'?: boolean;
}
/**
 * 
 * @export
 * @interface Parcel
 */
export interface Parcel {
    /**
     * 
     * @type {number}
     * @memberof Parcel
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'carrier': ParcelCarrierEnum;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'identifier': string;
    /**
     * 
     * @type {number}
     * @memberof Parcel
     */
    'price'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof Parcel
     */
    'refundable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'status'?: ParcelStatusEnum | null;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'dispute'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'transaction'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'updatedAt'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ParcelCarrierEnum {
    SwissPost = 'SwissPost',
    MondialRelay = 'MondialRelay',
    Colissimo = 'Colissimo',
    Dhl = 'Dhl',
    Chronopost = 'Chronopost',
    ColisPrive = 'ColisPrive',
    Dpd = 'Dpd',
    Ups = 'Ups',
    FedEx = 'FedEx',
    RelaisColis = 'RelaisColis'
}
/**
    * @export
    * @enum {string}
    */
export enum ParcelStatusEnum {
    Created = 'CREATED',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Delivered = 'DELIVERED',
    Error = 'ERROR',
    Accepted = 'ACCEPTED',
    Refused = 'REFUSED',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface ParcelDisputeRead
 */
export interface ParcelDisputeRead {
    /**
     * 
     * @type {string}
     * @memberof ParcelDisputeRead
     */
    'carrier': ParcelDisputeReadCarrierEnum;
    /**
     * 
     * @type {string}
     * @memberof ParcelDisputeRead
     */
    'identifier': string;
    /**
     * 
     * @type {number}
     * @memberof ParcelDisputeRead
     */
    'price'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ParcelDisputeRead
     */
    'refundable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ParcelDisputeRead
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParcelDisputeRead
     */
    'status'?: ParcelDisputeReadStatusEnum | null;
    /**
     * 
     * @type {string}
     * @memberof ParcelDisputeRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParcelDisputeRead
     */
    'updatedAt'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ParcelDisputeReadCarrierEnum {
    SwissPost = 'SwissPost',
    MondialRelay = 'MondialRelay',
    Colissimo = 'Colissimo',
    Dhl = 'Dhl',
    Chronopost = 'Chronopost',
    ColisPrive = 'ColisPrive',
    Dpd = 'Dpd',
    Ups = 'Ups',
    FedEx = 'FedEx',
    RelaisColis = 'RelaisColis'
}
/**
    * @export
    * @enum {string}
    */
export enum ParcelDisputeReadStatusEnum {
    Created = 'CREATED',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Delivered = 'DELIVERED',
    Error = 'ERROR',
    Accepted = 'ACCEPTED',
    Refused = 'REFUSED',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface ParcelWrite
 */
export interface ParcelWrite {
    /**
     * 
     * @type {string}
     * @memberof ParcelWrite
     */
    'carrier'?: ParcelWriteCarrierEnum;
    /**
     * 
     * @type {string}
     * @memberof ParcelWrite
     */
    'identifier'?: string;
    /**
     * 
     * @type {number}
     * @memberof ParcelWrite
     */
    'price'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ParcelWrite
     */
    'refundable': boolean;
    /**
     * 
     * @type {string}
     * @memberof ParcelWrite
     */
    'currency'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ParcelWriteCarrierEnum {
    SwissPost = 'SwissPost',
    MondialRelay = 'MondialRelay',
    Colissimo = 'Colissimo',
    Dhl = 'Dhl',
    Chronopost = 'Chronopost',
    ColisPrive = 'ColisPrive',
    Dpd = 'Dpd',
    Ups = 'Ups',
    FedEx = 'FedEx',
    RelaisColis = 'RelaisColis'
}

/**
 * 
 * @export
 * @interface Persona
 */
export interface Persona {
    /**
     * 
     * @type {number}
     * @memberof Persona
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'captcha'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'organization'?: string | null;
    /**
     * The URL you wish that Persona to go to without additional MFA. The URL MUST concern that Persona.
     * @type {string}
     * @memberof Persona
     */
    'targetUrl'?: string | null;
    /**
     * Url that is able to bypass MFA for a single user. Please note that this should not be shared between the complainant and the seller or anyone external to them.
     * @type {string}
     * @memberof Persona
     */
    'authUrl'?: string | null;
    /**
     * This authenticated-URL cannot be renewed, you will have to re-create one each time. Typically valid for a single hour.
     * @type {string}
     * @memberof Persona
     */
    'expireAt'?: string | null;
    /**
     * The hashed password
     * @type {string}
     * @memberof Persona
     */
    'password'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'plainPassword'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'gender'?: PersonaGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof Persona
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {Address}
     * @memberof Persona
     */
    'address'?: Address | null;
    /**
     * We sort Persona into three distinct risks\' category. This is inferred from the riskScore.
     * @type {string}
     * @memberof Persona
     */
    'riskLevel'?: PersonaRiskLevelEnum | null;
    /**
     * That score is regularly updated, each action taken can potentially update that value. A value close to zero mean zero risk and close to a hundred mean risky.
     * @type {number}
     * @memberof Persona
     */
    'riskScore'?: number | null;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof Persona
     */
    'externalPurchaseCount'?: number;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof Persona
     */
    'externalSellCount'?: number;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<Metadata>}
     * @memberof Persona
     */
    'metadata'?: Array<Metadata>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Persona
     */
    'offers': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Persona
     */
    'purchases': Array<string>;
    /**
     * 
     * @type {Array<View>}
     * @memberof Persona
     */
    'views': Array<View>;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'updatedAt'?: string | null;
    /**
     * Issued Offers count owned by a given Persona
     * @type {number}
     * @memberof Persona
     */
    'offerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Persona
     */
    'purchaseCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Persona
     */
    'roles'?: Array<string>;
    /**
     * Either email or the mobile phone number
     * @type {string}
     * @memberof Persona
     */
    'userIdentifier'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}
/**
    * @export
    * @enum {string}
    */
export enum PersonaRiskLevelEnum {
    Weak = 'WEAK',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface PersonaAddressRead
 */
export interface PersonaAddressRead {
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'gateOrPortalOrInboxCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'updatedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaAddressUpdate
 */
export interface PersonaAddressUpdate {
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaAddressWrite
 */
export interface PersonaAddressWrite {
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaAuthReturn
 */
export interface PersonaAuthReturn {
    /**
     * Url that is able to bypass MFA for a single user. Please note that this should not be shared between the complainant and the seller or anyone external to them.
     * @type {string}
     * @memberof PersonaAuthReturn
     */
    'authUrl'?: string | null;
    /**
     * This authenticated-URL cannot be renewed, you will have to re-create one each time. Typically valid for a single hour.
     * @type {string}
     * @memberof PersonaAuthReturn
     */
    'expireAt'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaCollectionRead
 */
export interface PersonaCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof PersonaCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'email'?: string | null;
    /**
     * We sort Persona into three distinct risks\' category. This is inferred from the riskScore.
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'riskLevel'?: PersonaCollectionReadRiskLevelEnum | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'updatedAt'?: string | null;
    /**
     * Issued Offers count owned by a given Persona
     * @type {number}
     * @memberof PersonaCollectionRead
     */
    'offerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PersonaCollectionRead
     */
    'purchaseCount'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaCollectionReadRiskLevelEnum {
    Weak = 'WEAK',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface PersonaDisputeRead
 */
export interface PersonaDisputeRead {
    /**
     * 
     * @type {number}
     * @memberof PersonaDisputeRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PersonaDisputeRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaDisputeRead
     */
    'lastName'?: string;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof PersonaDisputeRead
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaDisputeRead
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaDisputeRead
     */
    'mobilePhoneNumber'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaExternalAuth
 */
export interface PersonaExternalAuth {
    /**
     * 
     * @type {string}
     * @memberof PersonaExternalAuth
     */
    'captcha'?: string | null;
    /**
     * The URL you wish that Persona to go to without additional MFA. The URL MUST concern that Persona.
     * @type {string}
     * @memberof PersonaExternalAuth
     */
    'targetUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaExternalAuth
     */
    'plainPassword'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaExternalAuth
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaExternalAuth
     */
    'mobilePhoneNumber'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaMetadataRead
 */
export interface PersonaMetadataRead {
    /**
     * 
     * @type {string}
     * @memberof PersonaMetadataRead
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaMetadataRead
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaMetadataUpdate
 */
export interface PersonaMetadataUpdate {
    /**
     * 
     * @type {string}
     * @memberof PersonaMetadataUpdate
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaMetadataUpdate
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaMetadataWrite
 */
export interface PersonaMetadataWrite {
    /**
     * 
     * @type {string}
     * @memberof PersonaMetadataWrite
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaMetadataWrite
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaPostAuthRead
 */
export interface PersonaPostAuthRead {
    /**
     * Url that is able to bypass MFA for a single user. Please note that this should not be shared between the complainant and the seller or anyone external to them.
     * @type {string}
     * @memberof PersonaPostAuthRead
     */
    'authUrl'?: string | null;
    /**
     * This authenticated-URL cannot be renewed, you will have to re-create one each time. Typically valid for a single hour.
     * @type {string}
     * @memberof PersonaPostAuthRead
     */
    'expireAt'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaRead
 */
export interface PersonaRead {
    /**
     * 
     * @type {number}
     * @memberof PersonaRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'gender'?: PersonaReadGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof PersonaRead
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {PersonaAddressRead}
     * @memberof PersonaRead
     */
    'address'?: PersonaAddressRead | null;
    /**
     * We sort Persona into three distinct risks\' category. This is inferred from the riskScore.
     * @type {string}
     * @memberof PersonaRead
     */
    'riskLevel'?: PersonaReadRiskLevelEnum | null;
    /**
     * That score is regularly updated, each action taken can potentially update that value. A value close to zero mean zero risk and close to a hundred mean risky.
     * @type {number}
     * @memberof PersonaRead
     */
    'riskScore'?: number | null;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof PersonaRead
     */
    'externalPurchaseCount'?: number;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof PersonaRead
     */
    'externalSellCount'?: number;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<PersonaMetadataRead>}
     * @memberof PersonaRead
     */
    'metadata'?: Array<PersonaMetadataRead>;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'updatedAt'?: string | null;
    /**
     * Issued Offers count owned by a given Persona
     * @type {number}
     * @memberof PersonaRead
     */
    'offerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PersonaRead
     */
    'purchaseCount'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaReadGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}
/**
    * @export
    * @enum {string}
    */
export enum PersonaReadRiskLevelEnum {
    Weak = 'WEAK',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface PersonaRegister
 */
export interface PersonaRegister {
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'captcha'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'plainPassword'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'gender': PersonaRegisterGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof PersonaRegister
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'mobilePhoneNumber'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaRegisterGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * 
 * @export
 * @interface PersonaTokenWrite
 */
export interface PersonaTokenWrite {
    /**
     * The URL you wish that Persona to go to without additional MFA. The URL MUST concern that Persona.
     * @type {string}
     * @memberof PersonaTokenWrite
     */
    'targetUrl': string | null;
}
/**
 * 
 * @export
 * @interface PersonaUpdate
 */
export interface PersonaUpdate {
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'gender': PersonaUpdateGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof PersonaUpdate
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {PersonaAddressUpdate}
     * @memberof PersonaUpdate
     */
    'address'?: PersonaAddressUpdate | null;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof PersonaUpdate
     */
    'externalPurchaseCount'?: number;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof PersonaUpdate
     */
    'externalSellCount'?: number;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<PersonaMetadataUpdate>}
     * @memberof PersonaUpdate
     */
    'metadata'?: Array<PersonaMetadataUpdate>;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaUpdateGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * 
 * @export
 * @interface PersonaWrite
 */
export interface PersonaWrite {
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'gender': PersonaWriteGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof PersonaWrite
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {PersonaAddressWrite}
     * @memberof PersonaWrite
     */
    'address'?: PersonaAddressWrite | null;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof PersonaWrite
     */
    'externalPurchaseCount'?: number;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof PersonaWrite
     */
    'externalSellCount'?: number;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<PersonaMetadataWrite>}
     * @memberof PersonaWrite
     */
    'metadata'?: Array<PersonaMetadataWrite>;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaWriteGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * 
 * @export
 * @interface RateLimitError
 */
export interface RateLimitError {
    /**
     * 
     * @type {string}
     * @memberof RateLimitError
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof RateLimitError
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof RateLimitError
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface TransactionDisputeRead
 */
export interface TransactionDisputeRead {
    /**
     * 
     * @type {string}
     * @memberof TransactionDisputeRead
     */
    'ulid': string;
    /**
     * 
     * @type {OfferDisputeRead}
     * @memberof TransactionDisputeRead
     */
    'offer': OfferDisputeRead;
    /**
     * 
     * @type {PersonaDisputeRead}
     * @memberof TransactionDisputeRead
     */
    'buyer': PersonaDisputeRead;
    /**
     * 
     * @type {number}
     * @memberof TransactionDisputeRead
     */
    'fees'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionDisputeRead
     */
    'refundableFees'?: boolean;
    /**
     * 
     * @type {Array<MetadataDisputeRead>}
     * @memberof TransactionDisputeRead
     */
    'metadata'?: Array<MetadataDisputeRead>;
    /**
     * 
     * @type {Array<ParcelDisputeRead>}
     * @memberof TransactionDisputeRead
     */
    'parcels'?: Array<ParcelDisputeRead>;
}
/**
 * 
 * @export
 * @interface UnprocessableEntity
 */
export interface UnprocessableEntity {
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntity
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntity
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntity
     */
    'detail'?: string;
    /**
     * 
     * @type {Array<UnprocessableEntityViolationsInner>}
     * @memberof UnprocessableEntity
     */
    'violations'?: Array<UnprocessableEntityViolationsInner>;
}
/**
 * 
 * @export
 * @interface UnprocessableEntityViolationsInner
 */
export interface UnprocessableEntityViolationsInner {
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntityViolationsInner
     */
    'propertyPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntityViolationsInner
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntityViolationsInner
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'captcha'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'invitedRole'?: Array<UserInvitedRoleEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'roles': Array<UserRolesEnum>;
    /**
     * The hashed password
     * @type {string}
     * @memberof User
     */
    'password'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'plainPassword'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'newPassword'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'totpSecret'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'totpUri'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'totpEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'totpChallenge'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'intlPhoneNumber'?: string | null;
    /**
     * The originating country
     * @type {string}
     * @memberof User
     */
    'originCountry'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'preferredLanguage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastSuccessfulLogIn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'emailVerificationCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'emailVerificationInput'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phoneVerificationCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phoneVerificationInput'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'avatar'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'notifications'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'medias'?: Array<string>;
    /**
     * 
     * @type {Array<View>}
     * @memberof User
     */
    'views': Array<View>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'consentMailNotification': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'consentMailAds': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'lockdown': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'keys': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'organization'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'impersonatedOrganization'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'iri'?: string;
    /**
     * A visual identifier that represents this user.
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'salt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'userIdentifier'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'impersonatingOrganization'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'secondAuthFactor'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum UserInvitedRoleEnum {
    Admin = 'ROLE_ADMIN',
    Consultant = 'ROLE_CONSULTANT',
    AccountingManager = 'ROLE_ACCOUNTING_MANAGER',
    BillingManager = 'ROLE_BILLING_MANAGER',
    CustomerService = 'ROLE_CUSTOMER_SERVICE',
    CustomerService2 = 'ROLE_CUSTOMER_SERVICE',
    PlatformAdmin = 'ROLE_PLATFORM_ADMIN',
    PlatformSupport = 'ROLE_PLATFORM_SUPPORT',
    OrganizationOwner = 'ROLE_ORGANIZATION_OWNER'
}
/**
    * @export
    * @enum {string}
    */
export enum UserRolesEnum {
    OrganizationOwner = 'ROLE_ORGANIZATION_OWNER',
    Admin = 'ROLE_ADMIN',
    Consultant = 'ROLE_CONSULTANT',
    AccountingManager = 'ROLE_ACCOUNTING_MANAGER',
    BillingManager = 'ROLE_BILLING_MANAGER',
    CustomerService = 'ROLE_CUSTOMER_SERVICE',
    PlatformSupport = 'ROLE_PLATFORM_SUPPORT',
    PlatformAdmin = 'ROLE_PLATFORM_ADMIN',
    User = 'ROLE_USER'
}

/**
 * 
 * @export
 * @interface UserAddressWrite
 */
export interface UserAddressWrite {
    /**
     * 
     * @type {string}
     * @memberof UserAddressWrite
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAddressWrite
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAddressWrite
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAddressWrite
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAddressWrite
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAddressWrite
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAddressWrite
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAddressWrite
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAddressWrite
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * 
 * @export
 * @interface UserAuthenticatedRead
 */
export interface UserAuthenticatedRead {
    /**
     * 
     * @type {number}
     * @memberof UserAuthenticatedRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserAuthenticatedRead
     */
    'roles': Array<UserAuthenticatedReadRolesEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof UserAuthenticatedRead
     */
    'totpEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'intlPhoneNumber'?: string | null;
    /**
     * The originating country
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'originCountry'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'preferredLanguage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'lastSuccessfulLogIn'?: string | null;
    /**
     * 
     * @type {UserMediaAuthenticatedRead}
     * @memberof UserAuthenticatedRead
     */
    'avatar'?: UserMediaAuthenticatedRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserAuthenticatedRead
     */
    'consentMailNotification': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserAuthenticatedRead
     */
    'consentMailAds': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserAuthenticatedRead
     */
    'lockdown': boolean;
    /**
     * 
     * @type {UserOrganizationAuthenticatedRead}
     * @memberof UserAuthenticatedRead
     */
    'organization'?: UserOrganizationAuthenticatedRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'iri'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserAuthenticatedRead
     */
    'impersonatingOrganization'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserAuthenticatedRead
     */
    'secondAuthFactor'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum UserAuthenticatedReadRolesEnum {
    OrganizationOwner = 'ROLE_ORGANIZATION_OWNER',
    Admin = 'ROLE_ADMIN',
    Consultant = 'ROLE_CONSULTANT',
    AccountingManager = 'ROLE_ACCOUNTING_MANAGER',
    BillingManager = 'ROLE_BILLING_MANAGER',
    CustomerService = 'ROLE_CUSTOMER_SERVICE',
    PlatformSupport = 'ROLE_PLATFORM_SUPPORT',
    PlatformAdmin = 'ROLE_PLATFORM_ADMIN',
    User = 'ROLE_USER'
}

/**
 * 
 * @export
 * @interface UserCollectionRead
 */
export interface UserCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof UserCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserCollectionRead
     */
    'roles': Array<UserCollectionReadRolesEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof UserCollectionRead
     */
    'totpEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'intlPhoneNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'lastSuccessfulLogIn'?: string | null;
    /**
     * 
     * @type {UserMediaCollectionRead}
     * @memberof UserCollectionRead
     */
    'avatar'?: UserMediaCollectionRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {UserOrganizationCollectionRead}
     * @memberof UserCollectionRead
     */
    'organization'?: UserOrganizationCollectionRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'iri'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserCollectionRead
     */
    'secondAuthFactor'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum UserCollectionReadRolesEnum {
    OrganizationOwner = 'ROLE_ORGANIZATION_OWNER',
    Admin = 'ROLE_ADMIN',
    Consultant = 'ROLE_CONSULTANT',
    AccountingManager = 'ROLE_ACCOUNTING_MANAGER',
    BillingManager = 'ROLE_BILLING_MANAGER',
    CustomerService = 'ROLE_CUSTOMER_SERVICE',
    PlatformSupport = 'ROLE_PLATFORM_SUPPORT',
    PlatformAdmin = 'ROLE_PLATFORM_ADMIN',
    User = 'ROLE_USER'
}

/**
 * 
 * @export
 * @interface UserEmailValidationWrite
 */
export interface UserEmailValidationWrite {
    /**
     * 
     * @type {string}
     * @memberof UserEmailValidationWrite
     */
    'captcha': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserEmailValidationWrite
     */
    'plainPassword'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserEmailValidationWrite
     */
    'emailVerificationInput': string | null;
}
/**
 * 
 * @export
 * @interface UserInvite
 */
export interface UserInvite {
    /**
     * 
     * @type {string}
     * @memberof UserInvite
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserInvite
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof UserInvite
     */
    'email': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserInvite
     */
    'invitedRole': Array<UserInviteInvitedRoleEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum UserInviteInvitedRoleEnum {
    Admin = 'ROLE_ADMIN',
    Consultant = 'ROLE_CONSULTANT',
    AccountingManager = 'ROLE_ACCOUNTING_MANAGER',
    BillingManager = 'ROLE_BILLING_MANAGER',
    CustomerService = 'ROLE_CUSTOMER_SERVICE',
    CustomerService2 = 'ROLE_CUSTOMER_SERVICE',
    PlatformAdmin = 'ROLE_PLATFORM_ADMIN',
    PlatformSupport = 'ROLE_PLATFORM_SUPPORT',
    OrganizationOwner = 'ROLE_ORGANIZATION_OWNER'
}

/**
 * 
 * @export
 * @interface UserJwtCreated
 */
export interface UserJwtCreated {
    /**
     * 
     * @type {string}
     * @memberof UserJwtCreated
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface UserJwtWrite
 */
export interface UserJwtWrite {
    /**
     * 
     * @type {string}
     * @memberof UserJwtWrite
     */
    'captcha'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserJwtWrite
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserJwtWrite
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserJwtWrite
     */
    'totpInput'?: string;
}
/**
 * 
 * @export
 * @interface UserMediaAuthenticatedRead
 */
export interface UserMediaAuthenticatedRead {
    /**
     * 
     * @type {string}
     * @memberof UserMediaAuthenticatedRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface UserMediaCollectionRead
 */
export interface UserMediaCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof UserMediaCollectionRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface UserMediaRead
 */
export interface UserMediaRead {
    /**
     * 
     * @type {string}
     * @memberof UserMediaRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface UserOrganizationAuthenticatedRead
 */
export interface UserOrganizationAuthenticatedRead {
    /**
     * 
     * @type {number}
     * @memberof UserOrganizationAuthenticatedRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserOrganizationAuthenticatedRead
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserOrganizationAuthenticatedRead
     */
    'domainVerified': boolean;
    /**
     * 
     * @type {UserMediaAuthenticatedRead}
     * @memberof UserOrganizationAuthenticatedRead
     */
    'icon'?: UserMediaAuthenticatedRead | null;
    /**
     * 
     * @type {UserMediaAuthenticatedRead}
     * @memberof UserOrganizationAuthenticatedRead
     */
    'logo'?: UserMediaAuthenticatedRead | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserOrganizationAuthenticatedRead
     */
    'internalMessagingToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserOrganizationAuthenticatedRead
     */
    'personaAuthPortalToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserOrganizationAuthenticatedRead
     */
    'automatedReturnToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserOrganizationAuthenticatedRead
     */
    'counterProposalToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserOrganizationAuthenticatedRead
     */
    'flatRateEnabled'?: boolean;
}
/**
 * 
 * @export
 * @interface UserOrganizationCollectionRead
 */
export interface UserOrganizationCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof UserOrganizationCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserOrganizationCollectionRead
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UserOrganizationRead
 */
export interface UserOrganizationRead {
    /**
     * 
     * @type {number}
     * @memberof UserOrganizationRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserOrganizationRead
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserOrganizationRead
     */
    'domainVerified'?: boolean;
    /**
     * 
     * @type {UserMediaRead}
     * @memberof UserOrganizationRead
     */
    'icon'?: UserMediaRead | null;
    /**
     * 
     * @type {UserMediaRead}
     * @memberof UserOrganizationRead
     */
    'logo'?: UserMediaRead | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserOrganizationRead
     */
    'internalMessagingToggle'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserOrganizationRead
     */
    'personaAuthPortalToggle'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserOrganizationRead
     */
    'automatedReturnToggle'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserOrganizationRead
     */
    'counterProposalToggle'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserOrganizationRead
     */
    'flatRateEnabled'?: boolean;
}
/**
 * 
 * @export
 * @interface UserOrganizationWrite
 */
export interface UserOrganizationWrite {
    /**
     * 
     * @type {number}
     * @memberof UserOrganizationWrite
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserOrganizationWrite
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserOrganizationWrite
     */
    'vatNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserOrganizationWrite
     */
    'commercialRegistryNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserOrganizationWrite
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {UserAddressWrite}
     * @memberof UserOrganizationWrite
     */
    'billingAddress'?: UserAddressWrite | null;
}
/**
 * 
 * @export
 * @interface UserPostRegisterRead
 */
export interface UserPostRegisterRead {
    /**
     * 
     * @type {number}
     * @memberof UserPostRegisterRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserPostRegisterRead
     */
    'iri'?: string;
}
/**
 * 
 * @export
 * @interface UserTotpSetupRead
 */
export interface UserTotpSetupRead {
    /**
     * 
     * @type {string}
     * @memberof UserTotpSetupRead
     */
    'totpUri'?: string | null;
}
/**
 * 
 * @export
 * @interface UserTotpToggleWrite
 */
export interface UserTotpToggleWrite {
    /**
     * 
     * @type {boolean}
     * @memberof UserTotpToggleWrite
     */
    'totpEnabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserTotpToggleWrite
     */
    'totpChallenge': string | null;
}
/**
 * 
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'intlPhoneNumber'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdate
     */
    'consentMailNotification': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdate
     */
    'consentMailAds': boolean;
}
/**
 * 
 * @export
 * @interface UserUserEmailUpdate
 */
export interface UserUserEmailUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUserEmailUpdate
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserUserEmailUpdate
     */
    'plainPassword': string | null;
}
/**
 * 
 * @export
 * @interface UserUserPasswordUpdate
 */
export interface UserUserPasswordUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUserPasswordUpdate
     */
    'plainPassword': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserPasswordUpdate
     */
    'newPassword': string | null;
}
/**
 * 
 * @export
 * @interface UserUserRead
 */
export interface UserUserRead {
    /**
     * 
     * @type {number}
     * @memberof UserUserRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'email': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserUserRead
     */
    'roles'?: Array<UserUserReadRolesEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof UserUserRead
     */
    'totpEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'intlPhoneNumber'?: string | null;
    /**
     * The originating country
     * @type {string}
     * @memberof UserUserRead
     */
    'originCountry'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'preferredLanguage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'lastSuccessfulLogIn'?: string | null;
    /**
     * 
     * @type {MediaUserRead}
     * @memberof UserUserRead
     */
    'avatar'?: MediaUserRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserUserRead
     */
    'consentMailNotification'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserUserRead
     */
    'consentMailAds'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserUserRead
     */
    'lockdown'?: boolean;
    /**
     * 
     * @type {OrganizationUserRead}
     * @memberof UserUserRead
     */
    'organization'?: OrganizationUserRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'iri'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserUserRead
     */
    'impersonatingOrganization'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserUserRead
     */
    'secondAuthFactor'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum UserUserReadRolesEnum {
    OrganizationOwner = 'ROLE_ORGANIZATION_OWNER',
    Admin = 'ROLE_ADMIN',
    Consultant = 'ROLE_CONSULTANT',
    AccountingManager = 'ROLE_ACCOUNTING_MANAGER',
    BillingManager = 'ROLE_BILLING_MANAGER',
    CustomerService = 'ROLE_CUSTOMER_SERVICE',
    PlatformSupport = 'ROLE_PLATFORM_SUPPORT',
    PlatformAdmin = 'ROLE_PLATFORM_ADMIN',
    User = 'ROLE_USER'
}

/**
 * Disable a user account
 * @export
 * @interface UserUserSubscribed
 */
export interface UserUserSubscribed {
    /**
     * 
     * @type {number}
     * @memberof UserUserSubscribed
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserUserSubscribed
     */
    'iri'?: string;
}
/**
 * 
 * @export
 * @interface UserWrite
 */
export interface UserWrite {
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'captcha': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'plainPassword': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'intlPhoneNumber'?: string | null;
    /**
     * The originating country
     * @type {string}
     * @memberof UserWrite
     */
    'originCountry': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'preferredLanguage': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserWrite
     */
    'consentMailNotification'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserWrite
     */
    'consentMailAds'?: boolean;
    /**
     * 
     * @type {UserOrganizationWrite}
     * @memberof UserWrite
     */
    'organization'?: UserOrganizationWrite | null;
}
/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * 
     * @type {number}
     * @memberof View
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'ipAddress': string;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'offer'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'dispute'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'persona'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'user'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof View
     */
    'hitCount': number;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'namedSource'?: ViewNamedSourceEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ViewNamedSourceEnum {
    Buyer = 'BUYER',
    Platform = 'PLATFORM',
    Seller = 'SELLER',
    Other = 'OTHER'
}

/**
 * 
 * @export
 * @interface ViewDisputeRead
 */
export interface ViewDisputeRead {
    /**
     * 
     * @type {number}
     * @memberof ViewDisputeRead
     */
    'hitCount': number;
    /**
     * 
     * @type {string}
     * @memberof ViewDisputeRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViewDisputeRead
     */
    'namedSource'?: ViewDisputeReadNamedSourceEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ViewDisputeReadNamedSourceEnum {
    Buyer = 'BUYER',
    Platform = 'PLATFORM',
    Seller = 'SELLER',
    Other = 'OTHER'
}

/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * 
     * @type {number}
     * @memberof Webhook
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'event'?: WebhookEventEnum;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'iri'?: string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'occurredAt'?: string;
    /**
     * 
     * @type {WebhookObject}
     * @memberof Webhook
     */
    'object'?: WebhookObject;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookEventEnum {
    DisputeOpened = 'dispute.opened',
    DisputeSubmitted = 'dispute.submitted',
    DisputeCreated = 'dispute.created',
    DisputeAbandoned = 'dispute.abandoned',
    DisputeSettlement = 'dispute.settlement',
    DisputeClosed = 'dispute.closed',
    DisputeExpired = 'dispute.expired',
    DisputeManualArbitrationRequired = 'dispute.manual_arbitration_required',
    DisputeUpdated = 'dispute.updated',
    DisputeReminder = 'dispute.reminder',
    OfferCreated = 'offer.created',
    OfferExpired = 'offer.expired',
    OfferUpdated = 'offer.updated',
    OfferCrawlFailure = 'offer.crawl_failure',
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionReconciled = 'offer.transaction.reconciled',
    OfferTransactionAbandoned = 'offer.transaction.abandoned',
    OfferClosed = 'offer.closed',
    OfferTransactionRefund = 'offer.transaction.refund',
    PersonaAdded = 'persona.added'
}

/**
 * 
 * @export
 * @interface WebhookHistoryCollectionRead
 */
export interface WebhookHistoryCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryCollectionRead
     */
    'objectId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryCollectionRead
     */
    'event': WebhookHistoryCollectionReadEventEnum;
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryCollectionRead
     */
    'responseCode'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryCollectionRead
     */
    'occurredAt': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryCollectionRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryCollectionRead
     */
    'attemptedAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryCollectionRead
     */
    'retryCount': number;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookHistoryCollectionRead
     */
    'inProgress'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookHistoryCollectionReadEventEnum {
    DisputeOpened = 'dispute.opened',
    DisputeSubmitted = 'dispute.submitted',
    DisputeCreated = 'dispute.created',
    DisputeAbandoned = 'dispute.abandoned',
    DisputeSettlement = 'dispute.settlement',
    DisputeClosed = 'dispute.closed',
    DisputeExpired = 'dispute.expired',
    DisputeManualArbitrationRequired = 'dispute.manual_arbitration_required',
    DisputeUpdated = 'dispute.updated',
    DisputeReminder = 'dispute.reminder',
    OfferCreated = 'offer.created',
    OfferExpired = 'offer.expired',
    OfferUpdated = 'offer.updated',
    OfferCrawlFailure = 'offer.crawl_failure',
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionReconciled = 'offer.transaction.reconciled',
    OfferTransactionAbandoned = 'offer.transaction.abandoned',
    OfferClosed = 'offer.closed',
    OfferTransactionRefund = 'offer.transaction.refund',
    PersonaAdded = 'persona.added'
}

/**
 * 
 * @export
 * @interface WebhookHistoryRead
 */
export interface WebhookHistoryRead {
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'objectId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'event': WebhookHistoryReadEventEnum;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'url': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WebhookHistoryRead
     */
    'normalizedObject'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryRead
     */
    'responseCode'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'responseBody'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'occurredAt': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'attemptedAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryRead
     */
    'retryCount': number;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookHistoryRead
     */
    'inProgress'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookHistoryReadEventEnum {
    DisputeOpened = 'dispute.opened',
    DisputeSubmitted = 'dispute.submitted',
    DisputeCreated = 'dispute.created',
    DisputeAbandoned = 'dispute.abandoned',
    DisputeSettlement = 'dispute.settlement',
    DisputeClosed = 'dispute.closed',
    DisputeExpired = 'dispute.expired',
    DisputeManualArbitrationRequired = 'dispute.manual_arbitration_required',
    DisputeUpdated = 'dispute.updated',
    DisputeReminder = 'dispute.reminder',
    OfferCreated = 'offer.created',
    OfferExpired = 'offer.expired',
    OfferUpdated = 'offer.updated',
    OfferCrawlFailure = 'offer.crawl_failure',
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionReconciled = 'offer.transaction.reconciled',
    OfferTransactionAbandoned = 'offer.transaction.abandoned',
    OfferClosed = 'offer.closed',
    OfferTransactionRefund = 'offer.transaction.refund',
    PersonaAdded = 'persona.added'
}

/**
 * 
 * @export
 * @interface WebhookObject
 */
export interface WebhookObject {
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'ulid': string;
    /**
     * 
     * @type {DisputeTransactionRead}
     * @memberof WebhookObject
     */
    'transaction'?: DisputeTransactionRead;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'status': WebhookObjectStatusEnum;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof WebhookObject
     */
    'redirectUrl'?: string | null;
    /**
     * The dispute may concern only PART of the package. Specify it there.
     * @type {number}
     * @memberof WebhookObject
     */
    'itemCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'issueType'?: WebhookObjectIssueTypeEnum | null;
    /**
     * To be set only in conjunction of issueType = NOT_AS_DESCRIBED.
     * @type {string}
     * @memberof WebhookObject
     */
    'issueInDescriptionType'?: WebhookObjectIssueInDescriptionTypeEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookObject
     */
    'issueMentionedInOffer'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'issueDetails'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'complainantTruthfulnessScore': number;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'sellerTruthfulnessScore': number;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'complainantStake'?: WebhookObjectComplainantStakeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'inferredStake'?: WebhookObjectInferredStakeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'recommendedSolution'?: WebhookObjectRecommendedSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'recommendedPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'chosenSolution'?: WebhookObjectChosenSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'chosenPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'counterSolution'?: WebhookObjectCounterSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'counterPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'sellerNotes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'sellerRejectionReason'?: WebhookObjectSellerRejectionReasonEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookObject
     */
    'complainantApproval'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookObject
     */
    'sellerApproval'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'platformSolution'?: WebhookObjectPlatformSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'platformPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookObject
     */
    'platformApproval'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'platformActorType'?: WebhookObjectPlatformActorTypeEnum | null;
    /**
     * Explicit additional information about the platform decision. Could be written by AI, Ruling or Customer Care.
     * @type {string}
     * @memberof WebhookObject
     */
    'platformReasoning'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'arbitrationBy'?: string | null;
    /**
     * 
     * @type {Array<DisputeParcelRead>}
     * @memberof WebhookObject
     */
    'parcels': Array<DisputeParcelRead>;
    /**
     * 
     * @type {Array<DisputeViewRead>}
     * @memberof WebhookObject
     */
    'views': Array<DisputeViewRead>;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<PersonaMetadataRead>}
     * @memberof WebhookObject
     */
    'metadata': Array<PersonaMetadataRead>;
    /**
     * 
     * @type {Array<DisputeWorkflowEventRead>}
     * @memberof WebhookObject
     */
    'events'?: Array<DisputeWorkflowEventRead>;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'updatedAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'viewCount'?: number;
    /**
     * Yield if eligible the date-time at which the dispute state expire.
     * @type {string}
     * @memberof WebhookObject
     */
    'statusExpiration'?: string | null;
    /**
     * Determine who is awaited (actor) for the next transition
     * @type {string}
     * @memberof WebhookObject
     */
    'awaitedParty'?: WebhookObjectAwaitedPartyEnum;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'iri'?: string;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'messageCount'?: number;
    /**
     * Determine who won the case, if not specified, then it is ongoing.
     * @type {string}
     * @memberof WebhookObject
     */
    'closedInFavorOf'?: WebhookObjectClosedInFavorOfEnum;
    /**
     * Total amount disbursed by the buyer to acquire the item.
     * @type {number}
     * @memberof WebhookObject
     */
    'disbursedByBuyer'?: number | null;
    /**
     * How much the buyer can actually receive back in case of a full refund.
     * @type {number}
     * @memberof WebhookObject
     */
    'maxRefundableForBuyer'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'gender'?: WebhookObjectGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof WebhookObject
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {PersonaAddressRead}
     * @memberof WebhookObject
     */
    'address'?: PersonaAddressRead | null;
    /**
     * We sort Persona into three distinct risks\' category. This is inferred from the riskScore.
     * @type {string}
     * @memberof WebhookObject
     */
    'riskLevel'?: WebhookObjectRiskLevelEnum | null;
    /**
     * That score is regularly updated, each action taken can potentially update that value. A value close to zero mean zero risk and close to a hundred mean risky.
     * @type {number}
     * @memberof WebhookObject
     */
    'riskScore'?: number | null;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof WebhookObject
     */
    'externalPurchaseCount'?: number;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof WebhookObject
     */
    'externalSellCount'?: number;
    /**
     * Issued Offers count owned by a given Persona
     * @type {number}
     * @memberof WebhookObject
     */
    'offerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'purchaseCount'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectStatusEnum {
    Created = 'CREATED',
    Submitted = 'SUBMITTED',
    Opened = 'OPENED',
    Abandoned = 'ABANDONED',
    Objected = 'OBJECTED',
    PendingShipment = 'PENDING_SHIPMENT',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Returned = 'RETURNED',
    Dismissed = 'DISMISSED',
    Resolved = 'RESOLVED',
    Pending = 'PENDING'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectIssueTypeEnum {
    NotAsDescribed = 'NOT_AS_DESCRIBED',
    DoesNotWork = 'DOES_NOT_WORK',
    IsIncomplete = 'IS_INCOMPLETE',
    DeliveryIssue = 'DELIVERY_ISSUE',
    AllegedFraud = 'ALLEGED_FRAUD',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectIssueInDescriptionTypeEnum {
    WrongColour = 'WRONG_COLOUR',
    DamagedOrUsed = 'DAMAGED_OR_USED',
    IncorrectFormatOrSize = 'INCORRECT_FORMAT_OR_SIZE',
    DifferentMaterial = 'DIFFERENT_MATERIAL',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectComplainantStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectInferredStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectRecommendedSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectChosenSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectCounterSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectSellerRejectionReasonEnum {
    UnjustifiedRequest = 'UNJUSTIFIED_REQUEST',
    AbusiveRequest = 'ABUSIVE_REQUEST',
    FraudAttempt = 'FRAUD_ATTEMPT',
    Other = 'OTHER',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectPlatformSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectPlatformActorTypeEnum {
    Ruling = 'RULING',
    Ai = 'AI',
    CustomerCare = 'CUSTOMER_CARE',
    PlatformSupport = 'PLATFORM_SUPPORT',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectAwaitedPartyEnum {
    Buyer = 'BUYER',
    Platform = 'PLATFORM',
    Seller = 'SELLER'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectClosedInFavorOfEnum {
    Buyer = 'BUYER',
    Seller = 'SELLER'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectRiskLevelEnum {
    Weak = 'WEAK',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface WebhookSubscriptionRead
 */
export interface WebhookSubscriptionRead {
    /**
     * 
     * @type {number}
     * @memberof WebhookSubscriptionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionRead
     */
    'event'?: WebhookSubscriptionReadEventEnum | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionRead
     */
    'callbackUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionRead
     */
    'webhookSecret': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionRead
     */
    'createdAt'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookSubscriptionReadEventEnum {
    DisputeOpened = 'dispute.opened',
    DisputeSubmitted = 'dispute.submitted',
    DisputeCreated = 'dispute.created',
    DisputeAbandoned = 'dispute.abandoned',
    DisputeSettlement = 'dispute.settlement',
    DisputeClosed = 'dispute.closed',
    DisputeExpired = 'dispute.expired',
    DisputeManualArbitrationRequired = 'dispute.manual_arbitration_required',
    DisputeUpdated = 'dispute.updated',
    DisputeReminder = 'dispute.reminder',
    OfferCreated = 'offer.created',
    OfferExpired = 'offer.expired',
    OfferUpdated = 'offer.updated',
    OfferCrawlFailure = 'offer.crawl_failure',
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionReconciled = 'offer.transaction.reconciled',
    OfferTransactionAbandoned = 'offer.transaction.abandoned',
    OfferClosed = 'offer.closed',
    OfferTransactionRefund = 'offer.transaction.refund',
    PersonaAdded = 'persona.added',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface WebhookSubscriptionWrite
 */
export interface WebhookSubscriptionWrite {
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionWrite
     */
    'event'?: WebhookSubscriptionWriteEventEnum | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionWrite
     */
    'callbackUrl': string;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookSubscriptionWriteEventEnum {
    DisputeOpened = 'dispute.opened',
    DisputeSubmitted = 'dispute.submitted',
    DisputeCreated = 'dispute.created',
    DisputeAbandoned = 'dispute.abandoned',
    DisputeSettlement = 'dispute.settlement',
    DisputeClosed = 'dispute.closed',
    DisputeExpired = 'dispute.expired',
    DisputeManualArbitrationRequired = 'dispute.manual_arbitration_required',
    DisputeUpdated = 'dispute.updated',
    DisputeReminder = 'dispute.reminder',
    OfferCreated = 'offer.created',
    OfferExpired = 'offer.expired',
    OfferUpdated = 'offer.updated',
    OfferCrawlFailure = 'offer.crawl_failure',
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionReconciled = 'offer.transaction.reconciled',
    OfferTransactionAbandoned = 'offer.transaction.abandoned',
    OfferClosed = 'offer.closed',
    OfferTransactionRefund = 'offer.transaction.refund',
    PersonaAdded = 'persona.added',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface WorkflowEventDisputeRead
 */
export interface WorkflowEventDisputeRead {
    /**
     * 
     * @type {string}
     * @memberof WorkflowEventDisputeRead
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowEventDisputeRead
     */
    'from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowEventDisputeRead
     */
    'to'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowEventDisputeRead
     */
    'event'?: WorkflowEventDisputeReadEventEnum | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowEventDisputeRead
     */
    'occurredAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowEventDisputeRead
     */
    'initiator'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum WorkflowEventDisputeReadEventEnum {
    DisputeOpened = 'dispute.opened',
    DisputeSubmitted = 'dispute.submitted',
    DisputeCreated = 'dispute.created',
    DisputeAbandoned = 'dispute.abandoned',
    DisputeSettlement = 'dispute.settlement',
    DisputeClosed = 'dispute.closed',
    DisputeExpired = 'dispute.expired',
    DisputeManualArbitrationRequired = 'dispute.manual_arbitration_required',
    DisputeUpdated = 'dispute.updated',
    DisputeReminder = 'dispute.reminder',
    OfferCreated = 'offer.created',
    OfferExpired = 'offer.expired',
    OfferUpdated = 'offer.updated',
    OfferCrawlFailure = 'offer.crawl_failure',
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionReconciled = 'offer.transaction.reconciled',
    OfferTransactionAbandoned = 'offer.transaction.abandoned',
    OfferClosed = 'offer.closed',
    OfferTransactionRefund = 'offer.transaction.refund',
    PersonaAdded = 'persona.added',
    Null = 'null'
}


/**
 * BrandingApi - axios parameter creator
 * @export
 */
export const BrandingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Updates the Organization resource.
         * @summary Update your Organization details, branding or parameters
         * @param {string} id Organization identifier
         * @param {OrganizationUpdate} organizationUpdate The updated Organization resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdPatch: async (id: string, organizationUpdate: OrganizationUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdPatch', 'id', id)
            // verify required parameter 'organizationUpdate' is not null or undefined
            assertParamExists('apiOrganizationsIdPatch', 'organizationUpdate', organizationUpdate)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Icon
         * @param {number} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdiconDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdiconDelete', 'id', id)
            const localVarPath = `/organizations/{id}/icon`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization Icon
         * @param {number} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdiconPost: async (id: number, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdiconPost', 'id', id)
            const localVarPath = `/organizations/{id}/icon`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Logo
         * @param {number} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdlogoDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdlogoDelete', 'id', id)
            const localVarPath = `/organizations/{id}/logo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization logo
         * @param {number} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdlogoPost: async (id: number, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdlogoPost', 'id', id)
            const localVarPath = `/organizations/{id}/logo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrandingApi - functional programming interface
 * @export
 */
export const BrandingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrandingApiAxiosParamCreator(configuration)
    return {
        /**
         * Updates the Organization resource.
         * @summary Update your Organization details, branding or parameters
         * @param {string} id Organization identifier
         * @param {OrganizationUpdate} organizationUpdate The updated Organization resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdPatch(id: string, organizationUpdate: OrganizationUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOrganizationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdPatch(id, organizationUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandingApi.apiOrganizationsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Icon
         * @param {number} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdiconDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdiconDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandingApi.apiOrganizationsIdiconDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization Icon
         * @param {number} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdiconPost(id: number, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdiconPost(id, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandingApi.apiOrganizationsIdiconPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Logo
         * @param {number} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdlogoDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdlogoDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandingApi.apiOrganizationsIdlogoDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization logo
         * @param {number} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdlogoPost(id: number, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdlogoPost(id, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandingApi.apiOrganizationsIdlogoPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BrandingApi - factory interface
 * @export
 */
export const BrandingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrandingApiFp(configuration)
    return {
        /**
         * Updates the Organization resource.
         * @summary Update your Organization details, branding or parameters
         * @param {string} id Organization identifier
         * @param {OrganizationUpdate} organizationUpdate The updated Organization resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdPatch(id: string, organizationUpdate: OrganizationUpdate, options?: any): AxiosPromise<UserOrganizationRead> {
            return localVarFp.apiOrganizationsIdPatch(id, organizationUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Icon
         * @param {number} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdiconDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdiconDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization Icon
         * @param {number} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdiconPost(id: number, file?: File, options?: any): AxiosPromise<MediaRead> {
            return localVarFp.apiOrganizationsIdiconPost(id, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Logo
         * @param {number} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdlogoDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdlogoDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization logo
         * @param {number} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdlogoPost(id: number, file?: File, options?: any): AxiosPromise<MediaRead> {
            return localVarFp.apiOrganizationsIdlogoPost(id, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrandingApi - object-oriented interface
 * @export
 * @class BrandingApi
 * @extends {BaseAPI}
 */
export class BrandingApi extends BaseAPI {
    /**
     * Updates the Organization resource.
     * @summary Update your Organization details, branding or parameters
     * @param {string} id Organization identifier
     * @param {OrganizationUpdate} organizationUpdate The updated Organization resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdPatch(id: string, organizationUpdate: OrganizationUpdate, options?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdPatch(id, organizationUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Media resource.
     * @summary Unset your Organization Icon
     * @param {number} id Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdiconDelete(id: number, options?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdiconDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Media resource.
     * @summary Upload your Organization Icon
     * @param {number} id Organization identifier
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdiconPost(id: number, file?: File, options?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdiconPost(id, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Media resource.
     * @summary Unset your Organization Logo
     * @param {number} id Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdlogoDelete(id: number, options?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdlogoDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Media resource.
     * @summary Upload your Organization logo
     * @param {number} id Organization identifier
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdlogoPost(id: number, file?: File, options?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdlogoPost(id, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationApi - axios parameter creator
 * @export
 */
export const NotificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieve pending notifications for Persona
         * @param {string} id Notification identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdnotificationsGetCollection: async (id: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdnotificationsGetCollection', 'id', id)
            const localVarPath = `/personas/{id}/notifications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for Persona
         * @param {string} personaId Notification identifier
         * @param {string} id Notification identifier
         * @param {NotificationUpdate} notificationUpdate The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasPersonaIdnotificationsIdPatch: async (personaId: string, id: string, notificationUpdate: NotificationUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('apiPersonasPersonaIdnotificationsIdPatch', 'personaId', personaId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasPersonaIdnotificationsIdPatch', 'id', id)
            // verify required parameter 'notificationUpdate' is not null or undefined
            assertParamExists('apiPersonasPersonaIdnotificationsIdPatch', 'notificationUpdate', notificationUpdate)
            const localVarPath = `/personas/{personaId}/notifications/{id}`
                .replace(`{${"personaId"}}`, encodeURIComponent(String(personaId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieves the collection of Notification resources.
         * @param {string} id Notification identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdnotificationsGetCollection: async (id: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdnotificationsGetCollection', 'id', id)
            const localVarPath = `/users/{id}/notifications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for User
         * @param {string} userId Notification identifier
         * @param {string} id Notification identifier
         * @param {NotificationUpdate} notificationUpdate The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdnotificationsIdPatch: async (userId: string, id: string, notificationUpdate: NotificationUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdnotificationsIdPatch', 'userId', userId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersUserIdnotificationsIdPatch', 'id', id)
            // verify required parameter 'notificationUpdate' is not null or undefined
            assertParamExists('apiUsersUserIdnotificationsIdPatch', 'notificationUpdate', notificationUpdate)
            const localVarPath = `/users/{userId}/notifications/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationApi - functional programming interface
 * @export
 */
export const NotificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieve pending notifications for Persona
         * @param {string} id Notification identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdnotificationsGetCollection(id: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdnotificationsGetCollection(id, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.apiPersonasIdnotificationsGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for Persona
         * @param {string} personaId Notification identifier
         * @param {string} id Notification identifier
         * @param {NotificationUpdate} notificationUpdate The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasPersonaIdnotificationsIdPatch(personaId: string, id: string, notificationUpdate: NotificationUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasPersonaIdnotificationsIdPatch(personaId, id, notificationUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.apiPersonasPersonaIdnotificationsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieves the collection of Notification resources.
         * @param {string} id Notification identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdnotificationsGetCollection(id: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdnotificationsGetCollection(id, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.apiUsersIdnotificationsGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for User
         * @param {string} userId Notification identifier
         * @param {string} id Notification identifier
         * @param {NotificationUpdate} notificationUpdate The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdnotificationsIdPatch(userId: string, id: string, notificationUpdate: NotificationUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdnotificationsIdPatch(userId, id, notificationUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.apiUsersUserIdnotificationsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationApi - factory interface
 * @export
 */
export const NotificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieve pending notifications for Persona
         * @param {string} id Notification identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdnotificationsGetCollection(id: string, page?: number, options?: any): AxiosPromise<Array<NotificationRead>> {
            return localVarFp.apiPersonasIdnotificationsGetCollection(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for Persona
         * @param {string} personaId Notification identifier
         * @param {string} id Notification identifier
         * @param {NotificationUpdate} notificationUpdate The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasPersonaIdnotificationsIdPatch(personaId: string, id: string, notificationUpdate: NotificationUpdate, options?: any): AxiosPromise<NotificationRead> {
            return localVarFp.apiPersonasPersonaIdnotificationsIdPatch(personaId, id, notificationUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieves the collection of Notification resources.
         * @param {string} id Notification identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdnotificationsGetCollection(id: string, page?: number, options?: any): AxiosPromise<Array<NotificationRead>> {
            return localVarFp.apiUsersIdnotificationsGetCollection(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for User
         * @param {string} userId Notification identifier
         * @param {string} id Notification identifier
         * @param {NotificationUpdate} notificationUpdate The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdnotificationsIdPatch(userId: string, id: string, notificationUpdate: NotificationUpdate, options?: any): AxiosPromise<NotificationRead> {
            return localVarFp.apiUsersUserIdnotificationsIdPatch(userId, id, notificationUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
export class NotificationApi extends BaseAPI {
    /**
     * Retrieves the collection of Notification resources.
     * @summary Retrieve pending notifications for Persona
     * @param {string} id Notification identifier
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public apiPersonasIdnotificationsGetCollection(id: string, page?: number, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).apiPersonasIdnotificationsGetCollection(id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the Notification resource.
     * @summary Mark as read/unread a notification for Persona
     * @param {string} personaId Notification identifier
     * @param {string} id Notification identifier
     * @param {NotificationUpdate} notificationUpdate The updated Notification resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public apiPersonasPersonaIdnotificationsIdPatch(personaId: string, id: string, notificationUpdate: NotificationUpdate, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).apiPersonasPersonaIdnotificationsIdPatch(personaId, id, notificationUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of Notification resources.
     * @summary Retrieves the collection of Notification resources.
     * @param {string} id Notification identifier
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public apiUsersIdnotificationsGetCollection(id: string, page?: number, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).apiUsersIdnotificationsGetCollection(id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the Notification resource.
     * @summary Mark as read/unread a notification for User
     * @param {string} userId Notification identifier
     * @param {string} id Notification identifier
     * @param {NotificationUpdate} notificationUpdate The updated Notification resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public apiUsersUserIdnotificationsIdPatch(userId: string, id: string, notificationUpdate: NotificationUpdate, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).apiUsersUserIdnotificationsIdPatch(userId, id, notificationUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Organization resources.
         * @summary Retrieves the collection of Organization resources.
         * @param {number} [page] The collection page number
         * @param {number} [itemsPerPage] The number of items per page
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsGetCollection: async (page?: number, itemsPerPage?: number, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (itemsPerPage !== undefined) {
                localVarQueryParameter['itemsPerPage'] = itemsPerPage;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Organization resource.
         * @summary Retrieves a Organization resource.
         * @param {string} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdGet', 'id', id)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Organization resources.
         * @summary Retrieves the collection of Organization resources.
         * @param {number} [page] The collection page number
         * @param {number} [itemsPerPage] The number of items per page
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsGetCollection(page?: number, itemsPerPage?: number, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsGetCollection(page, itemsPerPage, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.apiOrganizationsGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a Organization resource.
         * @summary Retrieves a Organization resource.
         * @param {string} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.apiOrganizationsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Organization resources.
         * @summary Retrieves the collection of Organization resources.
         * @param {number} [page] The collection page number
         * @param {number} [itemsPerPage] The number of items per page
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsGetCollection(page?: number, itemsPerPage?: number, name?: string, options?: any): AxiosPromise<Array<OrganizationCollectionRead>> {
            return localVarFp.apiOrganizationsGetCollection(page, itemsPerPage, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Organization resource.
         * @summary Retrieves a Organization resource.
         * @param {string} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdGet(id: string, options?: any): AxiosPromise<OrganizationRead> {
            return localVarFp.apiOrganizationsIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * Retrieves the collection of Organization resources.
     * @summary Retrieves the collection of Organization resources.
     * @param {number} [page] The collection page number
     * @param {number} [itemsPerPage] The number of items per page
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public apiOrganizationsGetCollection(page?: number, itemsPerPage?: number, name?: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).apiOrganizationsGetCollection(page, itemsPerPage, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Organization resource.
     * @summary Retrieves a Organization resource.
     * @param {string} id Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public apiOrganizationsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).apiOrganizationsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PersonaApi - axios parameter creator
 * @export
 */
export const PersonaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Persona resources.
         * @summary Retrieves the collection of Persona resources.
         * @param {number} [page] The collection page number
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {Array<string>} [email2] 
         * @param {string} [mobilePhoneNumber] 
         * @param {Array<string>} [mobilePhoneNumber2] 
         * @param {ApiPersonasGetCollectionGenderEnum} [gender] Filter on a limited subset of gender
         * @param {ApiPersonasGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {string} [dateOfBirthBefore] 
         * @param {string} [dateOfBirthStrictlyBefore] 
         * @param {string} [dateOfBirthAfter] 
         * @param {string} [dateOfBirthStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasGetCollection: async (page?: number, firstName?: string, lastName?: string, email?: string, email2?: Array<string>, mobilePhoneNumber?: string, mobilePhoneNumber2?: Array<string>, gender?: ApiPersonasGetCollectionGenderEnum, orderCreatedAt?: ApiPersonasGetCollectionOrderCreatedAtEnum, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, dateOfBirthBefore?: string, dateOfBirthStrictlyBefore?: string, dateOfBirthAfter?: string, dateOfBirthStrictlyAfter?: string, metadata?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/personas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['firstName'] = firstName;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['lastName'] = lastName;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (email2) {
                localVarQueryParameter['email[]'] = email2;
            }

            if (mobilePhoneNumber !== undefined) {
                localVarQueryParameter['mobilePhoneNumber'] = mobilePhoneNumber;
            }

            if (mobilePhoneNumber2) {
                localVarQueryParameter['mobilePhoneNumber[]'] = mobilePhoneNumber2;
            }

            if (gender !== undefined) {
                localVarQueryParameter['gender'] = gender;
            }

            if (orderCreatedAt !== undefined) {
                localVarQueryParameter['order[createdAt]'] = orderCreatedAt;
            }

            if (createdAtBefore !== undefined) {
                localVarQueryParameter['createdAt[before]'] = createdAtBefore;
            }

            if (createdAtStrictlyBefore !== undefined) {
                localVarQueryParameter['createdAt[strictly_before]'] = createdAtStrictlyBefore;
            }

            if (createdAtAfter !== undefined) {
                localVarQueryParameter['createdAt[after]'] = createdAtAfter;
            }

            if (createdAtStrictlyAfter !== undefined) {
                localVarQueryParameter['createdAt[strictly_after]'] = createdAtStrictlyAfter;
            }

            if (dateOfBirthBefore !== undefined) {
                localVarQueryParameter['dateOfBirth[before]'] = dateOfBirthBefore;
            }

            if (dateOfBirthStrictlyBefore !== undefined) {
                localVarQueryParameter['dateOfBirth[strictly_before]'] = dateOfBirthStrictlyBefore;
            }

            if (dateOfBirthAfter !== undefined) {
                localVarQueryParameter['dateOfBirth[after]'] = dateOfBirthAfter;
            }

            if (dateOfBirthStrictlyAfter !== undefined) {
                localVarQueryParameter['dateOfBirth[strictly_after]'] = dateOfBirthStrictlyAfter;
            }

            if (metadata) {
                localVarQueryParameter['metadata[]'] = metadata.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You **MAY** unregister (or free the email/phone number) your Persona entry using that endpoint. *Please note that* this operation will fail if that Persona have any ongoing operations.
         * @summary Unregister a Persona (Your customer)
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdDelete', 'id', id)
            const localVarPath = `/personas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_WRITE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Persona resource.
         * @summary Retrieves a Persona resource.
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdGet', 'id', id)
            const localVarPath = `/personas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update your Persona (eg. your customer/user entry) through that API call. _Beware that updating_ **email** and/or the **mobile phone number** must be done using non reserved values. Otherwise this operation will be rejected.
         * @summary Updates the Persona resource.
         * @param {string} id Persona identifier
         * @param {PersonaUpdate} personaUpdate The updated Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdPatch: async (id: string, personaUpdate: PersonaUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdPatch', 'id', id)
            // verify required parameter 'personaUpdate' is not null or undefined
            assertParamExists('apiPersonasIdPatch', 'personaUpdate', personaUpdate)
            const localVarPath = `/personas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Without this, your users may be required to pass a MFA challenge even if they are already logged-in from your website. Pass the URL you wish your user access, either a Dispute resource.
         * @summary Issue authenticated URL for single end-user
         * @param {string} id Persona identifier
         * @param {PersonaTokenWrite} personaTokenWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdtokenPost: async (id: string, personaTokenWrite: PersonaTokenWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdtokenPost', 'id', id)
            // verify required parameter 'personaTokenWrite' is not null or undefined
            assertParamExists('apiPersonasIdtokenPost', 'personaTokenWrite', personaTokenWrite)
            const localVarPath = `/personas/{id}/token`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_AUTH"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaTokenWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You should not register your whole database of users, only those who are concerned by a Dispute operation. One Persona entry for your organization can be assigned as a seller or buyer.  **Notes:**   - (i) There is a unique constraint for the mobile phone numbers and email.   - (ii) You will have to issue a DELETE operation on a Persona that withhold a specific phone number or email.   - (iii) You are NOT REQUIRED to provide email OR a mobile phone number but it is highly recommended, if none provided the email will be generated as \'{ulid}@your-domain.tld\'. In that case, please specify at least one metadata in order to find your entry with ease.
         * @summary Register a Persona (Your customer)
         * @param {PersonaWrite} personaWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasPost: async (personaWrite: PersonaWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaWrite' is not null or undefined
            assertParamExists('apiPersonasPost', 'personaWrite', personaWrite)
            const localVarPath = `/personas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonaApi - functional programming interface
 * @export
 */
export const PersonaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonaApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Persona resources.
         * @summary Retrieves the collection of Persona resources.
         * @param {number} [page] The collection page number
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {Array<string>} [email2] 
         * @param {string} [mobilePhoneNumber] 
         * @param {Array<string>} [mobilePhoneNumber2] 
         * @param {ApiPersonasGetCollectionGenderEnum} [gender] Filter on a limited subset of gender
         * @param {ApiPersonasGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {string} [dateOfBirthBefore] 
         * @param {string} [dateOfBirthStrictlyBefore] 
         * @param {string} [dateOfBirthAfter] 
         * @param {string} [dateOfBirthStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasGetCollection(page?: number, firstName?: string, lastName?: string, email?: string, email2?: Array<string>, mobilePhoneNumber?: string, mobilePhoneNumber2?: Array<string>, gender?: ApiPersonasGetCollectionGenderEnum, orderCreatedAt?: ApiPersonasGetCollectionOrderCreatedAtEnum, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, dateOfBirthBefore?: string, dateOfBirthStrictlyBefore?: string, dateOfBirthAfter?: string, dateOfBirthStrictlyAfter?: string, metadata?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PersonaCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasGetCollection(page, firstName, lastName, email, email2, mobilePhoneNumber, mobilePhoneNumber2, gender, orderCreatedAt, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, dateOfBirthBefore, dateOfBirthStrictlyBefore, dateOfBirthAfter, dateOfBirthStrictlyAfter, metadata, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.apiPersonasGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You **MAY** unregister (or free the email/phone number) your Persona entry using that endpoint. *Please note that* this operation will fail if that Persona have any ongoing operations.
         * @summary Unregister a Persona (Your customer)
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.apiPersonasIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a Persona resource.
         * @summary Retrieves a Persona resource.
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.apiPersonasIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update your Persona (eg. your customer/user entry) through that API call. _Beware that updating_ **email** and/or the **mobile phone number** must be done using non reserved values. Otherwise this operation will be rejected.
         * @summary Updates the Persona resource.
         * @param {string} id Persona identifier
         * @param {PersonaUpdate} personaUpdate The updated Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdPatch(id: string, personaUpdate: PersonaUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdPatch(id, personaUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.apiPersonasIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Without this, your users may be required to pass a MFA challenge even if they are already logged-in from your website. Pass the URL you wish your user access, either a Dispute resource.
         * @summary Issue authenticated URL for single end-user
         * @param {string} id Persona identifier
         * @param {PersonaTokenWrite} personaTokenWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdtokenPost(id: string, personaTokenWrite: PersonaTokenWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaPostAuthRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdtokenPost(id, personaTokenWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.apiPersonasIdtokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You should not register your whole database of users, only those who are concerned by a Dispute operation. One Persona entry for your organization can be assigned as a seller or buyer.  **Notes:**   - (i) There is a unique constraint for the mobile phone numbers and email.   - (ii) You will have to issue a DELETE operation on a Persona that withhold a specific phone number or email.   - (iii) You are NOT REQUIRED to provide email OR a mobile phone number but it is highly recommended, if none provided the email will be generated as \'{ulid}@your-domain.tld\'. In that case, please specify at least one metadata in order to find your entry with ease.
         * @summary Register a Persona (Your customer)
         * @param {PersonaWrite} personaWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasPost(personaWrite: PersonaWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasPost(personaWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.apiPersonasPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PersonaApi - factory interface
 * @export
 */
export const PersonaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonaApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Persona resources.
         * @summary Retrieves the collection of Persona resources.
         * @param {number} [page] The collection page number
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {Array<string>} [email2] 
         * @param {string} [mobilePhoneNumber] 
         * @param {Array<string>} [mobilePhoneNumber2] 
         * @param {ApiPersonasGetCollectionGenderEnum} [gender] Filter on a limited subset of gender
         * @param {ApiPersonasGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {string} [dateOfBirthBefore] 
         * @param {string} [dateOfBirthStrictlyBefore] 
         * @param {string} [dateOfBirthAfter] 
         * @param {string} [dateOfBirthStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasGetCollection(page?: number, firstName?: string, lastName?: string, email?: string, email2?: Array<string>, mobilePhoneNumber?: string, mobilePhoneNumber2?: Array<string>, gender?: ApiPersonasGetCollectionGenderEnum, orderCreatedAt?: ApiPersonasGetCollectionOrderCreatedAtEnum, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, dateOfBirthBefore?: string, dateOfBirthStrictlyBefore?: string, dateOfBirthAfter?: string, dateOfBirthStrictlyAfter?: string, metadata?: Array<string>, options?: any): AxiosPromise<Array<PersonaCollectionRead>> {
            return localVarFp.apiPersonasGetCollection(page, firstName, lastName, email, email2, mobilePhoneNumber, mobilePhoneNumber2, gender, orderCreatedAt, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, dateOfBirthBefore, dateOfBirthStrictlyBefore, dateOfBirthAfter, dateOfBirthStrictlyAfter, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * You **MAY** unregister (or free the email/phone number) your Persona entry using that endpoint. *Please note that* this operation will fail if that Persona have any ongoing operations.
         * @summary Unregister a Persona (Your customer)
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiPersonasIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Persona resource.
         * @summary Retrieves a Persona resource.
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdGet(id: string, options?: any): AxiosPromise<PersonaRead> {
            return localVarFp.apiPersonasIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update your Persona (eg. your customer/user entry) through that API call. _Beware that updating_ **email** and/or the **mobile phone number** must be done using non reserved values. Otherwise this operation will be rejected.
         * @summary Updates the Persona resource.
         * @param {string} id Persona identifier
         * @param {PersonaUpdate} personaUpdate The updated Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdPatch(id: string, personaUpdate: PersonaUpdate, options?: any): AxiosPromise<PersonaRead> {
            return localVarFp.apiPersonasIdPatch(id, personaUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Without this, your users may be required to pass a MFA challenge even if they are already logged-in from your website. Pass the URL you wish your user access, either a Dispute resource.
         * @summary Issue authenticated URL for single end-user
         * @param {string} id Persona identifier
         * @param {PersonaTokenWrite} personaTokenWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdtokenPost(id: string, personaTokenWrite: PersonaTokenWrite, options?: any): AxiosPromise<PersonaPostAuthRead> {
            return localVarFp.apiPersonasIdtokenPost(id, personaTokenWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * You should not register your whole database of users, only those who are concerned by a Dispute operation. One Persona entry for your organization can be assigned as a seller or buyer.  **Notes:**   - (i) There is a unique constraint for the mobile phone numbers and email.   - (ii) You will have to issue a DELETE operation on a Persona that withhold a specific phone number or email.   - (iii) You are NOT REQUIRED to provide email OR a mobile phone number but it is highly recommended, if none provided the email will be generated as \'{ulid}@your-domain.tld\'. In that case, please specify at least one metadata in order to find your entry with ease.
         * @summary Register a Persona (Your customer)
         * @param {PersonaWrite} personaWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasPost(personaWrite: PersonaWrite, options?: any): AxiosPromise<PersonaRead> {
            return localVarFp.apiPersonasPost(personaWrite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonaApi - object-oriented interface
 * @export
 * @class PersonaApi
 * @extends {BaseAPI}
 */
export class PersonaApi extends BaseAPI {
    /**
     * Retrieves the collection of Persona resources.
     * @summary Retrieves the collection of Persona resources.
     * @param {number} [page] The collection page number
     * @param {string} [firstName] 
     * @param {string} [lastName] 
     * @param {string} [email] 
     * @param {Array<string>} [email2] 
     * @param {string} [mobilePhoneNumber] 
     * @param {Array<string>} [mobilePhoneNumber2] 
     * @param {ApiPersonasGetCollectionGenderEnum} [gender] Filter on a limited subset of gender
     * @param {ApiPersonasGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
     * @param {string} [createdAtBefore] 
     * @param {string} [createdAtStrictlyBefore] 
     * @param {string} [createdAtAfter] 
     * @param {string} [createdAtStrictlyAfter] 
     * @param {string} [dateOfBirthBefore] 
     * @param {string} [dateOfBirthStrictlyBefore] 
     * @param {string} [dateOfBirthAfter] 
     * @param {string} [dateOfBirthStrictlyAfter] 
     * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasGetCollection(page?: number, firstName?: string, lastName?: string, email?: string, email2?: Array<string>, mobilePhoneNumber?: string, mobilePhoneNumber2?: Array<string>, gender?: ApiPersonasGetCollectionGenderEnum, orderCreatedAt?: ApiPersonasGetCollectionOrderCreatedAtEnum, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, dateOfBirthBefore?: string, dateOfBirthStrictlyBefore?: string, dateOfBirthAfter?: string, dateOfBirthStrictlyAfter?: string, metadata?: Array<string>, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasGetCollection(page, firstName, lastName, email, email2, mobilePhoneNumber, mobilePhoneNumber2, gender, orderCreatedAt, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, dateOfBirthBefore, dateOfBirthStrictlyBefore, dateOfBirthAfter, dateOfBirthStrictlyAfter, metadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You **MAY** unregister (or free the email/phone number) your Persona entry using that endpoint. *Please note that* this operation will fail if that Persona have any ongoing operations.
     * @summary Unregister a Persona (Your customer)
     * @param {string} id Persona identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Persona resource.
     * @summary Retrieves a Persona resource.
     * @param {string} id Persona identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasIdGet(id: string, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update your Persona (eg. your customer/user entry) through that API call. _Beware that updating_ **email** and/or the **mobile phone number** must be done using non reserved values. Otherwise this operation will be rejected.
     * @summary Updates the Persona resource.
     * @param {string} id Persona identifier
     * @param {PersonaUpdate} personaUpdate The updated Persona resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasIdPatch(id: string, personaUpdate: PersonaUpdate, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasIdPatch(id, personaUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Without this, your users may be required to pass a MFA challenge even if they are already logged-in from your website. Pass the URL you wish your user access, either a Dispute resource.
     * @summary Issue authenticated URL for single end-user
     * @param {string} id Persona identifier
     * @param {PersonaTokenWrite} personaTokenWrite The new Persona resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasIdtokenPost(id: string, personaTokenWrite: PersonaTokenWrite, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasIdtokenPost(id, personaTokenWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You should not register your whole database of users, only those who are concerned by a Dispute operation. One Persona entry for your organization can be assigned as a seller or buyer.  **Notes:**   - (i) There is a unique constraint for the mobile phone numbers and email.   - (ii) You will have to issue a DELETE operation on a Persona that withhold a specific phone number or email.   - (iii) You are NOT REQUIRED to provide email OR a mobile phone number but it is highly recommended, if none provided the email will be generated as \'{ulid}@your-domain.tld\'. In that case, please specify at least one metadata in order to find your entry with ease.
     * @summary Register a Persona (Your customer)
     * @param {PersonaWrite} personaWrite The new Persona resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasPost(personaWrite: PersonaWrite, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasPost(personaWrite, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum ApiPersonasGetCollectionGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiPersonasGetCollectionOrderCreatedAtEnum {
    Asc = 'asc',
    Desc = 'desc'
}


/**
 * ResolutionCenterApi - axios parameter creator
 * @export
 */
export const ResolutionCenterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Dispute resources.
         * @summary Retrieves the collection of Dispute resources.
         * @param {number} [page] The collection page number
         * @param {ApiDisputesGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
         * @param {ApiDisputesGetCollectionOrderStatusEnum} [orderStatus] 
         * @param {ApiDisputesGetCollectionOrderUpdatedAtEnum} [orderUpdatedAt] 
         * @param {string} [transactionOfferPublicUrl] 
         * @param {Array<string>} [transactionOfferPublicUrl2] 
         * @param {string} [transactionOfferTitle] 
         * @param {number} [transactionBuyerId] 
         * @param {Array<number>} [transactionBuyerId2] 
         * @param {string} [transactionBuyerEmail] 
         * @param {number} [transactionOfferSellerId] 
         * @param {Array<number>} [transactionOfferSellerId2] 
         * @param {string} [transactionOfferSellerEmail] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {ApiDisputesGetCollectionStatusEnum} [status] Filter on a limited subset of status
         * @param {ApiDisputesGetCollectionTransactionStatusEnum} [transactionStatus] Filter on a limited subset of transaction.status
         * @param {boolean} [existsRecommendedSolution] 
         * @param {boolean} [existsChosenSolution] 
         * @param {boolean} [existsCounterSolution] 
         * @param {boolean} [existsPlatformSolution] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [transactionMetadata] Flattened OrderedMap for transaction.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [transactionOfferMetadata] Flattened OrderedMap for transaction.offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesGetCollection: async (page?: number, orderCreatedAt?: ApiDisputesGetCollectionOrderCreatedAtEnum, orderStatus?: ApiDisputesGetCollectionOrderStatusEnum, orderUpdatedAt?: ApiDisputesGetCollectionOrderUpdatedAtEnum, transactionOfferPublicUrl?: string, transactionOfferPublicUrl2?: Array<string>, transactionOfferTitle?: string, transactionBuyerId?: number, transactionBuyerId2?: Array<number>, transactionBuyerEmail?: string, transactionOfferSellerId?: number, transactionOfferSellerId2?: Array<number>, transactionOfferSellerEmail?: string, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, status?: ApiDisputesGetCollectionStatusEnum, transactionStatus?: ApiDisputesGetCollectionTransactionStatusEnum, existsRecommendedSolution?: boolean, existsChosenSolution?: boolean, existsCounterSolution?: boolean, existsPlatformSolution?: boolean, metadata?: Array<string>, transactionMetadata?: Array<string>, transactionOfferMetadata?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/disputes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderCreatedAt !== undefined) {
                localVarQueryParameter['order[createdAt]'] = orderCreatedAt;
            }

            if (orderStatus !== undefined) {
                localVarQueryParameter['order[status]'] = orderStatus;
            }

            if (orderUpdatedAt !== undefined) {
                localVarQueryParameter['order[updatedAt]'] = orderUpdatedAt;
            }

            if (transactionOfferPublicUrl !== undefined) {
                localVarQueryParameter['transaction.offer.publicUrl'] = transactionOfferPublicUrl;
            }

            if (transactionOfferPublicUrl2) {
                localVarQueryParameter['transaction.offer.publicUrl[]'] = transactionOfferPublicUrl2;
            }

            if (transactionOfferTitle !== undefined) {
                localVarQueryParameter['transaction.offer.title'] = transactionOfferTitle;
            }

            if (transactionBuyerId !== undefined) {
                localVarQueryParameter['transaction.buyer.id'] = transactionBuyerId;
            }

            if (transactionBuyerId2) {
                localVarQueryParameter['transaction.buyer.id[]'] = transactionBuyerId2;
            }

            if (transactionBuyerEmail !== undefined) {
                localVarQueryParameter['transaction.buyer.email'] = transactionBuyerEmail;
            }

            if (transactionOfferSellerId !== undefined) {
                localVarQueryParameter['transaction.offer.seller.id'] = transactionOfferSellerId;
            }

            if (transactionOfferSellerId2) {
                localVarQueryParameter['transaction.offer.seller.id[]'] = transactionOfferSellerId2;
            }

            if (transactionOfferSellerEmail !== undefined) {
                localVarQueryParameter['transaction.offer.seller.email'] = transactionOfferSellerEmail;
            }

            if (createdAtBefore !== undefined) {
                localVarQueryParameter['createdAt[before]'] = createdAtBefore;
            }

            if (createdAtStrictlyBefore !== undefined) {
                localVarQueryParameter['createdAt[strictly_before]'] = createdAtStrictlyBefore;
            }

            if (createdAtAfter !== undefined) {
                localVarQueryParameter['createdAt[after]'] = createdAtAfter;
            }

            if (createdAtStrictlyAfter !== undefined) {
                localVarQueryParameter['createdAt[strictly_after]'] = createdAtStrictlyAfter;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (transactionStatus !== undefined) {
                localVarQueryParameter['transaction.status'] = transactionStatus;
            }

            if (existsRecommendedSolution !== undefined) {
                localVarQueryParameter['exists[recommendedSolution]'] = existsRecommendedSolution;
            }

            if (existsChosenSolution !== undefined) {
                localVarQueryParameter['exists[chosenSolution]'] = existsChosenSolution;
            }

            if (existsCounterSolution !== undefined) {
                localVarQueryParameter['exists[counterSolution]'] = existsCounterSolution;
            }

            if (existsPlatformSolution !== undefined) {
                localVarQueryParameter['exists[platformSolution]'] = existsPlatformSolution;
            }

            if (metadata) {
                localVarQueryParameter['metadata[]'] = metadata.join(COLLECTION_FORMATS.csv);
            }

            if (transactionMetadata) {
                localVarQueryParameter['transaction.metadata[]'] = transactionMetadata.join(COLLECTION_FORMATS.csv);
            }

            if (transactionOfferMetadata) {
                localVarQueryParameter['transaction.offer.metadata[]'] = transactionOfferMetadata.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a draft dispute to be filled by an alleged aggrieved customer. Do not use that endpoint if the transaction took place using our safe-checkout tunnel. This endpoint return a unique URL that can be accessed by both the complainant and seller (if individual).  **Note:** You can generate at your own discretion tokens for both parties, thus avoiding the secondary authentication.
         * @summary Draft a standalone Dispute
         * @param {DisputeIndependentWrite} disputeIndependentWrite The new Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesPost: async (disputeIndependentWrite: DisputeIndependentWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'disputeIndependentWrite' is not null or undefined
            assertParamExists('apiDisputesPost', 'disputeIndependentWrite', disputeIndependentWrite)
            const localVarPath = `/disputes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_WRITE", "PERSONA_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disputeIndependentWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Only the buyer/complainant** can dismiss the case immediately. Otherwise, the support can but in a limited ranges of Dispute status.
         * @summary Abandon claims on Dispute
         * @param {string} ulid Dispute identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidDelete: async (ulid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidDelete', 'ulid', ulid)
            const localVarPath = `/disputes/{ulid}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_WRITE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Dispute resource.
         * @summary Retrieves a Dispute resource.
         * @param {string} ulid Dispute identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidGet: async (ulid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidGet', 'ulid', ulid)
            const localVarPath = `/disputes/{ulid}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the Dispute resource.
         * @summary Update the Dispute
         * @param {string} ulid Dispute identifier
         * @param {DisputeUpdate} disputeUpdate The updated Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidPatch: async (ulid: string, disputeUpdate: DisputeUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidPatch', 'ulid', ulid)
            // verify required parameter 'disputeUpdate' is not null or undefined
            assertParamExists('apiDisputesUlidPatch', 'disputeUpdate', disputeUpdate)
            const localVarPath = `/disputes/{ulid}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_ARBITRATION"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disputeUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Only authenticated** complainant and seller **CAN** issue an evaluation **WHEN** the dispute reached a final state.
         * @summary Submit an Evaluation for the Dispute
         * @param {string} ulid Evaluation identifier
         * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevaluationsPost: async (ulid: string, evaluationWrite: EvaluationWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidevaluationsPost', 'ulid', ulid)
            // verify required parameter 'evaluationWrite' is not null or undefined
            assertParamExists('apiDisputesUlidevaluationsPost', 'evaluationWrite', evaluationWrite)
            const localVarPath = `/disputes/{ulid}/evaluations`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(evaluationWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of Evidence resources.
         * @summary Retrieve all Evidences in Dispute
         * @param {string} ulid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesGetCollection: async (ulid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidevidencesGetCollection', 'ulid', ulid)
            const localVarPath = `/disputes/{ulid}/evidences`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Evidence resource.
         * @summary Withdraw an Evidence from a Dispute
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesIdDelete: async (ulid: string, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidevidencesIdDelete', 'ulid', ulid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiDisputesUlidevidencesIdDelete', 'id', id)
            const localVarPath = `/disputes/{ulid}/evidences/{id}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Media resource.
         * @summary Upload attachment in regard of described Evidence
         * @param {string} ulid 
         * @param {number} id 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesIdmediaPost: async (ulid: string, id: number, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidevidencesIdmediaPost', 'ulid', ulid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiDisputesUlidevidencesIdmediaPost', 'id', id)
            const localVarPath = `/disputes/{ulid}/evidences/{id}/media`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This action does not held the actual upload, you will have to do the upload in a dedicated request.
         * @summary Submit an Evidence to the Dispute case
         * @param {string} ulid 
         * @param {EvidenceWrite} evidenceWrite The new Evidence resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesPost: async (ulid: string, evidenceWrite: EvidenceWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidevidencesPost', 'ulid', ulid)
            // verify required parameter 'evidenceWrite' is not null or undefined
            assertParamExists('apiDisputesUlidevidencesPost', 'evidenceWrite', evidenceWrite)
            const localVarPath = `/disputes/{ulid}/evidences`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(evidenceWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of Parcel resources.
         * @summary Retrieves the collection of Parcel resources.
         * @param {string} ulid 
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidparcelsGetCollection: async (ulid: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidparcelsGetCollection', 'ulid', ulid)
            const localVarPath = `/disputes/{ulid}/parcels`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Parcel resource.
         * @summary Removes the Parcel resource.
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidparcelsIdDelete: async (ulid: string, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidparcelsIdDelete', 'ulid', ulid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiDisputesUlidparcelsIdDelete', 'id', id)
            const localVarPath = `/disputes/{ulid}/parcels/{id}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Parcel resource.
         * @summary Creates a Parcel resource.
         * @param {string} ulid 
         * @param {ParcelWrite} parcelWrite The new Parcel resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidparcelsPost: async (ulid: string, parcelWrite: ParcelWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidparcelsPost', 'ulid', ulid)
            // verify required parameter 'parcelWrite' is not null or undefined
            assertParamExists('apiDisputesUlidparcelsPost', 'parcelWrite', parcelWrite)
            const localVarPath = `/disputes/{ulid}/parcels`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(parcelWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Media resource.
         * @summary Removes the Media resource.
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasIdDelete: async (ulid: string, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidmediasIdDelete', 'ulid', ulid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOffersUlidmediasIdDelete', 'id', id)
            const localVarPath = `/offers/{ulid}/medias/{id}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Media resource.
         * @summary Upload a picture for a given Offer
         * @param {string} ulid 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasPost: async (ulid: string, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidmediasPost', 'ulid', ulid)
            const localVarPath = `/offers/{ulid}/medias`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResolutionCenterApi - functional programming interface
 * @export
 */
export const ResolutionCenterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResolutionCenterApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Dispute resources.
         * @summary Retrieves the collection of Dispute resources.
         * @param {number} [page] The collection page number
         * @param {ApiDisputesGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
         * @param {ApiDisputesGetCollectionOrderStatusEnum} [orderStatus] 
         * @param {ApiDisputesGetCollectionOrderUpdatedAtEnum} [orderUpdatedAt] 
         * @param {string} [transactionOfferPublicUrl] 
         * @param {Array<string>} [transactionOfferPublicUrl2] 
         * @param {string} [transactionOfferTitle] 
         * @param {number} [transactionBuyerId] 
         * @param {Array<number>} [transactionBuyerId2] 
         * @param {string} [transactionBuyerEmail] 
         * @param {number} [transactionOfferSellerId] 
         * @param {Array<number>} [transactionOfferSellerId2] 
         * @param {string} [transactionOfferSellerEmail] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {ApiDisputesGetCollectionStatusEnum} [status] Filter on a limited subset of status
         * @param {ApiDisputesGetCollectionTransactionStatusEnum} [transactionStatus] Filter on a limited subset of transaction.status
         * @param {boolean} [existsRecommendedSolution] 
         * @param {boolean} [existsChosenSolution] 
         * @param {boolean} [existsCounterSolution] 
         * @param {boolean} [existsPlatformSolution] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [transactionMetadata] Flattened OrderedMap for transaction.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [transactionOfferMetadata] Flattened OrderedMap for transaction.offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesGetCollection(page?: number, orderCreatedAt?: ApiDisputesGetCollectionOrderCreatedAtEnum, orderStatus?: ApiDisputesGetCollectionOrderStatusEnum, orderUpdatedAt?: ApiDisputesGetCollectionOrderUpdatedAtEnum, transactionOfferPublicUrl?: string, transactionOfferPublicUrl2?: Array<string>, transactionOfferTitle?: string, transactionBuyerId?: number, transactionBuyerId2?: Array<number>, transactionBuyerEmail?: string, transactionOfferSellerId?: number, transactionOfferSellerId2?: Array<number>, transactionOfferSellerEmail?: string, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, status?: ApiDisputesGetCollectionStatusEnum, transactionStatus?: ApiDisputesGetCollectionTransactionStatusEnum, existsRecommendedSolution?: boolean, existsChosenSolution?: boolean, existsCounterSolution?: boolean, existsPlatformSolution?: boolean, metadata?: Array<string>, transactionMetadata?: Array<string>, transactionOfferMetadata?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DisputeCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesGetCollection(page, orderCreatedAt, orderStatus, orderUpdatedAt, transactionOfferPublicUrl, transactionOfferPublicUrl2, transactionOfferTitle, transactionBuyerId, transactionBuyerId2, transactionBuyerEmail, transactionOfferSellerId, transactionOfferSellerId2, transactionOfferSellerEmail, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, status, transactionStatus, existsRecommendedSolution, existsChosenSolution, existsCounterSolution, existsPlatformSolution, metadata, transactionMetadata, transactionOfferMetadata, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResolutionCenterApi.apiDisputesGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a draft dispute to be filled by an alleged aggrieved customer. Do not use that endpoint if the transaction took place using our safe-checkout tunnel. This endpoint return a unique URL that can be accessed by both the complainant and seller (if individual).  **Note:** You can generate at your own discretion tokens for both parties, thus avoiding the secondary authentication.
         * @summary Draft a standalone Dispute
         * @param {DisputeIndependentWrite} disputeIndependentWrite The new Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesPost(disputeIndependentWrite: DisputeIndependentWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisputePostCreationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesPost(disputeIndependentWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResolutionCenterApi.apiDisputesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * **Only the buyer/complainant** can dismiss the case immediately. Otherwise, the support can but in a limited ranges of Dispute status.
         * @summary Abandon claims on Dispute
         * @param {string} ulid Dispute identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidDelete(ulid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidDelete(ulid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResolutionCenterApi.apiDisputesUlidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a Dispute resource.
         * @summary Retrieves a Dispute resource.
         * @param {string} ulid Dispute identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidGet(ulid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisputeRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidGet(ulid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResolutionCenterApi.apiDisputesUlidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the Dispute resource.
         * @summary Update the Dispute
         * @param {string} ulid Dispute identifier
         * @param {DisputeUpdate} disputeUpdate The updated Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidPatch(ulid: string, disputeUpdate: DisputeUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisputeRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidPatch(ulid, disputeUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResolutionCenterApi.apiDisputesUlidPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * **Only authenticated** complainant and seller **CAN** issue an evaluation **WHEN** the dispute reached a final state.
         * @summary Submit an Evaluation for the Dispute
         * @param {string} ulid Evaluation identifier
         * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidevaluationsPost(ulid: string, evaluationWrite: EvaluationWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EvaluationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidevaluationsPost(ulid, evaluationWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResolutionCenterApi.apiDisputesUlidevaluationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the collection of Evidence resources.
         * @summary Retrieve all Evidences in Dispute
         * @param {string} ulid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidevidencesGetCollection(ulid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EvidenceRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidevidencesGetCollection(ulid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResolutionCenterApi.apiDisputesUlidevidencesGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the Evidence resource.
         * @summary Withdraw an Evidence from a Dispute
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidevidencesIdDelete(ulid: string, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidevidencesIdDelete(ulid, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResolutionCenterApi.apiDisputesUlidevidencesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Media resource.
         * @summary Upload attachment in regard of described Evidence
         * @param {string} ulid 
         * @param {number} id 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidevidencesIdmediaPost(ulid: string, id: number, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidevidencesIdmediaPost(ulid, id, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResolutionCenterApi.apiDisputesUlidevidencesIdmediaPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This action does not held the actual upload, you will have to do the upload in a dedicated request.
         * @summary Submit an Evidence to the Dispute case
         * @param {string} ulid 
         * @param {EvidenceWrite} evidenceWrite The new Evidence resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidevidencesPost(ulid: string, evidenceWrite: EvidenceWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EvidenceRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidevidencesPost(ulid, evidenceWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResolutionCenterApi.apiDisputesUlidevidencesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the collection of Parcel resources.
         * @summary Retrieves the collection of Parcel resources.
         * @param {string} ulid 
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidparcelsGetCollection(ulid: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidparcelsGetCollection(ulid, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResolutionCenterApi.apiDisputesUlidparcelsGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the Parcel resource.
         * @summary Removes the Parcel resource.
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidparcelsIdDelete(ulid: string, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidparcelsIdDelete(ulid, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResolutionCenterApi.apiDisputesUlidparcelsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Parcel resource.
         * @summary Creates a Parcel resource.
         * @param {string} ulid 
         * @param {ParcelWrite} parcelWrite The new Parcel resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidparcelsPost(ulid: string, parcelWrite: ParcelWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidparcelsPost(ulid, parcelWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResolutionCenterApi.apiDisputesUlidparcelsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the Media resource.
         * @summary Removes the Media resource.
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidmediasIdDelete(ulid: string, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidmediasIdDelete(ulid, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResolutionCenterApi.apiOffersUlidmediasIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Media resource.
         * @summary Upload a picture for a given Offer
         * @param {string} ulid 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidmediasPost(ulid: string, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidmediasPost(ulid, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResolutionCenterApi.apiOffersUlidmediasPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResolutionCenterApi - factory interface
 * @export
 */
export const ResolutionCenterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResolutionCenterApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Dispute resources.
         * @summary Retrieves the collection of Dispute resources.
         * @param {number} [page] The collection page number
         * @param {ApiDisputesGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
         * @param {ApiDisputesGetCollectionOrderStatusEnum} [orderStatus] 
         * @param {ApiDisputesGetCollectionOrderUpdatedAtEnum} [orderUpdatedAt] 
         * @param {string} [transactionOfferPublicUrl] 
         * @param {Array<string>} [transactionOfferPublicUrl2] 
         * @param {string} [transactionOfferTitle] 
         * @param {number} [transactionBuyerId] 
         * @param {Array<number>} [transactionBuyerId2] 
         * @param {string} [transactionBuyerEmail] 
         * @param {number} [transactionOfferSellerId] 
         * @param {Array<number>} [transactionOfferSellerId2] 
         * @param {string} [transactionOfferSellerEmail] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {ApiDisputesGetCollectionStatusEnum} [status] Filter on a limited subset of status
         * @param {ApiDisputesGetCollectionTransactionStatusEnum} [transactionStatus] Filter on a limited subset of transaction.status
         * @param {boolean} [existsRecommendedSolution] 
         * @param {boolean} [existsChosenSolution] 
         * @param {boolean} [existsCounterSolution] 
         * @param {boolean} [existsPlatformSolution] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [transactionMetadata] Flattened OrderedMap for transaction.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [transactionOfferMetadata] Flattened OrderedMap for transaction.offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesGetCollection(page?: number, orderCreatedAt?: ApiDisputesGetCollectionOrderCreatedAtEnum, orderStatus?: ApiDisputesGetCollectionOrderStatusEnum, orderUpdatedAt?: ApiDisputesGetCollectionOrderUpdatedAtEnum, transactionOfferPublicUrl?: string, transactionOfferPublicUrl2?: Array<string>, transactionOfferTitle?: string, transactionBuyerId?: number, transactionBuyerId2?: Array<number>, transactionBuyerEmail?: string, transactionOfferSellerId?: number, transactionOfferSellerId2?: Array<number>, transactionOfferSellerEmail?: string, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, status?: ApiDisputesGetCollectionStatusEnum, transactionStatus?: ApiDisputesGetCollectionTransactionStatusEnum, existsRecommendedSolution?: boolean, existsChosenSolution?: boolean, existsCounterSolution?: boolean, existsPlatformSolution?: boolean, metadata?: Array<string>, transactionMetadata?: Array<string>, transactionOfferMetadata?: Array<string>, options?: any): AxiosPromise<Array<DisputeCollectionRead>> {
            return localVarFp.apiDisputesGetCollection(page, orderCreatedAt, orderStatus, orderUpdatedAt, transactionOfferPublicUrl, transactionOfferPublicUrl2, transactionOfferTitle, transactionBuyerId, transactionBuyerId2, transactionBuyerEmail, transactionOfferSellerId, transactionOfferSellerId2, transactionOfferSellerEmail, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, status, transactionStatus, existsRecommendedSolution, existsChosenSolution, existsCounterSolution, existsPlatformSolution, metadata, transactionMetadata, transactionOfferMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a draft dispute to be filled by an alleged aggrieved customer. Do not use that endpoint if the transaction took place using our safe-checkout tunnel. This endpoint return a unique URL that can be accessed by both the complainant and seller (if individual).  **Note:** You can generate at your own discretion tokens for both parties, thus avoiding the secondary authentication.
         * @summary Draft a standalone Dispute
         * @param {DisputeIndependentWrite} disputeIndependentWrite The new Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesPost(disputeIndependentWrite: DisputeIndependentWrite, options?: any): AxiosPromise<DisputePostCreationRead> {
            return localVarFp.apiDisputesPost(disputeIndependentWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * **Only the buyer/complainant** can dismiss the case immediately. Otherwise, the support can but in a limited ranges of Dispute status.
         * @summary Abandon claims on Dispute
         * @param {string} ulid Dispute identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidDelete(ulid: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiDisputesUlidDelete(ulid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Dispute resource.
         * @summary Retrieves a Dispute resource.
         * @param {string} ulid Dispute identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidGet(ulid: string, options?: any): AxiosPromise<DisputeRead> {
            return localVarFp.apiDisputesUlidGet(ulid, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the Dispute resource.
         * @summary Update the Dispute
         * @param {string} ulid Dispute identifier
         * @param {DisputeUpdate} disputeUpdate The updated Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidPatch(ulid: string, disputeUpdate: DisputeUpdate, options?: any): AxiosPromise<DisputeRead> {
            return localVarFp.apiDisputesUlidPatch(ulid, disputeUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * **Only authenticated** complainant and seller **CAN** issue an evaluation **WHEN** the dispute reached a final state.
         * @summary Submit an Evaluation for the Dispute
         * @param {string} ulid Evaluation identifier
         * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevaluationsPost(ulid: string, evaluationWrite: EvaluationWrite, options?: any): AxiosPromise<EvaluationRead> {
            return localVarFp.apiDisputesUlidevaluationsPost(ulid, evaluationWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of Evidence resources.
         * @summary Retrieve all Evidences in Dispute
         * @param {string} ulid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesGetCollection(ulid: string, options?: any): AxiosPromise<Array<EvidenceRead>> {
            return localVarFp.apiDisputesUlidevidencesGetCollection(ulid, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Evidence resource.
         * @summary Withdraw an Evidence from a Dispute
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesIdDelete(ulid: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiDisputesUlidevidencesIdDelete(ulid, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Media resource.
         * @summary Upload attachment in regard of described Evidence
         * @param {string} ulid 
         * @param {number} id 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesIdmediaPost(ulid: string, id: number, file?: File, options?: any): AxiosPromise<MediaRead> {
            return localVarFp.apiDisputesUlidevidencesIdmediaPost(ulid, id, file, options).then((request) => request(axios, basePath));
        },
        /**
         * This action does not held the actual upload, you will have to do the upload in a dedicated request.
         * @summary Submit an Evidence to the Dispute case
         * @param {string} ulid 
         * @param {EvidenceWrite} evidenceWrite The new Evidence resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesPost(ulid: string, evidenceWrite: EvidenceWrite, options?: any): AxiosPromise<EvidenceRead> {
            return localVarFp.apiDisputesUlidevidencesPost(ulid, evidenceWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of Parcel resources.
         * @summary Retrieves the collection of Parcel resources.
         * @param {string} ulid 
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidparcelsGetCollection(ulid: string, page?: number, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.apiDisputesUlidparcelsGetCollection(ulid, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Parcel resource.
         * @summary Removes the Parcel resource.
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidparcelsIdDelete(ulid: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiDisputesUlidparcelsIdDelete(ulid, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Parcel resource.
         * @summary Creates a Parcel resource.
         * @param {string} ulid 
         * @param {ParcelWrite} parcelWrite The new Parcel resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidparcelsPost(ulid: string, parcelWrite: ParcelWrite, options?: any): AxiosPromise<object> {
            return localVarFp.apiDisputesUlidparcelsPost(ulid, parcelWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Media resource.
         * @summary Removes the Media resource.
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasIdDelete(ulid: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiOffersUlidmediasIdDelete(ulid, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Media resource.
         * @summary Upload a picture for a given Offer
         * @param {string} ulid 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasPost(ulid: string, file?: File, options?: any): AxiosPromise<MediaRead> {
            return localVarFp.apiOffersUlidmediasPost(ulid, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResolutionCenterApi - object-oriented interface
 * @export
 * @class ResolutionCenterApi
 * @extends {BaseAPI}
 */
export class ResolutionCenterApi extends BaseAPI {
    /**
     * Retrieves the collection of Dispute resources.
     * @summary Retrieves the collection of Dispute resources.
     * @param {number} [page] The collection page number
     * @param {ApiDisputesGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
     * @param {ApiDisputesGetCollectionOrderStatusEnum} [orderStatus] 
     * @param {ApiDisputesGetCollectionOrderUpdatedAtEnum} [orderUpdatedAt] 
     * @param {string} [transactionOfferPublicUrl] 
     * @param {Array<string>} [transactionOfferPublicUrl2] 
     * @param {string} [transactionOfferTitle] 
     * @param {number} [transactionBuyerId] 
     * @param {Array<number>} [transactionBuyerId2] 
     * @param {string} [transactionBuyerEmail] 
     * @param {number} [transactionOfferSellerId] 
     * @param {Array<number>} [transactionOfferSellerId2] 
     * @param {string} [transactionOfferSellerEmail] 
     * @param {string} [createdAtBefore] 
     * @param {string} [createdAtStrictlyBefore] 
     * @param {string} [createdAtAfter] 
     * @param {string} [createdAtStrictlyAfter] 
     * @param {ApiDisputesGetCollectionStatusEnum} [status] Filter on a limited subset of status
     * @param {ApiDisputesGetCollectionTransactionStatusEnum} [transactionStatus] Filter on a limited subset of transaction.status
     * @param {boolean} [existsRecommendedSolution] 
     * @param {boolean} [existsChosenSolution] 
     * @param {boolean} [existsCounterSolution] 
     * @param {boolean} [existsPlatformSolution] 
     * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {Array<string>} [transactionMetadata] Flattened OrderedMap for transaction.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {Array<string>} [transactionOfferMetadata] Flattened OrderedMap for transaction.offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesGetCollection(page?: number, orderCreatedAt?: ApiDisputesGetCollectionOrderCreatedAtEnum, orderStatus?: ApiDisputesGetCollectionOrderStatusEnum, orderUpdatedAt?: ApiDisputesGetCollectionOrderUpdatedAtEnum, transactionOfferPublicUrl?: string, transactionOfferPublicUrl2?: Array<string>, transactionOfferTitle?: string, transactionBuyerId?: number, transactionBuyerId2?: Array<number>, transactionBuyerEmail?: string, transactionOfferSellerId?: number, transactionOfferSellerId2?: Array<number>, transactionOfferSellerEmail?: string, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, status?: ApiDisputesGetCollectionStatusEnum, transactionStatus?: ApiDisputesGetCollectionTransactionStatusEnum, existsRecommendedSolution?: boolean, existsChosenSolution?: boolean, existsCounterSolution?: boolean, existsPlatformSolution?: boolean, metadata?: Array<string>, transactionMetadata?: Array<string>, transactionOfferMetadata?: Array<string>, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesGetCollection(page, orderCreatedAt, orderStatus, orderUpdatedAt, transactionOfferPublicUrl, transactionOfferPublicUrl2, transactionOfferTitle, transactionBuyerId, transactionBuyerId2, transactionBuyerEmail, transactionOfferSellerId, transactionOfferSellerId2, transactionOfferSellerEmail, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, status, transactionStatus, existsRecommendedSolution, existsChosenSolution, existsCounterSolution, existsPlatformSolution, metadata, transactionMetadata, transactionOfferMetadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a draft dispute to be filled by an alleged aggrieved customer. Do not use that endpoint if the transaction took place using our safe-checkout tunnel. This endpoint return a unique URL that can be accessed by both the complainant and seller (if individual).  **Note:** You can generate at your own discretion tokens for both parties, thus avoiding the secondary authentication.
     * @summary Draft a standalone Dispute
     * @param {DisputeIndependentWrite} disputeIndependentWrite The new Dispute resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesPost(disputeIndependentWrite: DisputeIndependentWrite, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesPost(disputeIndependentWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Only the buyer/complainant** can dismiss the case immediately. Otherwise, the support can but in a limited ranges of Dispute status.
     * @summary Abandon claims on Dispute
     * @param {string} ulid Dispute identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidDelete(ulid: string, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidDelete(ulid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Dispute resource.
     * @summary Retrieves a Dispute resource.
     * @param {string} ulid Dispute identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidGet(ulid: string, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidGet(ulid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the Dispute resource.
     * @summary Update the Dispute
     * @param {string} ulid Dispute identifier
     * @param {DisputeUpdate} disputeUpdate The updated Dispute resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidPatch(ulid: string, disputeUpdate: DisputeUpdate, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidPatch(ulid, disputeUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Only authenticated** complainant and seller **CAN** issue an evaluation **WHEN** the dispute reached a final state.
     * @summary Submit an Evaluation for the Dispute
     * @param {string} ulid Evaluation identifier
     * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidevaluationsPost(ulid: string, evaluationWrite: EvaluationWrite, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidevaluationsPost(ulid, evaluationWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of Evidence resources.
     * @summary Retrieve all Evidences in Dispute
     * @param {string} ulid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidevidencesGetCollection(ulid: string, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidevidencesGetCollection(ulid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Evidence resource.
     * @summary Withdraw an Evidence from a Dispute
     * @param {string} ulid 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidevidencesIdDelete(ulid: string, id: number, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidevidencesIdDelete(ulid, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Media resource.
     * @summary Upload attachment in regard of described Evidence
     * @param {string} ulid 
     * @param {number} id 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidevidencesIdmediaPost(ulid: string, id: number, file?: File, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidevidencesIdmediaPost(ulid, id, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This action does not held the actual upload, you will have to do the upload in a dedicated request.
     * @summary Submit an Evidence to the Dispute case
     * @param {string} ulid 
     * @param {EvidenceWrite} evidenceWrite The new Evidence resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidevidencesPost(ulid: string, evidenceWrite: EvidenceWrite, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidevidencesPost(ulid, evidenceWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of Parcel resources.
     * @summary Retrieves the collection of Parcel resources.
     * @param {string} ulid 
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidparcelsGetCollection(ulid: string, page?: number, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidparcelsGetCollection(ulid, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Parcel resource.
     * @summary Removes the Parcel resource.
     * @param {string} ulid 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidparcelsIdDelete(ulid: string, id: number, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidparcelsIdDelete(ulid, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Parcel resource.
     * @summary Creates a Parcel resource.
     * @param {string} ulid 
     * @param {ParcelWrite} parcelWrite The new Parcel resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidparcelsPost(ulid: string, parcelWrite: ParcelWrite, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidparcelsPost(ulid, parcelWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Media resource.
     * @summary Removes the Media resource.
     * @param {string} ulid 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiOffersUlidmediasIdDelete(ulid: string, id: number, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiOffersUlidmediasIdDelete(ulid, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Media resource.
     * @summary Upload a picture for a given Offer
     * @param {string} ulid 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiOffersUlidmediasPost(ulid: string, file?: File, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiOffersUlidmediasPost(ulid, file, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum ApiDisputesGetCollectionOrderCreatedAtEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiDisputesGetCollectionOrderStatusEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiDisputesGetCollectionOrderUpdatedAtEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiDisputesGetCollectionStatusEnum {
    Created = 'CREATED',
    Submitted = 'SUBMITTED',
    Opened = 'OPENED',
    Abandoned = 'ABANDONED',
    Objected = 'OBJECTED',
    PendingShipment = 'PENDING_SHIPMENT',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Returned = 'RETURNED',
    Dismissed = 'DISMISSED',
    Resolved = 'RESOLVED',
    Pending = 'PENDING'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiDisputesGetCollectionTransactionStatusEnum {
    Created = 'CREATED',
    Authorized = 'AUTHORIZED',
    Refused = 'REFUSED',
    Accepted = 'ACCEPTED',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Delivered = 'DELIVERED',
    Completed = 'COMPLETED',
    Disputed = 'DISPUTED'
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of ApiClient resources.
         * @summary Retrieves the collection of ApiClient resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsGetCollection: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the ApiClient resource.
         * @summary Removes the ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsIdentifierDelete: async (identifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('apiApiClientsIdentifierDelete', 'identifier', identifier)
            const localVarPath = `/api-clients/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a ApiClient resource.
         * @summary Retrieves a ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsIdentifierGet: async (identifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('apiApiClientsIdentifierGet', 'identifier', identifier)
            const localVarPath = `/api-clients/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a ApiClient resource.
         * @summary Creates a ApiClient resource.
         * @param {ApiClientWrite} apiClientWrite The new ApiClient resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsPost: async (apiClientWrite: ApiClientWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiClientWrite' is not null or undefined
            assertParamExists('apiApiClientsPost', 'apiClientWrite', apiClientWrite)
            const localVarPath = `/api-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiClientWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a user to your organization workspace
         * @summary Organization invite
         * @param {UserInvite} userInvite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInvitePost: async (userInvite: UserInvite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userInvite' is not null or undefined
            assertParamExists('apiInvitePost', 'userInvite', userInvite)
            const localVarPath = `/invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInvite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Main route for Persona (Organization customers) to authenticate themselves. Public access, captcha protected and MFA mandatory.
         * @summary Persona Authentication
         * @param {PersonaExternalAuth} personaExternalAuth The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasauthenticationPost: async (personaExternalAuth: PersonaExternalAuth, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaExternalAuth' is not null or undefined
            assertParamExists('apiPersonasauthenticationPost', 'personaExternalAuth', personaExternalAuth)
            const localVarPath = `/personas/authentication`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaExternalAuth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Persona resource.
         * @summary Retrieve your authenticated Persona
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasmeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/personas/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Persona resource.
         * @summary Persona external registration
         * @param {PersonaRegister} personaRegister The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasregisterPost: async (personaRegister: PersonaRegister, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaRegister' is not null or undefined
            assertParamExists('apiPersonasregisterPost', 'personaRegister', personaRegister)
            const localVarPath = `/personas/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaRegister, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Internal-use only, protected by a captcha. Organization first-enrollment
         * @summary Organization onboarding
         * @param {UserWrite} userWrite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRegisterPost: async (userWrite: UserWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userWrite' is not null or undefined
            assertParamExists('apiRegisterPost', 'userWrite', userWrite)
            const localVarPath = `/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of User resources.
         * @summary Retrieves the collection of User resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGetCollection: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the User resource.
         * @summary Removes the User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdDelete', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdGet', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {UserUpdate} userUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdPatch: async (id: string, userUpdate: UserUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdPatch', 'id', id)
            // verify required parameter 'userUpdate' is not null or undefined
            assertParamExists('apiUsersIdPatch', 'userUpdate', userUpdate)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Media resource.
         * @summary Unset your personal avatar
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdavatarDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdavatarDelete', 'id', id)
            const localVarPath = `/users/{id}/avatar`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Media resource.
         * @summary Upload your personal avatar
         * @param {number} id User identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdavatarPost: async (id: number, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdavatarPost', 'id', id)
            const localVarPath = `/users/{id}/avatar`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Update user email
         * @param {string} id User identifier
         * @param {UserUserEmailUpdate} userUserEmailUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdemailPatch: async (id: string, userUserEmailUpdate: UserUserEmailUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdemailPatch', 'id', id)
            // verify required parameter 'userUserEmailUpdate' is not null or undefined
            assertParamExists('apiUsersIdemailPatch', 'userUserEmailUpdate', userUserEmailUpdate)
            const localVarPath = `/users/{id}/email`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUserEmailUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Validate email ownership
         * @param {string} id User identifier
         * @param {UserEmailValidationWrite} userEmailValidationWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdemailValidationPatch: async (id: string, userEmailValidationWrite: UserEmailValidationWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdemailValidationPatch', 'id', id)
            // verify required parameter 'userEmailValidationWrite' is not null or undefined
            assertParamExists('apiUsersIdemailValidationPatch', 'userEmailValidationWrite', userEmailValidationWrite)
            const localVarPath = `/users/{id}/email-validation`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userEmailValidationWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {object} body The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdenablePatch: async (id: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdenablePatch', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('apiUsersIdenablePatch', 'body', body)
            const localVarPath = `/users/{id}/enable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {UserUserPasswordUpdate} userUserPasswordUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdpasswordPatch: async (id: string, userUserPasswordUpdate: UserUserPasswordUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdpasswordPatch', 'id', id)
            // verify required parameter 'userUserPasswordUpdate' is not null or undefined
            assertParamExists('apiUsersIdpasswordPatch', 'userUserPasswordUpdate', userUserPasswordUpdate)
            const localVarPath = `/users/{id}/password`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUserPasswordUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {object} body The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdtotpSetupPatch: async (id: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdtotpSetupPatch', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('apiUsersIdtotpSetupPatch', 'body', body)
            const localVarPath = `/users/{id}/totp-setup`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {UserTotpToggleWrite} userTotpToggleWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdtotpTogglePatch: async (id: string, userTotpToggleWrite: UserTotpToggleWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdtotpTogglePatch', 'id', id)
            // verify required parameter 'userTotpToggleWrite' is not null or undefined
            assertParamExists('apiUsersIdtotpTogglePatch', 'userTotpToggleWrite', userTotpToggleWrite)
            const localVarPath = `/users/{id}/totp-toggle`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userTotpToggleWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is protected by a captcha, do not try to use it to consume our API. IP/CIDR to be banned upon fraudulent/irregular usage. Follow the oauth 2.0 authentication challenge as described in the documentation.
         * @summary User authentication
         * @param {UserJwtWrite} [userJwtWrite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationPost: async (userJwtWrite?: UserJwtWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authentication`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userJwtWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of ApiClient resources.
         * @summary Retrieves the collection of ApiClient resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApiClientsGetCollection(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiClientRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApiClientsGetCollection(page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiApiClientsGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the ApiClient resource.
         * @summary Removes the ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApiClientsIdentifierDelete(identifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApiClientsIdentifierDelete(identifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiApiClientsIdentifierDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a ApiClient resource.
         * @summary Retrieves a ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApiClientsIdentifierGet(identifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClientRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApiClientsIdentifierGet(identifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiApiClientsIdentifierGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a ApiClient resource.
         * @summary Creates a ApiClient resource.
         * @param {ApiClientWrite} apiClientWrite The new ApiClient resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApiClientsPost(apiClientWrite: ApiClientWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClientPostCreationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApiClientsPost(apiClientWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiApiClientsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invite a user to your organization workspace
         * @summary Organization invite
         * @param {UserInvite} userInvite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInvitePost(userInvite: UserInvite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPostRegisterRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInvitePost(userInvite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiInvitePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuthenticatedRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Main route for Persona (Organization customers) to authenticate themselves. Public access, captcha protected and MFA mandatory.
         * @summary Persona Authentication
         * @param {PersonaExternalAuth} personaExternalAuth The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasauthenticationPost(personaExternalAuth: PersonaExternalAuth, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaAuthReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasauthenticationPost(personaExternalAuth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiPersonasauthenticationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a Persona resource.
         * @summary Retrieve your authenticated Persona
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasmeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasmeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiPersonasmeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Persona resource.
         * @summary Persona external registration
         * @param {PersonaRegister} personaRegister The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasregisterPost(personaRegister: PersonaRegister, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasregisterPost(personaRegister, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiPersonasregisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Internal-use only, protected by a captcha. Organization first-enrollment
         * @summary Organization onboarding
         * @param {UserWrite} userWrite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRegisterPost(userWrite: UserWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPostRegisterRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRegisterPost(userWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the collection of User resources.
         * @summary Retrieves the collection of User resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersGetCollection(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersGetCollection(page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the User resource.
         * @summary Removes the User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {UserUpdate} userUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdPatch(id: string, userUpdate: UserUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPostRegisterRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdPatch(id, userUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the Media resource.
         * @summary Unset your personal avatar
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdavatarDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdavatarDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdavatarDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Media resource.
         * @summary Upload your personal avatar
         * @param {number} id User identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdavatarPost(id: number, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdavatarPost(id, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdavatarPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Update user email
         * @param {string} id User identifier
         * @param {UserUserEmailUpdate} userUserEmailUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdemailPatch(id: string, userUserEmailUpdate: UserUserEmailUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserUserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdemailPatch(id, userUserEmailUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdemailPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Validate email ownership
         * @param {string} id User identifier
         * @param {UserEmailValidationWrite} userEmailValidationWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdemailValidationPatch(id: string, userEmailValidationWrite: UserEmailValidationWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPostRegisterRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdemailValidationPatch(id, userEmailValidationWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdemailValidationPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {object} body The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdenablePatch(id: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserUserSubscribed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdenablePatch(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdenablePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {UserUserPasswordUpdate} userUserPasswordUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdpasswordPatch(id: string, userUserPasswordUpdate: UserUserPasswordUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserUserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdpasswordPatch(id, userUserPasswordUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdpasswordPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {object} body The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdtotpSetupPatch(id: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTotpSetupRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdtotpSetupPatch(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdtotpSetupPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {UserTotpToggleWrite} userTotpToggleWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdtotpTogglePatch(id: string, userTotpToggleWrite: UserTotpToggleWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdtotpTogglePatch(id, userTotpToggleWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdtotpTogglePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint is protected by a captcha, do not try to use it to consume our API. IP/CIDR to be banned upon fraudulent/irregular usage. Follow the oauth 2.0 authentication challenge as described in the documentation.
         * @summary User authentication
         * @param {UserJwtWrite} [userJwtWrite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationPost(userJwtWrite?: UserJwtWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserJwtCreated>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationPost(userJwtWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.authenticationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Retrieves the collection of ApiClient resources.
         * @summary Retrieves the collection of ApiClient resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsGetCollection(page?: number, options?: any): AxiosPromise<Array<ApiClientRead>> {
            return localVarFp.apiApiClientsGetCollection(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the ApiClient resource.
         * @summary Removes the ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsIdentifierDelete(identifier: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiApiClientsIdentifierDelete(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a ApiClient resource.
         * @summary Retrieves a ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsIdentifierGet(identifier: string, options?: any): AxiosPromise<ApiClientRead> {
            return localVarFp.apiApiClientsIdentifierGet(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a ApiClient resource.
         * @summary Creates a ApiClient resource.
         * @param {ApiClientWrite} apiClientWrite The new ApiClient resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsPost(apiClientWrite: ApiClientWrite, options?: any): AxiosPromise<ApiClientPostCreationRead> {
            return localVarFp.apiApiClientsPost(apiClientWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a user to your organization workspace
         * @summary Organization invite
         * @param {UserInvite} userInvite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInvitePost(userInvite: UserInvite, options?: any): AxiosPromise<UserPostRegisterRead> {
            return localVarFp.apiInvitePost(userInvite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMeGet(options?: any): AxiosPromise<UserAuthenticatedRead> {
            return localVarFp.apiMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Main route for Persona (Organization customers) to authenticate themselves. Public access, captcha protected and MFA mandatory.
         * @summary Persona Authentication
         * @param {PersonaExternalAuth} personaExternalAuth The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasauthenticationPost(personaExternalAuth: PersonaExternalAuth, options?: any): AxiosPromise<PersonaAuthReturn> {
            return localVarFp.apiPersonasauthenticationPost(personaExternalAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Persona resource.
         * @summary Retrieve your authenticated Persona
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasmeGet(options?: any): AxiosPromise<PersonaRead> {
            return localVarFp.apiPersonasmeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Persona resource.
         * @summary Persona external registration
         * @param {PersonaRegister} personaRegister The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasregisterPost(personaRegister: PersonaRegister, options?: any): AxiosPromise<PersonaRead> {
            return localVarFp.apiPersonasregisterPost(personaRegister, options).then((request) => request(axios, basePath));
        },
        /**
         * Internal-use only, protected by a captcha. Organization first-enrollment
         * @summary Organization onboarding
         * @param {UserWrite} userWrite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRegisterPost(userWrite: UserWrite, options?: any): AxiosPromise<UserPostRegisterRead> {
            return localVarFp.apiRegisterPost(userWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of User resources.
         * @summary Retrieves the collection of User resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGetCollection(page?: number, options?: any): AxiosPromise<Array<UserCollectionRead>> {
            return localVarFp.apiUsersGetCollection(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the User resource.
         * @summary Removes the User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiUsersIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdGet(id: string, options?: any): AxiosPromise<User> {
            return localVarFp.apiUsersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {UserUpdate} userUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdPatch(id: string, userUpdate: UserUpdate, options?: any): AxiosPromise<UserPostRegisterRead> {
            return localVarFp.apiUsersIdPatch(id, userUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Media resource.
         * @summary Unset your personal avatar
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdavatarDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiUsersIdavatarDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Media resource.
         * @summary Upload your personal avatar
         * @param {number} id User identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdavatarPost(id: number, file?: File, options?: any): AxiosPromise<MediaRead> {
            return localVarFp.apiUsersIdavatarPost(id, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Update user email
         * @param {string} id User identifier
         * @param {UserUserEmailUpdate} userUserEmailUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdemailPatch(id: string, userUserEmailUpdate: UserUserEmailUpdate, options?: any): AxiosPromise<UserUserRead> {
            return localVarFp.apiUsersIdemailPatch(id, userUserEmailUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Validate email ownership
         * @param {string} id User identifier
         * @param {UserEmailValidationWrite} userEmailValidationWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdemailValidationPatch(id: string, userEmailValidationWrite: UserEmailValidationWrite, options?: any): AxiosPromise<UserPostRegisterRead> {
            return localVarFp.apiUsersIdemailValidationPatch(id, userEmailValidationWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {object} body The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdenablePatch(id: string, body: object, options?: any): AxiosPromise<UserUserSubscribed> {
            return localVarFp.apiUsersIdenablePatch(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {UserUserPasswordUpdate} userUserPasswordUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdpasswordPatch(id: string, userUserPasswordUpdate: UserUserPasswordUpdate, options?: any): AxiosPromise<UserUserRead> {
            return localVarFp.apiUsersIdpasswordPatch(id, userUserPasswordUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {object} body The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdtotpSetupPatch(id: string, body: object, options?: any): AxiosPromise<UserTotpSetupRead> {
            return localVarFp.apiUsersIdtotpSetupPatch(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {UserTotpToggleWrite} userTotpToggleWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdtotpTogglePatch(id: string, userTotpToggleWrite: UserTotpToggleWrite, options?: any): AxiosPromise<object> {
            return localVarFp.apiUsersIdtotpTogglePatch(id, userTotpToggleWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is protected by a captcha, do not try to use it to consume our API. IP/CIDR to be banned upon fraudulent/irregular usage. Follow the oauth 2.0 authentication challenge as described in the documentation.
         * @summary User authentication
         * @param {UserJwtWrite} [userJwtWrite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationPost(userJwtWrite?: UserJwtWrite, options?: any): AxiosPromise<UserJwtCreated> {
            return localVarFp.authenticationPost(userJwtWrite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Retrieves the collection of ApiClient resources.
     * @summary Retrieves the collection of ApiClient resources.
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiApiClientsGetCollection(page?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiApiClientsGetCollection(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the ApiClient resource.
     * @summary Removes the ApiClient resource.
     * @param {string} identifier ApiClient identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiApiClientsIdentifierDelete(identifier: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiApiClientsIdentifierDelete(identifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a ApiClient resource.
     * @summary Retrieves a ApiClient resource.
     * @param {string} identifier ApiClient identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiApiClientsIdentifierGet(identifier: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiApiClientsIdentifierGet(identifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a ApiClient resource.
     * @summary Creates a ApiClient resource.
     * @param {ApiClientWrite} apiClientWrite The new ApiClient resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiApiClientsPost(apiClientWrite: ApiClientWrite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiApiClientsPost(apiClientWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invite a user to your organization workspace
     * @summary Organization invite
     * @param {UserInvite} userInvite The new User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiInvitePost(userInvite: UserInvite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiInvitePost(userInvite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a User resource.
     * @summary Retrieves a User resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiMeGet(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Main route for Persona (Organization customers) to authenticate themselves. Public access, captcha protected and MFA mandatory.
     * @summary Persona Authentication
     * @param {PersonaExternalAuth} personaExternalAuth The new Persona resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiPersonasauthenticationPost(personaExternalAuth: PersonaExternalAuth, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiPersonasauthenticationPost(personaExternalAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Persona resource.
     * @summary Retrieve your authenticated Persona
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiPersonasmeGet(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiPersonasmeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Persona resource.
     * @summary Persona external registration
     * @param {PersonaRegister} personaRegister The new Persona resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiPersonasregisterPost(personaRegister: PersonaRegister, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiPersonasregisterPost(personaRegister, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Internal-use only, protected by a captcha. Organization first-enrollment
     * @summary Organization onboarding
     * @param {UserWrite} userWrite The new User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiRegisterPost(userWrite: UserWrite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiRegisterPost(userWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of User resources.
     * @summary Retrieves the collection of User resources.
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersGetCollection(page?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersGetCollection(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the User resource.
     * @summary Removes the User resource.
     * @param {string} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a User resource.
     * @summary Retrieves a User resource.
     * @param {string} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdGet(id: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Updates the User resource.
     * @param {string} id User identifier
     * @param {UserUpdate} userUpdate The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdPatch(id: string, userUpdate: UserUpdate, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdPatch(id, userUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Media resource.
     * @summary Unset your personal avatar
     * @param {number} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdavatarDelete(id: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdavatarDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Media resource.
     * @summary Upload your personal avatar
     * @param {number} id User identifier
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdavatarPost(id: number, file?: File, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdavatarPost(id, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Update user email
     * @param {string} id User identifier
     * @param {UserUserEmailUpdate} userUserEmailUpdate The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdemailPatch(id: string, userUserEmailUpdate: UserUserEmailUpdate, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdemailPatch(id, userUserEmailUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Validate email ownership
     * @param {string} id User identifier
     * @param {UserEmailValidationWrite} userEmailValidationWrite The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdemailValidationPatch(id: string, userEmailValidationWrite: UserEmailValidationWrite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdemailValidationPatch(id, userEmailValidationWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Updates the User resource.
     * @param {string} id User identifier
     * @param {object} body The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdenablePatch(id: string, body: object, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdenablePatch(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Updates the User resource.
     * @param {string} id User identifier
     * @param {UserUserPasswordUpdate} userUserPasswordUpdate The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdpasswordPatch(id: string, userUserPasswordUpdate: UserUserPasswordUpdate, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdpasswordPatch(id, userUserPasswordUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Updates the User resource.
     * @param {string} id User identifier
     * @param {object} body The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdtotpSetupPatch(id: string, body: object, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdtotpSetupPatch(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Updates the User resource.
     * @param {string} id User identifier
     * @param {UserTotpToggleWrite} userTotpToggleWrite The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdtotpTogglePatch(id: string, userTotpToggleWrite: UserTotpToggleWrite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdtotpTogglePatch(id, userTotpToggleWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is protected by a captcha, do not try to use it to consume our API. IP/CIDR to be banned upon fraudulent/irregular usage. Follow the oauth 2.0 authentication challenge as described in the documentation.
     * @summary User authentication
     * @param {UserJwtWrite} [userJwtWrite] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public authenticationPost(userJwtWrite?: UserJwtWrite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).authenticationPost(userJwtWrite, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of WebhookHistory resources.
         * @summary Retrieves the collection of WebhookHistory resources.
         * @param {number} [page] The collection page number
         * @param {string} [event] 
         * @param {Array<string>} [event2] 
         * @param {string} [objectId] 
         * @param {Array<string>} [objectId2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesGetCollection: async (page?: number, event?: string, event2?: Array<string>, objectId?: string, objectId2?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhook-histories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["ORGANIZATION_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }

            if (event2) {
                localVarQueryParameter['event[]'] = event2;
            }

            if (objectId !== undefined) {
                localVarQueryParameter['objectId'] = objectId;
            }

            if (objectId2) {
                localVarQueryParameter['objectId[]'] = objectId2;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a WebhookHistory resource.
         * @summary Retrieves a WebhookHistory resource.
         * @param {string} id WebhookHistory identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWebhookHistoriesIdGet', 'id', id)
            const localVarPath = `/webhook-histories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["ORGANIZATION_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces the WebhookHistory resource.
         * @summary Replay a Webhook that ended up in failure
         * @param {string} id WebhookHistory identifier
         * @param {object} body The updated WebhookHistory resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesIdPut: async (id: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWebhookHistoriesIdPut', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('apiWebhookHistoriesIdPut', 'body', body)
            const localVarPath = `/webhook-histories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of WebhookSubscription resources.
         * @summary Retrieves the collection of WebhookSubscription resources.
         * @param {number} [page] The collection page number
         * @param {ApiWebhookSubscriptionsGetCollectionEventEnum} [event] Filter on a limited subset of event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsGetCollection: async (page?: number, event?: ApiWebhookSubscriptionsGetCollectionEventEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhook-subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["ORGANIZATION_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the WebhookSubscription resource.
         * @summary Removes the WebhookSubscription resource.
         * @param {string} id WebhookSubscription identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWebhookSubscriptionsIdDelete', 'id', id)
            const localVarPath = `/webhook-subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a WebhookSubscription resource.
         * @summary Subscribe to Event(s)
         * @param {WebhookSubscriptionWrite} webhookSubscriptionWrite The new WebhookSubscription resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsPost: async (webhookSubscriptionWrite: WebhookSubscriptionWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookSubscriptionWrite' is not null or undefined
            assertParamExists('apiWebhookSubscriptionsPost', 'webhookSubscriptionWrite', webhookSubscriptionWrite)
            const localVarPath = `/webhook-subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookSubscriptionWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of WebhookHistory resources.
         * @summary Retrieves the collection of WebhookHistory resources.
         * @param {number} [page] The collection page number
         * @param {string} [event] 
         * @param {Array<string>} [event2] 
         * @param {string} [objectId] 
         * @param {Array<string>} [objectId2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookHistoriesGetCollection(page?: number, event?: string, event2?: Array<string>, objectId?: string, objectId2?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookHistoryCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookHistoriesGetCollection(page, event, event2, objectId, objectId2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.apiWebhookHistoriesGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a WebhookHistory resource.
         * @summary Retrieves a WebhookHistory resource.
         * @param {string} id WebhookHistory identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookHistoriesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookHistoryRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookHistoriesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.apiWebhookHistoriesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replaces the WebhookHistory resource.
         * @summary Replay a Webhook that ended up in failure
         * @param {string} id WebhookHistory identifier
         * @param {object} body The updated WebhookHistory resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookHistoriesIdPut(id: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookHistoryRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookHistoriesIdPut(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.apiWebhookHistoriesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the collection of WebhookSubscription resources.
         * @summary Retrieves the collection of WebhookSubscription resources.
         * @param {number} [page] The collection page number
         * @param {ApiWebhookSubscriptionsGetCollectionEventEnum} [event] Filter on a limited subset of event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookSubscriptionsGetCollection(page?: number, event?: ApiWebhookSubscriptionsGetCollectionEventEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookSubscriptionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookSubscriptionsGetCollection(page, event, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.apiWebhookSubscriptionsGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the WebhookSubscription resource.
         * @summary Removes the WebhookSubscription resource.
         * @param {string} id WebhookSubscription identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookSubscriptionsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookSubscriptionsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.apiWebhookSubscriptionsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a WebhookSubscription resource.
         * @summary Subscribe to Event(s)
         * @param {WebhookSubscriptionWrite} webhookSubscriptionWrite The new WebhookSubscription resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookSubscriptionsPost(webhookSubscriptionWrite: WebhookSubscriptionWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSubscriptionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookSubscriptionsPost(webhookSubscriptionWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.apiWebhookSubscriptionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * Retrieves the collection of WebhookHistory resources.
         * @summary Retrieves the collection of WebhookHistory resources.
         * @param {number} [page] The collection page number
         * @param {string} [event] 
         * @param {Array<string>} [event2] 
         * @param {string} [objectId] 
         * @param {Array<string>} [objectId2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesGetCollection(page?: number, event?: string, event2?: Array<string>, objectId?: string, objectId2?: Array<string>, options?: any): AxiosPromise<Array<WebhookHistoryCollectionRead>> {
            return localVarFp.apiWebhookHistoriesGetCollection(page, event, event2, objectId, objectId2, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a WebhookHistory resource.
         * @summary Retrieves a WebhookHistory resource.
         * @param {string} id WebhookHistory identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesIdGet(id: string, options?: any): AxiosPromise<WebhookHistoryRead> {
            return localVarFp.apiWebhookHistoriesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the WebhookHistory resource.
         * @summary Replay a Webhook that ended up in failure
         * @param {string} id WebhookHistory identifier
         * @param {object} body The updated WebhookHistory resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesIdPut(id: string, body: object, options?: any): AxiosPromise<WebhookHistoryRead> {
            return localVarFp.apiWebhookHistoriesIdPut(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of WebhookSubscription resources.
         * @summary Retrieves the collection of WebhookSubscription resources.
         * @param {number} [page] The collection page number
         * @param {ApiWebhookSubscriptionsGetCollectionEventEnum} [event] Filter on a limited subset of event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsGetCollection(page?: number, event?: ApiWebhookSubscriptionsGetCollectionEventEnum, options?: any): AxiosPromise<Array<WebhookSubscriptionRead>> {
            return localVarFp.apiWebhookSubscriptionsGetCollection(page, event, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the WebhookSubscription resource.
         * @summary Removes the WebhookSubscription resource.
         * @param {string} id WebhookSubscription identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiWebhookSubscriptionsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a WebhookSubscription resource.
         * @summary Subscribe to Event(s)
         * @param {WebhookSubscriptionWrite} webhookSubscriptionWrite The new WebhookSubscription resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsPost(webhookSubscriptionWrite: WebhookSubscriptionWrite, options?: any): AxiosPromise<WebhookSubscriptionRead> {
            return localVarFp.apiWebhookSubscriptionsPost(webhookSubscriptionWrite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * Retrieves the collection of WebhookHistory resources.
     * @summary Retrieves the collection of WebhookHistory resources.
     * @param {number} [page] The collection page number
     * @param {string} [event] 
     * @param {Array<string>} [event2] 
     * @param {string} [objectId] 
     * @param {Array<string>} [objectId2] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookHistoriesGetCollection(page?: number, event?: string, event2?: Array<string>, objectId?: string, objectId2?: Array<string>, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookHistoriesGetCollection(page, event, event2, objectId, objectId2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a WebhookHistory resource.
     * @summary Retrieves a WebhookHistory resource.
     * @param {string} id WebhookHistory identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookHistoriesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookHistoriesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces the WebhookHistory resource.
     * @summary Replay a Webhook that ended up in failure
     * @param {string} id WebhookHistory identifier
     * @param {object} body The updated WebhookHistory resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookHistoriesIdPut(id: string, body: object, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookHistoriesIdPut(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of WebhookSubscription resources.
     * @summary Retrieves the collection of WebhookSubscription resources.
     * @param {number} [page] The collection page number
     * @param {ApiWebhookSubscriptionsGetCollectionEventEnum} [event] Filter on a limited subset of event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookSubscriptionsGetCollection(page?: number, event?: ApiWebhookSubscriptionsGetCollectionEventEnum, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookSubscriptionsGetCollection(page, event, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the WebhookSubscription resource.
     * @summary Removes the WebhookSubscription resource.
     * @param {string} id WebhookSubscription identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookSubscriptionsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookSubscriptionsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a WebhookSubscription resource.
     * @summary Subscribe to Event(s)
     * @param {WebhookSubscriptionWrite} webhookSubscriptionWrite The new WebhookSubscription resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookSubscriptionsPost(webhookSubscriptionWrite: WebhookSubscriptionWrite, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookSubscriptionsPost(webhookSubscriptionWrite, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum ApiWebhookSubscriptionsGetCollectionEventEnum {
    DisputeOpened = 'dispute.opened',
    DisputeSubmitted = 'dispute.submitted',
    DisputeCreated = 'dispute.created',
    DisputeAbandoned = 'dispute.abandoned',
    DisputeSettlement = 'dispute.settlement',
    DisputeClosed = 'dispute.closed',
    DisputeExpired = 'dispute.expired',
    DisputeManualArbitrationRequired = 'dispute.manual_arbitration_required',
    DisputeUpdated = 'dispute.updated',
    DisputeReminder = 'dispute.reminder',
    OfferCreated = 'offer.created',
    OfferExpired = 'offer.expired',
    OfferUpdated = 'offer.updated',
    OfferCrawlFailure = 'offer.crawl_failure',
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionReconciled = 'offer.transaction.reconciled',
    OfferTransactionAbandoned = 'offer.transaction.abandoned',
    OfferClosed = 'offer.closed',
    OfferTransactionRefund = 'offer.transaction.refund',
    PersonaAdded = 'persona.added'
}


