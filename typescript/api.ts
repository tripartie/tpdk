/* tslint:disable */
/* eslint-disable */
/**
 * Tripartie
 * Our API suite for the **Resolution Center** and the **Safe Checkout** features. Simple, yet elegant web interfaces for your convenience. One request away from your first automated resolution or safe-checkout.
 *
 * The version of the OpenAPI document: 2.0.153
 * Contact: noc@tripartie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {number}
     * @memberof Address
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'gateOrPortalOrInboxCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'updatedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface AddressIndependentWrite
 */
export interface AddressIndependentWrite {
    /**
     * 
     * @type {string}
     * @memberof AddressIndependentWrite
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressIndependentWrite
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressIndependentWrite
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressIndependentWrite
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressIndependentWrite
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressIndependentWrite
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressIndependentWrite
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressIndependentWrite
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressIndependentWrite
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * 
 * @export
 * @interface AddressUpdate
 */
export interface AddressUpdate {
    /**
     * 
     * @type {string}
     * @memberof AddressUpdate
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdate
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdate
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdate
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdate
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdate
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdate
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdate
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdate
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * 
 * @export
 * @interface AddressWrite
 */
export interface AddressWrite {
    /**
     * 
     * @type {string}
     * @memberof AddressWrite
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressWrite
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressWrite
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressWrite
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressWrite
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressWrite
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressWrite
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressWrite
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressWrite
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiClientPostCreationRead
 */
export interface ApiClientPostCreationRead {
    /**
     * 
     * @type {string}
     * @memberof ApiClientPostCreationRead
     */
    'identifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiClientPostCreationRead
     */
    'secret'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiClientPostCreationRead
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ApiClientRead
 */
export interface ApiClientRead {
    /**
     * 
     * @type {string}
     * @memberof ApiClientRead
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof ApiClientRead
     */
    'createdAt': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiClientRead
     */
    'scopes'?: Array<ApiClientReadScopesEnum>;
    /**
     * 
     * @type {string}
     * @memberof ApiClientRead
     */
    'name'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiClientReadScopesEnum {
    DisputeRead = 'DISPUTE_READ',
    DisputeWrite = 'DISPUTE_WRITE',
    PersonaRead = 'PERSONA_READ',
    PersonaWrite = 'PERSONA_WRITE',
    PersonaAuth = 'PERSONA_AUTH',
    OfferRead = 'OFFER_READ',
    OfferWrite = 'OFFER_WRITE',
    OrganizationRead = 'ORGANIZATION_READ',
    InternalWrite = 'INTERNAL_WRITE'
}

/**
 * 
 * @export
 * @interface ApiClientWrite
 */
export interface ApiClientWrite {
    /**
     * 
     * @type {string}
     * @memberof ApiClientWrite
     */
    'referenceName': string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiClientWrite
     */
    'desiredScopes'?: Array<ApiClientWriteDesiredScopesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiClientWriteDesiredScopesEnum {
    OfferRead = 'OFFER_READ',
    OfferWrite = 'OFFER_WRITE',
    DisputeRead = 'DISPUTE_READ',
    DisputeWrite = 'DISPUTE_WRITE',
    OrganizationRead = 'ORGANIZATION_READ',
    PersonaRead = 'PERSONA_READ',
    PersonaWrite = 'PERSONA_WRITE',
    PersonaAuth = 'PERSONA_AUTH'
}

/**
 * Access directly our resolution center without having used the safe-checkout feature.
 * @export
 * @interface DisputeCollectionRead
 */
export interface DisputeCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'ulid': string;
    /**
     * 
     * @type {TransactionCollectionRead}
     * @memberof DisputeCollectionRead
     */
    'transaction'?: TransactionCollectionRead;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'status': DisputeCollectionReadStatusEnum;
    /**
     * The dispute may concern only PART of the package. Specify it there.
     * @type {number}
     * @memberof DisputeCollectionRead
     */
    'itemCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'issueType'?: DisputeCollectionReadIssueTypeEnum | null;
    /**
     * To be set only in conjunction of issueType = NOT_AS_DESCRIBED.
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'issueInDescriptionType'?: DisputeCollectionReadIssueInDescriptionTypeEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeCollectionRead
     */
    'issueMentionedInOffer'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'complainantStake'?: DisputeCollectionReadComplainantStakeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'inferredStake'?: DisputeCollectionReadInferredStakeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'chosenSolution'?: DisputeCollectionReadChosenSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeCollectionRead
     */
    'chosenPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'platformSolution'?: DisputeCollectionReadPlatformSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeCollectionRead
     */
    'platformPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeCollectionRead
     */
    'platformApproval'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'platformActorType'?: DisputeCollectionReadPlatformActorTypeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'updatedAt'?: string | null;
    /**
     * Yield if eligible the date-time at which the dispute state expire.
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'statusExpiration'?: string | null;
    /**
     * Determine who is awaited (actor) for the next transition
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'awaitedParty'?: DisputeCollectionReadAwaitedPartyEnum;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'iri'?: string;
    /**
     * 
     * @type {number}
     * @memberof DisputeCollectionRead
     */
    'messageCount'?: number;
    /**
     * Determine who won the case, if not specified, then it is ongoing.
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'closedInFavorOf'?: DisputeCollectionReadClosedInFavorOfEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadStatusEnum {
    Created = 'CREATED',
    Submitted = 'SUBMITTED',
    Opened = 'OPENED',
    Abandoned = 'ABANDONED',
    Objected = 'OBJECTED',
    PendingShipment = 'PENDING_SHIPMENT',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Returned = 'RETURNED',
    Dismissed = 'DISMISSED',
    Resolved = 'RESOLVED',
    Pending = 'PENDING'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadIssueTypeEnum {
    NotAsDescribed = 'NOT_AS_DESCRIBED',
    DoesNotWork = 'DOES_NOT_WORK',
    IsIncomplete = 'IS_INCOMPLETE',
    DeliveryIssue = 'DELIVERY_ISSUE',
    AllegedFraud = 'ALLEGED_FRAUD',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadIssueInDescriptionTypeEnum {
    WrongColour = 'WRONG_COLOUR',
    DamagedOrUsed = 'DAMAGED_OR_USED',
    IncorrectFormatOrSize = 'INCORRECT_FORMAT_OR_SIZE',
    DifferentMaterial = 'DIFFERENT_MATERIAL',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadComplainantStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadInferredStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadChosenSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadPlatformSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadPlatformActorTypeEnum {
    Ruling = 'RULING',
    Ai = 'AI',
    CustomerCare = 'CUSTOMER_CARE',
    PlatformSupport = 'PLATFORM_SUPPORT',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadAwaitedPartyEnum {
    Buyer = 'BUYER',
    Platform = 'PLATFORM',
    Seller = 'SELLER'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadClosedInFavorOfEnum {
    Buyer = 'BUYER',
    Seller = 'SELLER'
}

/**
 * Access directly our resolution center without having used the safe-checkout feature.
 * @export
 * @interface DisputeDisputeRead
 */
export interface DisputeDisputeRead {
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'ulid': string;
    /**
     * 
     * @type {TransactionDisputeRead}
     * @memberof DisputeDisputeRead
     */
    'transaction'?: TransactionDisputeRead;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'status': DisputeDisputeReadStatusEnum;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'redirectUrl'?: string | null;
    /**
     * The dispute may concern only PART of the package. Specify it there.
     * @type {number}
     * @memberof DisputeDisputeRead
     */
    'itemCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'issueType'?: DisputeDisputeReadIssueTypeEnum | null;
    /**
     * To be set only in conjunction of issueType = NOT_AS_DESCRIBED.
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'issueInDescriptionType'?: DisputeDisputeReadIssueInDescriptionTypeEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeDisputeRead
     */
    'issueMentionedInOffer'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'issueDetails'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeDisputeRead
     */
    'complainantTruthfulnessScore': number;
    /**
     * 
     * @type {number}
     * @memberof DisputeDisputeRead
     */
    'sellerTruthfulnessScore': number;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'complainantStake'?: DisputeDisputeReadComplainantStakeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'inferredStake'?: DisputeDisputeReadInferredStakeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'recommendedSolution'?: DisputeDisputeReadRecommendedSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeDisputeRead
     */
    'recommendedPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'chosenSolution'?: DisputeDisputeReadChosenSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeDisputeRead
     */
    'chosenPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'counterSolution'?: DisputeDisputeReadCounterSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeDisputeRead
     */
    'counterPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'sellerNotes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'sellerRejectionReason'?: DisputeDisputeReadSellerRejectionReasonEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeDisputeRead
     */
    'complainantApproval'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeDisputeRead
     */
    'sellerApproval'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'platformSolution'?: DisputeDisputeReadPlatformSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeDisputeRead
     */
    'platformPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeDisputeRead
     */
    'platformApproval'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'platformActorType'?: DisputeDisputeReadPlatformActorTypeEnum | null;
    /**
     * Explicit additional information about the platform decision. Could be written by AI, Ruling or Customer Care.
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'platformReasoning'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'arbitrationBy'?: string | null;
    /**
     * 
     * @type {Array<ParcelDisputeRead>}
     * @memberof DisputeDisputeRead
     */
    'parcels': Array<ParcelDisputeRead>;
    /**
     * 
     * @type {Array<ViewDisputeRead>}
     * @memberof DisputeDisputeRead
     */
    'views': Array<ViewDisputeRead>;
    /**
     * 
     * @type {Array<MetadataDisputeRead>}
     * @memberof DisputeDisputeRead
     */
    'metadata': Array<MetadataDisputeRead>;
    /**
     * 
     * @type {Array<WorkflowEventDisputeRead>}
     * @memberof DisputeDisputeRead
     */
    'events'?: Array<WorkflowEventDisputeRead>;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'updatedAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeDisputeRead
     */
    'viewCount'?: number;
    /**
     * Yield if eligible the date-time at which the dispute state expire.
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'statusExpiration'?: string | null;
    /**
     * Determine who is awaited (actor) for the next transition
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'awaitedParty'?: DisputeDisputeReadAwaitedPartyEnum;
    /**
     * 
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'iri'?: string;
    /**
     * 
     * @type {number}
     * @memberof DisputeDisputeRead
     */
    'messageCount'?: number;
    /**
     * Determine who won the case, if not specified, then it is ongoing.
     * @type {string}
     * @memberof DisputeDisputeRead
     */
    'closedInFavorOf'?: DisputeDisputeReadClosedInFavorOfEnum;
    /**
     * Total amount disbursed by the buyer to acquire the item.
     * @type {number}
     * @memberof DisputeDisputeRead
     */
    'disbursedByBuyer'?: number | null;
    /**
     * How much the buyer can actually receive back in case of a full refund.
     * @type {number}
     * @memberof DisputeDisputeRead
     */
    'maxRefundableForBuyer'?: number | null;
}

/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadStatusEnum {
    Created = 'CREATED',
    Submitted = 'SUBMITTED',
    Opened = 'OPENED',
    Abandoned = 'ABANDONED',
    Objected = 'OBJECTED',
    PendingShipment = 'PENDING_SHIPMENT',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Returned = 'RETURNED',
    Dismissed = 'DISMISSED',
    Resolved = 'RESOLVED',
    Pending = 'PENDING'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadIssueTypeEnum {
    NotAsDescribed = 'NOT_AS_DESCRIBED',
    DoesNotWork = 'DOES_NOT_WORK',
    IsIncomplete = 'IS_INCOMPLETE',
    DeliveryIssue = 'DELIVERY_ISSUE',
    AllegedFraud = 'ALLEGED_FRAUD',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadIssueInDescriptionTypeEnum {
    WrongColour = 'WRONG_COLOUR',
    DamagedOrUsed = 'DAMAGED_OR_USED',
    IncorrectFormatOrSize = 'INCORRECT_FORMAT_OR_SIZE',
    DifferentMaterial = 'DIFFERENT_MATERIAL',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadComplainantStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadInferredStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadRecommendedSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadChosenSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadCounterSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadSellerRejectionReasonEnum {
    UnjustifiedRequest = 'UNJUSTIFIED_REQUEST',
    AbusiveRequest = 'ABUSIVE_REQUEST',
    FraudAttempt = 'FRAUD_ATTEMPT',
    Other = 'OTHER',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadPlatformSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadPlatformActorTypeEnum {
    Ruling = 'RULING',
    Ai = 'AI',
    CustomerCare = 'CUSTOMER_CARE',
    PlatformSupport = 'PLATFORM_SUPPORT',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadAwaitedPartyEnum {
    Buyer = 'BUYER',
    Platform = 'PLATFORM',
    Seller = 'SELLER'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeDisputeReadClosedInFavorOfEnum {
    Buyer = 'BUYER',
    Seller = 'SELLER'
}

/**
 * Access directly our resolution center without having used the safe-checkout feature.
 * @export
 * @interface DisputeIndependentWrite
 */
export interface DisputeIndependentWrite {
    /**
     * 
     * @type {TransactionIndependentWrite}
     * @memberof DisputeIndependentWrite
     */
    'transaction': TransactionIndependentWrite;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof DisputeIndependentWrite
     */
    'redirectUrl'?: string | null;
    /**
     * 
     * @type {Array<MetadataIndependentWrite>}
     * @memberof DisputeIndependentWrite
     */
    'metadata'?: Array<MetadataIndependentWrite>;
}
/**
 * Access directly our resolution center without having used the safe-checkout feature.
 * @export
 * @interface DisputePostCreationRead
 */
export interface DisputePostCreationRead {
    /**
     * 
     * @type {string}
     * @memberof DisputePostCreationRead
     */
    'ulid'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputePostCreationRead
     */
    'url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DisputePostCreationRead
     */
    'buyerId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DisputePostCreationRead
     */
    'sellerId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputePostCreationRead
     */
    'offerUlid'?: string | null;
}
/**
 * Access directly our resolution center without having used the safe-checkout feature.
 * @export
 * @interface DisputeRead
 */
export interface DisputeRead {
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'ulid': string;
    /**
     * 
     * @type {TransactionRead}
     * @memberof DisputeRead
     */
    'transaction'?: TransactionRead;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'status': DisputeReadStatusEnum;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof DisputeRead
     */
    'redirectUrl'?: string | null;
    /**
     * The dispute may concern only PART of the package. Specify it there.
     * @type {number}
     * @memberof DisputeRead
     */
    'itemCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'issueType'?: DisputeReadIssueTypeEnum | null;
    /**
     * To be set only in conjunction of issueType = NOT_AS_DESCRIBED.
     * @type {string}
     * @memberof DisputeRead
     */
    'issueInDescriptionType'?: DisputeReadIssueInDescriptionTypeEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeRead
     */
    'issueMentionedInOffer'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'issueDetails'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeRead
     */
    'complainantTruthfulnessScore': number;
    /**
     * 
     * @type {number}
     * @memberof DisputeRead
     */
    'sellerTruthfulnessScore': number;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'complainantStake'?: DisputeReadComplainantStakeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'inferredStake'?: DisputeReadInferredStakeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'recommendedSolution'?: DisputeReadRecommendedSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeRead
     */
    'recommendedPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'chosenSolution'?: DisputeReadChosenSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeRead
     */
    'chosenPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'counterSolution'?: DisputeReadCounterSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeRead
     */
    'counterPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'sellerNotes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'sellerRejectionReason'?: DisputeReadSellerRejectionReasonEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeRead
     */
    'complainantApproval'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeRead
     */
    'sellerApproval'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'platformSolution'?: DisputeReadPlatformSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeRead
     */
    'platformPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeRead
     */
    'platformApproval'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'platformActorType'?: DisputeReadPlatformActorTypeEnum | null;
    /**
     * Explicit additional information about the platform decision. Could be written by AI, Ruling or Customer Care.
     * @type {string}
     * @memberof DisputeRead
     */
    'platformReasoning'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'arbitrationBy'?: string | null;
    /**
     * 
     * @type {Array<ParcelRead>}
     * @memberof DisputeRead
     */
    'parcels': Array<ParcelRead>;
    /**
     * 
     * @type {Array<ViewRead>}
     * @memberof DisputeRead
     */
    'views': Array<ViewRead>;
    /**
     * 
     * @type {Array<MetadataRead>}
     * @memberof DisputeRead
     */
    'metadata': Array<MetadataRead>;
    /**
     * 
     * @type {Array<WorkflowEventRead>}
     * @memberof DisputeRead
     */
    'events'?: Array<WorkflowEventRead>;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'updatedAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeRead
     */
    'viewCount'?: number;
    /**
     * Yield if eligible the date-time at which the dispute state expire.
     * @type {string}
     * @memberof DisputeRead
     */
    'statusExpiration'?: string | null;
    /**
     * Determine who is awaited (actor) for the next transition
     * @type {string}
     * @memberof DisputeRead
     */
    'awaitedParty'?: DisputeReadAwaitedPartyEnum;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'iri'?: string;
    /**
     * 
     * @type {number}
     * @memberof DisputeRead
     */
    'messageCount'?: number;
    /**
     * Determine who won the case, if not specified, then it is ongoing.
     * @type {string}
     * @memberof DisputeRead
     */
    'closedInFavorOf'?: DisputeReadClosedInFavorOfEnum;
    /**
     * Total amount disbursed by the buyer to acquire the item.
     * @type {number}
     * @memberof DisputeRead
     */
    'disbursedByBuyer'?: number | null;
    /**
     * How much the buyer can actually receive back in case of a full refund.
     * @type {number}
     * @memberof DisputeRead
     */
    'maxRefundableForBuyer'?: number | null;
}

/**
    * @export
    * @enum {string}
    */
export enum DisputeReadStatusEnum {
    Created = 'CREATED',
    Submitted = 'SUBMITTED',
    Opened = 'OPENED',
    Abandoned = 'ABANDONED',
    Objected = 'OBJECTED',
    PendingShipment = 'PENDING_SHIPMENT',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Returned = 'RETURNED',
    Dismissed = 'DISMISSED',
    Resolved = 'RESOLVED',
    Pending = 'PENDING'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadIssueTypeEnum {
    NotAsDescribed = 'NOT_AS_DESCRIBED',
    DoesNotWork = 'DOES_NOT_WORK',
    IsIncomplete = 'IS_INCOMPLETE',
    DeliveryIssue = 'DELIVERY_ISSUE',
    AllegedFraud = 'ALLEGED_FRAUD',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadIssueInDescriptionTypeEnum {
    WrongColour = 'WRONG_COLOUR',
    DamagedOrUsed = 'DAMAGED_OR_USED',
    IncorrectFormatOrSize = 'INCORRECT_FORMAT_OR_SIZE',
    DifferentMaterial = 'DIFFERENT_MATERIAL',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadComplainantStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadInferredStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadRecommendedSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadChosenSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadCounterSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadSellerRejectionReasonEnum {
    UnjustifiedRequest = 'UNJUSTIFIED_REQUEST',
    AbusiveRequest = 'ABUSIVE_REQUEST',
    FraudAttempt = 'FRAUD_ATTEMPT',
    Other = 'OTHER',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadPlatformSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadPlatformActorTypeEnum {
    Ruling = 'RULING',
    Ai = 'AI',
    CustomerCare = 'CUSTOMER_CARE',
    PlatformSupport = 'PLATFORM_SUPPORT',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadAwaitedPartyEnum {
    Buyer = 'BUYER',
    Platform = 'PLATFORM',
    Seller = 'SELLER'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadClosedInFavorOfEnum {
    Buyer = 'BUYER',
    Seller = 'SELLER'
}

/**
 * Access directly our resolution center without having used the safe-checkout feature.
 * @export
 * @interface DisputeUpdate
 */
export interface DisputeUpdate {
    /**
     * The dispute may concern only PART of the package. Specify it there.
     * @type {number}
     * @memberof DisputeUpdate
     */
    'itemCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeUpdate
     */
    'issueType'?: DisputeUpdateIssueTypeEnum | null;
    /**
     * To be set only in conjunction of issueType = NOT_AS_DESCRIBED.
     * @type {string}
     * @memberof DisputeUpdate
     */
    'issueInDescriptionType'?: DisputeUpdateIssueInDescriptionTypeEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeUpdate
     */
    'issueMentionedInOffer'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeUpdate
     */
    'issueDetails'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeUpdate
     */
    'complainantStake'?: DisputeUpdateComplainantStakeEnum | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeUpdate
     */
    'chosenSolution'?: DisputeUpdateChosenSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeUpdate
     */
    'chosenPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeUpdate
     */
    'counterSolution'?: DisputeUpdateCounterSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeUpdate
     */
    'counterPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeUpdate
     */
    'sellerNotes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeUpdate
     */
    'sellerRejectionReason'?: DisputeUpdateSellerRejectionReasonEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeUpdate
     */
    'complainantApproval'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeUpdate
     */
    'sellerApproval'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeUpdate
     */
    'platformSolution'?: DisputeUpdatePlatformSolutionEnum | null;
    /**
     * 
     * @type {number}
     * @memberof DisputeUpdate
     */
    'platformPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeUpdate
     */
    'platformApproval'?: boolean | null;
    /**
     * Explicit additional information about the platform decision. Could be written by AI, Ruling or Customer Care.
     * @type {string}
     * @memberof DisputeUpdate
     */
    'platformReasoning'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum DisputeUpdateIssueTypeEnum {
    NotAsDescribed = 'NOT_AS_DESCRIBED',
    DoesNotWork = 'DOES_NOT_WORK',
    IsIncomplete = 'IS_INCOMPLETE',
    DeliveryIssue = 'DELIVERY_ISSUE',
    AllegedFraud = 'ALLEGED_FRAUD',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeUpdateIssueInDescriptionTypeEnum {
    WrongColour = 'WRONG_COLOUR',
    DamagedOrUsed = 'DAMAGED_OR_USED',
    IncorrectFormatOrSize = 'INCORRECT_FORMAT_OR_SIZE',
    DifferentMaterial = 'DIFFERENT_MATERIAL',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeUpdateComplainantStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeUpdateChosenSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeUpdateCounterSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeUpdateSellerRejectionReasonEnum {
    UnjustifiedRequest = 'UNJUSTIFIED_REQUEST',
    AbusiveRequest = 'ABUSIVE_REQUEST',
    FraudAttempt = 'FRAUD_ATTEMPT',
    Other = 'OTHER',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeUpdatePlatformSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface DisputeWrite
 */
export interface DisputeWrite {
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof DisputeWrite
     */
    'redirectUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface EvaluationRead
 */
export interface EvaluationRead {
    /**
     * 
     * @type {number}
     * @memberof EvaluationRead
     */
    'rating': number;
    /**
     * 
     * @type {string}
     * @memberof EvaluationRead
     */
    'comment'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EvaluationRead
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface EvaluationWrite
 */
export interface EvaluationWrite {
    /**
     * 
     * @type {number}
     * @memberof EvaluationWrite
     */
    'rating': number;
    /**
     * 
     * @type {string}
     * @memberof EvaluationWrite
     */
    'comment'?: string | null;
}
/**
 * 
 * @export
 * @interface Evidence
 */
export interface Evidence {
    /**
     * 
     * @type {number}
     * @memberof Evidence
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Evidence
     */
    'dispute'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Evidence
     */
    'owner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Evidence
     */
    'status': EvidenceStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Evidence
     */
    'media'?: string | null;
    /**
     * Description of what the evidence actually is.
     * @type {string}
     * @memberof Evidence
     */
    'additionalInformation'?: string;
    /**
     * 
     * @type {string}
     * @memberof Evidence
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Evidence
     */
    'updatedAt'?: string | null;
    /**
     * Shortcut to whomever sent the evidence
     * @type {string}
     * @memberof Evidence
     */
    'publisher'?: EvidencePublisherEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum EvidenceStatusEnum {
    Submitted = 'SUBMITTED',
    Correlated = 'CORRELATED',
    Unrelated = 'UNRELATED',
    Pending = 'PENDING',
    Tempered = 'TEMPERED',
    Rejected = 'REJECTED'
}
/**
    * @export
    * @enum {string}
    */
export enum EvidencePublisherEnum {
    Buyer = 'BUYER',
    Platform = 'PLATFORM',
    Seller = 'SELLER'
}

/**
 * 
 * @export
 * @interface EvidenceRead
 */
export interface EvidenceRead {
    /**
     * 
     * @type {number}
     * @memberof EvidenceRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EvidenceRead
     */
    'status': EvidenceReadStatusEnum;
    /**
     * 
     * @type {MediaRead}
     * @memberof EvidenceRead
     */
    'media'?: MediaRead | null;
    /**
     * Description of what the evidence actually is.
     * @type {string}
     * @memberof EvidenceRead
     */
    'additionalInformation'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceRead
     */
    'updatedAt'?: string | null;
    /**
     * Shortcut to whomever sent the evidence
     * @type {string}
     * @memberof EvidenceRead
     */
    'publisher'?: EvidenceReadPublisherEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum EvidenceReadStatusEnum {
    Submitted = 'SUBMITTED',
    Correlated = 'CORRELATED',
    Unrelated = 'UNRELATED',
    Pending = 'PENDING',
    Tempered = 'TEMPERED',
    Rejected = 'REJECTED'
}
/**
    * @export
    * @enum {string}
    */
export enum EvidenceReadPublisherEnum {
    Buyer = 'BUYER',
    Platform = 'PLATFORM',
    Seller = 'SELLER'
}

/**
 * 
 * @export
 * @interface EvidenceWrite
 */
export interface EvidenceWrite {
    /**
     * Description of what the evidence actually is.
     * @type {string}
     * @memberof EvidenceWrite
     */
    'additionalInformation': string;
}
/**
 * 
 * @export
 * @interface Media
 */
export interface Media {
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'extension': string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'filename': string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'fingerprint': string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'publicUrl': string;
    /**
     * 
     * @type {File}
     * @memberof Media
     */
    'file'?: File | null;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'b64EncodedTmpFile'?: string | null;
    /**
     * Associated 374x374 pixels small thumbnail
     * @type {string}
     * @memberof Media
     */
    'thumbnail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'original'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'owner'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Media
     */
    'offers'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'thumbnailUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface MediaAuthenticatedRead
 */
export interface MediaAuthenticatedRead {
    /**
     * 
     * @type {string}
     * @memberof MediaAuthenticatedRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface MediaCollectionRead
 */
export interface MediaCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof MediaCollectionRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface MediaDisputeRead
 */
export interface MediaDisputeRead {
    /**
     * 
     * @type {string}
     * @memberof MediaDisputeRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface MediaRead
 */
export interface MediaRead {
    /**
     * 
     * @type {string}
     * @memberof MediaRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * 
     * @type {number}
     * @memberof Metadata
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'persona'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'dispute'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'offer'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'transaction'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface MetadataDisputeRead
 */
export interface MetadataDisputeRead {
    /**
     * 
     * @type {string}
     * @memberof MetadataDisputeRead
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetadataDisputeRead
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface MetadataIndependentWrite
 */
export interface MetadataIndependentWrite {
    /**
     * 
     * @type {string}
     * @memberof MetadataIndependentWrite
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetadataIndependentWrite
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface MetadataRead
 */
export interface MetadataRead {
    /**
     * 
     * @type {string}
     * @memberof MetadataRead
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetadataRead
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface MetadataUpdate
 */
export interface MetadataUpdate {
    /**
     * 
     * @type {string}
     * @memberof MetadataUpdate
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetadataUpdate
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface MetadataWrite
 */
export interface MetadataWrite {
    /**
     * 
     * @type {string}
     * @memberof MetadataWrite
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetadataWrite
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface NotificationRead
 */
export interface NotificationRead {
    /**
     * 
     * @type {string}
     * @memberof NotificationRead
     */
    'type'?: NotificationReadTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationRead
     */
    'seen': boolean;
    /**
     * 
     * @type {string}
     * @memberof NotificationRead
     */
    'createdAt'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum NotificationReadTypeEnum {
    DisputeStateUpdate = 'DISPUTE_STATE_UPDATE',
    DisputeReminder = 'DISPUTE_REMINDER',
    MessageSent = 'MESSAGE_SENT',
    DisputeSettlement = 'DISPUTE_SETTLEMENT',
    DisputeArbitrationRequired = 'DISPUTE_ARBITRATION_REQUIRED',
    DisputeResolved = 'DISPUTE_RESOLVED'
}

/**
 * 
 * @export
 * @interface NotificationUpdate
 */
export interface NotificationUpdate {
    /**
     * 
     * @type {boolean}
     * @memberof NotificationUpdate
     */
    'seen': boolean;
}
/**
 * 
 * @export
 * @interface Offer
 */
export interface Offer {
    /**
     * 
     * @type {number}
     * @memberof Offer
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'ulid': string;
    /**
     * If specified, there would be not need for you to fill-in details. Must be accessible over WAN.
     * @type {string}
     * @memberof Offer
     */
    'publicUrl'?: string | null;
    /**
     * Mean that the generated url cannot be accessed without a generated token for a Persona. Disallow external registration.
     * @type {boolean}
     * @memberof Offer
     */
    'enforcePersonaAuth': boolean;
    /**
     * Override YOUR platform fees for that particular Offer.
     * @type {number}
     * @memberof Offer
     */
    'overrideRateCommissionSafeCheckout'?: number | null;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof Offer
     */
    'redirectUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'url': string | null;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'organization'?: string | null;
    /**
     * If the seller is actually YOUR organization, set it to NULL.
     * @type {string}
     * @memberof Offer
     */
    'seller': string;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {string}
     * @memberof Offer
     */
    'nature': OfferNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Offer
     */
    'unitPrice'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'currencyCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Offer
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'condition'?: OfferConditionEnum;
    /**
     * 
     * @type {number}
     * @memberof Offer
     */
    'weightInGram'?: number | null;
    /**
     * That toggle allows the seller to propose shipping for its item. If set in conjunction of shippingCarrier, the label will be automatically generated. Also, it will restrict the carrier to the limited subset defined.
     * @type {boolean}
     * @memberof Offer
     */
    'shippingAllowed': boolean;
    /**
     * Enable both parties to finalize the transaction in person rather than using delivery. A QR Code must be scanned by the seller once the buyer claims the product.
     * @type {boolean}
     * @memberof Offer
     */
    'handDeliveryAllowed': boolean;
    /**
     * If you wish to enable automated shipping label generation through a specific provider, specify it there.
     * @type {Array<string>}
     * @memberof Offer
     */
    'shippingCarriers'?: Array<OfferShippingCarriersEnum>;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'eanCode'?: string | null;
    /**
     * Set this flag to false to forbid a potential buyer to acquire this item separately.          This is only useful in a BulkOffer context.
     * @type {boolean}
     * @memberof Offer
     */
    'canBeSoldSeparately': boolean;
    /**
     * 
     * @type {Array<Metadata>}
     * @memberof Offer
     */
    'metadata'?: Array<Metadata>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Offer
     */
    'medias': Array<string>;
    /**
     * 
     * @type {Array<View>}
     * @memberof Offer
     */
    'views': Array<View>;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'updatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'iri'?: string;
    /**
     * 
     * @type {number}
     * @memberof Offer
     */
    'halfPricePoint'?: number | null;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferShippingCarriersEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay'
}

/**
 * 
 * @export
 * @interface OfferCollectionRead
 */
export interface OfferCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'ulid': string;
    /**
     * If specified, there would be not need for you to fill-in details. Must be accessible over WAN.
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'publicUrl'?: string | null;
    /**
     * If the seller is actually YOUR organization, set it to NULL.
     * @type {PersonaCollectionRead}
     * @memberof OfferCollectionRead
     */
    'seller': PersonaCollectionRead;
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof OfferCollectionRead
     */
    'unitPrice'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'currencyCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferCollectionRead
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'condition'?: OfferCollectionReadConditionEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferCollectionReadConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}

/**
 * 
 * @export
 * @interface OfferDisputeRead
 */
export interface OfferDisputeRead {
    /**
     * 
     * @type {string}
     * @memberof OfferDisputeRead
     */
    'ulid': string;
    /**
     * If specified, there would be not need for you to fill-in details. Must be accessible over WAN.
     * @type {string}
     * @memberof OfferDisputeRead
     */
    'publicUrl'?: string | null;
    /**
     * 
     * @type {OrganizationDisputeRead}
     * @memberof OfferDisputeRead
     */
    'organization'?: OrganizationDisputeRead | null;
    /**
     * If the seller is actually YOUR organization, set it to NULL.
     * @type {PersonaDisputeRead}
     * @memberof OfferDisputeRead
     */
    'seller': PersonaDisputeRead;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {string}
     * @memberof OfferDisputeRead
     */
    'nature': OfferDisputeReadNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof OfferDisputeRead
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferDisputeRead
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferDisputeRead
     */
    'unitPrice'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OfferDisputeRead
     */
    'currencyCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferDisputeRead
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof OfferDisputeRead
     */
    'condition'?: OfferDisputeReadConditionEnum;
    /**
     * 
     * @type {Array<MediaDisputeRead>}
     * @memberof OfferDisputeRead
     */
    'medias': Array<MediaDisputeRead>;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferDisputeReadNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferDisputeReadConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}

/**
 * An Offer object represent a public listening
 * @export
 * @interface OfferIndependentWrite
 */
export interface OfferIndependentWrite {
    /**
     * If specified, there would be not need for you to fill-in details. Must be accessible over WAN.
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'publicUrl'?: string | null;
    /**
     * If the seller is actually YOUR organization, set it to NULL.
     * @type {PersonaIndependentWrite}
     * @memberof OfferIndependentWrite
     */
    'seller': PersonaIndependentWrite;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'nature'?: OfferIndependentWriteNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'description': string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferIndependentWrite
     */
    'unitPrice'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'currencyCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferIndependentWrite
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'condition'?: OfferIndependentWriteConditionEnum;
    /**
     * 
     * @type {number}
     * @memberof OfferIndependentWrite
     */
    'weightInGram'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'eanCode'?: string | null;
    /**
     * 
     * @type {Array<MetadataIndependentWrite>}
     * @memberof OfferIndependentWrite
     */
    'metadata'?: Array<MetadataIndependentWrite>;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferIndependentWriteNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferIndependentWriteConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}

/**
 * An Offer object represent a public listening
 * @export
 * @interface OfferPostCreationRead
 */
export interface OfferPostCreationRead {
    /**
     * 
     * @type {string}
     * @memberof OfferPostCreationRead
     */
    'url'?: string | null;
}
/**
 * 
 * @export
 * @interface OfferRead
 */
export interface OfferRead {
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'ulid': string;
    /**
     * If specified, there would be not need for you to fill-in details. Must be accessible over WAN.
     * @type {string}
     * @memberof OfferRead
     */
    'publicUrl'?: string | null;
    /**
     * 
     * @type {OrganizationRead}
     * @memberof OfferRead
     */
    'organization'?: OrganizationRead | null;
    /**
     * If the seller is actually YOUR organization, set it to NULL.
     * @type {PersonaRead}
     * @memberof OfferRead
     */
    'seller': PersonaRead;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {string}
     * @memberof OfferRead
     */
    'nature': OfferReadNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferRead
     */
    'unitPrice'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'currencyCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferRead
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'condition'?: OfferReadConditionEnum;
    /**
     * 
     * @type {Array<MediaRead>}
     * @memberof OfferRead
     */
    'medias': Array<MediaRead>;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferReadNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferReadConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}

/**
 * 
 * @export
 * @interface OfferUpdate
 */
export interface OfferUpdate {
    /**
     * If specified, there would be not need for you to fill-in details. Must be accessible over WAN.
     * @type {string}
     * @memberof OfferUpdate
     */
    'publicUrl'?: string | null;
    /**
     * Mean that the generated url cannot be accessed without a generated token for a Persona. Disallow external registration.
     * @type {boolean}
     * @memberof OfferUpdate
     */
    'enforcePersonaAuth'?: boolean;
    /**
     * Override YOUR platform fees for that particular Offer.
     * @type {number}
     * @memberof OfferUpdate
     */
    'overrideRateCommissionSafeCheckout'?: number | null;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof OfferUpdate
     */
    'redirectUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferUpdate
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferUpdate
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferUpdate
     */
    'unitPrice'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OfferUpdate
     */
    'currencyCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferUpdate
     */
    'itemCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof OfferUpdate
     */
    'weightInGram'?: number | null;
    /**
     * That toggle allows the seller to propose shipping for its item. If set in conjunction of shippingCarrier, the label will be automatically generated. Also, it will restrict the carrier to the limited subset defined.
     * @type {boolean}
     * @memberof OfferUpdate
     */
    'shippingAllowed'?: boolean;
    /**
     * Enable both parties to finalize the transaction in person rather than using delivery. A QR Code must be scanned by the seller once the buyer claims the product.
     * @type {boolean}
     * @memberof OfferUpdate
     */
    'handDeliveryAllowed'?: boolean;
    /**
     * If you wish to enable automated shipping label generation through a specific provider, specify it there.
     * @type {Array<string>}
     * @memberof OfferUpdate
     */
    'shippingCarriers'?: Array<OfferUpdateShippingCarriersEnum>;
    /**
     * 
     * @type {string}
     * @memberof OfferUpdate
     */
    'eanCode'?: string | null;
    /**
     * Set this flag to false to forbid a potential buyer to acquire this item separately.          This is only useful in a BulkOffer context.
     * @type {boolean}
     * @memberof OfferUpdate
     */
    'canBeSoldSeparately'?: boolean;
    /**
     * 
     * @type {Array<MetadataUpdate>}
     * @memberof OfferUpdate
     */
    'metadata'?: Array<MetadataUpdate>;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferUpdateShippingCarriersEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay'
}

/**
 * 
 * @export
 * @interface OfferWrite
 */
export interface OfferWrite {
    /**
     * If specified, there would be not need for you to fill-in details. Must be accessible over WAN.
     * @type {string}
     * @memberof OfferWrite
     */
    'publicUrl'?: string | null;
    /**
     * Mean that the generated url cannot be accessed without a generated token for a Persona. Disallow external registration.
     * @type {boolean}
     * @memberof OfferWrite
     */
    'enforcePersonaAuth'?: boolean;
    /**
     * Override YOUR platform fees for that particular Offer.
     * @type {number}
     * @memberof OfferWrite
     */
    'overrideRateCommissionSafeCheckout'?: number | null;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof OfferWrite
     */
    'redirectUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferWrite
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof OfferWrite
     */
    'description': string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferWrite
     */
    'unitPrice'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OfferWrite
     */
    'currencyCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferWrite
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof OfferWrite
     */
    'condition'?: OfferWriteConditionEnum;
    /**
     * 
     * @type {number}
     * @memberof OfferWrite
     */
    'weightInGram'?: number | null;
    /**
     * That toggle allows the seller to propose shipping for its item. If set in conjunction of shippingCarrier, the label will be automatically generated. Also, it will restrict the carrier to the limited subset defined.
     * @type {boolean}
     * @memberof OfferWrite
     */
    'shippingAllowed'?: boolean;
    /**
     * Enable both parties to finalize the transaction in person rather than using delivery. A QR Code must be scanned by the seller once the buyer claims the product.
     * @type {boolean}
     * @memberof OfferWrite
     */
    'handDeliveryAllowed'?: boolean;
    /**
     * If you wish to enable automated shipping label generation through a specific provider, specify it there.
     * @type {Array<string>}
     * @memberof OfferWrite
     */
    'shippingCarriers'?: Array<OfferWriteShippingCarriersEnum>;
    /**
     * 
     * @type {string}
     * @memberof OfferWrite
     */
    'eanCode'?: string | null;
    /**
     * Set this flag to false to forbid a potential buyer to acquire this item separately.          This is only useful in a BulkOffer context.
     * @type {boolean}
     * @memberof OfferWrite
     */
    'canBeSoldSeparately'?: boolean;
    /**
     * 
     * @type {Array<MetadataWrite>}
     * @memberof OfferWrite
     */
    'metadata'?: Array<MetadataWrite>;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferWriteConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferWriteShippingCarriersEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay'
}

/**
 * 
 * @export
 * @interface OrganizationAuthenticatedRead
 */
export interface OrganizationAuthenticatedRead {
    /**
     * 
     * @type {number}
     * @memberof OrganizationAuthenticatedRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAuthenticatedRead
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationAuthenticatedRead
     */
    'domainVerified': boolean;
    /**
     * 
     * @type {MediaAuthenticatedRead}
     * @memberof OrganizationAuthenticatedRead
     */
    'icon'?: MediaAuthenticatedRead | null;
    /**
     * 
     * @type {MediaAuthenticatedRead}
     * @memberof OrganizationAuthenticatedRead
     */
    'logo'?: MediaAuthenticatedRead | null;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationAuthenticatedRead
     */
    'safeCheckoutToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationAuthenticatedRead
     */
    'resolutionCenterToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationAuthenticatedRead
     */
    'internalMessagingToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationAuthenticatedRead
     */
    'personaAuthPortalToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationAuthenticatedRead
     */
    'automatedReturnToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationAuthenticatedRead
     */
    'flatRateEnabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof OrganizationAuthenticatedRead
     */
    'rateCommissionSafeCheckout': number;
}
/**
 * 
 * @export
 * @interface OrganizationCollectionRead
 */
export interface OrganizationCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof OrganizationCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCollectionRead
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCollectionRead
     */
    'vatNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCollectionRead
     */
    'commercialRegistryNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCollectionRead
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {MediaCollectionRead}
     * @memberof OrganizationCollectionRead
     */
    'icon'?: MediaCollectionRead | null;
    /**
     * 
     * @type {MediaCollectionRead}
     * @memberof OrganizationCollectionRead
     */
    'logo'?: MediaCollectionRead | null;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationCollectionRead
     */
    'directNotificationToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationCollectionRead
     */
    'safeCheckoutToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationCollectionRead
     */
    'resolutionCenterToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationCollectionRead
     */
    'internalMessagingToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationCollectionRead
     */
    'personaAuthPortalToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationCollectionRead
     */
    'automatedReturnToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationCollectionRead
     */
    'flatRateEnabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof OrganizationCollectionRead
     */
    'rateCommissionSafeCheckout': number;
}
/**
 * 
 * @export
 * @interface OrganizationDisputeRead
 */
export interface OrganizationDisputeRead {
    /**
     * 
     * @type {string}
     * @memberof OrganizationDisputeRead
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDisputeRead
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDisputeRead
     */
    'customBaseUrl'?: string | null;
    /**
     * 
     * @type {MediaDisputeRead}
     * @memberof OrganizationDisputeRead
     */
    'icon'?: MediaDisputeRead | null;
    /**
     * 
     * @type {MediaDisputeRead}
     * @memberof OrganizationDisputeRead
     */
    'logo'?: MediaDisputeRead | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDisputeRead
     */
    'primaryColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDisputeRead
     */
    'secondaryColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDisputeRead
     */
    'accentColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDisputeRead
     */
    'errorColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDisputeRead
     */
    'infoColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDisputeRead
     */
    'successColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDisputeRead
     */
    'warningColor'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationDisputeRead
     */
    'directNotificationToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationDisputeRead
     */
    'personaAuthPortalToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationDisputeRead
     */
    'flatRateEnabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof OrganizationDisputeRead
     */
    'rateCommissionSafeCheckout': number;
}
/**
 * 
 * @export
 * @interface OrganizationRead
 */
export interface OrganizationRead {
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'customBaseUrl'?: string | null;
    /**
     * 
     * @type {MediaRead}
     * @memberof OrganizationRead
     */
    'icon'?: MediaRead | null;
    /**
     * 
     * @type {MediaRead}
     * @memberof OrganizationRead
     */
    'logo'?: MediaRead | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'primaryColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'secondaryColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'accentColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'errorColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'infoColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'successColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'warningColor'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationRead
     */
    'directNotificationToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationRead
     */
    'personaAuthPortalToggle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationRead
     */
    'flatRateEnabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof OrganizationRead
     */
    'rateCommissionSafeCheckout': number;
}
/**
 * 
 * @export
 * @interface OrganizationUpdate
 */
export interface OrganizationUpdate {
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'vatNumber': string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'commercialRegistryNumber': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'customBaseUrl'?: string | null;
    /**
     * 
     * @type {AddressUpdate}
     * @memberof OrganizationUpdate
     */
    'billingAddress'?: AddressUpdate | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'primaryColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'secondaryColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'accentColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'errorColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'infoColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'successColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'warningColor'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationUpdate
     */
    'directNotificationToggle'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'anonymityLevel'?: OrganizationUpdateAnonymityLevelEnum;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationUpdate
     */
    'flatRateEnabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof OrganizationUpdate
     */
    'rateCommissionSafeCheckout'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum OrganizationUpdateAnonymityLevelEnum {
    Complete = 'COMPLETE',
    PartialFirstName = 'PARTIAL_FIRST_NAME',
    Transparent = 'TRANSPARENT'
}

/**
 * 
 * @export
 * @interface OrganizationWrite
 */
export interface OrganizationWrite {
    /**
     * 
     * @type {number}
     * @memberof OrganizationWrite
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWrite
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWrite
     */
    'vatNumber': string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWrite
     */
    'commercialRegistryNumber': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWrite
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {AddressWrite}
     * @memberof OrganizationWrite
     */
    'billingAddress'?: AddressWrite | null;
}
/**
 * 
 * @export
 * @interface Parcel
 */
export interface Parcel {
    /**
     * 
     * @type {number}
     * @memberof Parcel
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'carrier': ParcelCarrierEnum;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'identifier': string;
    /**
     * 
     * @type {number}
     * @memberof Parcel
     */
    'price'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof Parcel
     */
    'refundable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'status'?: ParcelStatusEnum | null;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'dispute'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'transaction'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'updatedAt'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ParcelCarrierEnum {
    SwissPost = 'SwissPost',
    MondialRelay = 'MondialRelay',
    Colissimo = 'Colissimo',
    Dhl = 'Dhl',
    Chronopost = 'Chronopost',
    ColisPrive = 'ColisPrive',
    Dpd = 'Dpd',
    Ups = 'Ups',
    FedEx = 'FedEx',
    RelaisColis = 'RelaisColis'
}
/**
    * @export
    * @enum {string}
    */
export enum ParcelStatusEnum {
    Created = 'CREATED',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Delivered = 'DELIVERED',
    Error = 'ERROR',
    Accepted = 'ACCEPTED',
    Refused = 'REFUSED',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface ParcelDisputeRead
 */
export interface ParcelDisputeRead {
    /**
     * 
     * @type {string}
     * @memberof ParcelDisputeRead
     */
    'carrier': ParcelDisputeReadCarrierEnum;
    /**
     * 
     * @type {string}
     * @memberof ParcelDisputeRead
     */
    'identifier': string;
    /**
     * 
     * @type {number}
     * @memberof ParcelDisputeRead
     */
    'price'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ParcelDisputeRead
     */
    'refundable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ParcelDisputeRead
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParcelDisputeRead
     */
    'status'?: ParcelDisputeReadStatusEnum | null;
    /**
     * 
     * @type {string}
     * @memberof ParcelDisputeRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParcelDisputeRead
     */
    'updatedAt'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ParcelDisputeReadCarrierEnum {
    SwissPost = 'SwissPost',
    MondialRelay = 'MondialRelay',
    Colissimo = 'Colissimo',
    Dhl = 'Dhl',
    Chronopost = 'Chronopost',
    ColisPrive = 'ColisPrive',
    Dpd = 'Dpd',
    Ups = 'Ups',
    FedEx = 'FedEx',
    RelaisColis = 'RelaisColis'
}
/**
    * @export
    * @enum {string}
    */
export enum ParcelDisputeReadStatusEnum {
    Created = 'CREATED',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Delivered = 'DELIVERED',
    Error = 'ERROR',
    Accepted = 'ACCEPTED',
    Refused = 'REFUSED',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface ParcelIndependentWrite
 */
export interface ParcelIndependentWrite {
    /**
     * 
     * @type {string}
     * @memberof ParcelIndependentWrite
     */
    'carrier'?: ParcelIndependentWriteCarrierEnum;
    /**
     * 
     * @type {string}
     * @memberof ParcelIndependentWrite
     */
    'identifier'?: string;
    /**
     * 
     * @type {number}
     * @memberof ParcelIndependentWrite
     */
    'price'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ParcelIndependentWrite
     */
    'refundable': boolean;
    /**
     * 
     * @type {string}
     * @memberof ParcelIndependentWrite
     */
    'currency'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ParcelIndependentWriteCarrierEnum {
    SwissPost = 'SwissPost',
    MondialRelay = 'MondialRelay',
    Colissimo = 'Colissimo',
    Dhl = 'Dhl',
    Chronopost = 'Chronopost',
    ColisPrive = 'ColisPrive',
    Dpd = 'Dpd',
    Ups = 'Ups',
    FedEx = 'FedEx',
    RelaisColis = 'RelaisColis'
}

/**
 * 
 * @export
 * @interface ParcelRead
 */
export interface ParcelRead {
    /**
     * 
     * @type {string}
     * @memberof ParcelRead
     */
    'carrier': ParcelReadCarrierEnum;
    /**
     * 
     * @type {string}
     * @memberof ParcelRead
     */
    'identifier': string;
    /**
     * 
     * @type {number}
     * @memberof ParcelRead
     */
    'price'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ParcelRead
     */
    'refundable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ParcelRead
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParcelRead
     */
    'status'?: ParcelReadStatusEnum | null;
    /**
     * 
     * @type {string}
     * @memberof ParcelRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParcelRead
     */
    'updatedAt'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ParcelReadCarrierEnum {
    SwissPost = 'SwissPost',
    MondialRelay = 'MondialRelay',
    Colissimo = 'Colissimo',
    Dhl = 'Dhl',
    Chronopost = 'Chronopost',
    ColisPrive = 'ColisPrive',
    Dpd = 'Dpd',
    Ups = 'Ups',
    FedEx = 'FedEx',
    RelaisColis = 'RelaisColis'
}
/**
    * @export
    * @enum {string}
    */
export enum ParcelReadStatusEnum {
    Created = 'CREATED',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Delivered = 'DELIVERED',
    Error = 'ERROR',
    Accepted = 'ACCEPTED',
    Refused = 'REFUSED',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface ParcelWrite
 */
export interface ParcelWrite {
    /**
     * 
     * @type {string}
     * @memberof ParcelWrite
     */
    'carrier'?: ParcelWriteCarrierEnum;
    /**
     * 
     * @type {string}
     * @memberof ParcelWrite
     */
    'identifier'?: string;
    /**
     * 
     * @type {number}
     * @memberof ParcelWrite
     */
    'price'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ParcelWrite
     */
    'refundable': boolean;
    /**
     * 
     * @type {string}
     * @memberof ParcelWrite
     */
    'currency'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ParcelWriteCarrierEnum {
    SwissPost = 'SwissPost',
    MondialRelay = 'MondialRelay',
    Colissimo = 'Colissimo',
    Dhl = 'Dhl',
    Chronopost = 'Chronopost',
    ColisPrive = 'ColisPrive',
    Dpd = 'Dpd',
    Ups = 'Ups',
    FedEx = 'FedEx',
    RelaisColis = 'RelaisColis'
}

/**
 * 
 * @export
 * @interface Persona
 */
export interface Persona {
    /**
     * 
     * @type {number}
     * @memberof Persona
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'captcha'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'organization'?: string | null;
    /**
     * The URL you wish that Persona to go to without additional MFA. The URL MUST concern that Persona.
     * @type {string}
     * @memberof Persona
     */
    'targetUrl'?: string | null;
    /**
     * Url that is able to bypass MFA for a single user. Please note that this should not be shared between the complainant and the seller or anyone external to them.
     * @type {string}
     * @memberof Persona
     */
    'authUrl'?: string | null;
    /**
     * This authenticated-URL cannot be renewed, you will have to re-create one each time. Typically valid for a single hour.
     * @type {string}
     * @memberof Persona
     */
    'expireAt'?: string | null;
    /**
     * The hashed password
     * @type {string}
     * @memberof Persona
     */
    'password'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'plainPassword'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'gender'?: PersonaGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof Persona
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {Address}
     * @memberof Persona
     */
    'address'?: Address | null;
    /**
     * We sort Persona into three distinct risks\' category. This is inferred from the riskScore.
     * @type {string}
     * @memberof Persona
     */
    'riskLevel'?: PersonaRiskLevelEnum | null;
    /**
     * That score is regularly updated, each action taken can potentially update that value. A value close to zero mean zero risk and close to a hundred mean risky.
     * @type {number}
     * @memberof Persona
     */
    'riskScore'?: number | null;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof Persona
     */
    'externalPurchaseCount'?: number;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof Persona
     */
    'externalSellCount'?: number;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<Metadata>}
     * @memberof Persona
     */
    'metadata'?: Array<Metadata>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Persona
     */
    'offers': Array<string>;
    /**
     * 
     * @type {any}
     * @memberof Persona
     */
    'purchases': any;
    /**
     * 
     * @type {Array<View>}
     * @memberof Persona
     */
    'views': Array<View>;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'updatedAt'?: string | null;
    /**
     * Issued Offers count owned by a given Persona
     * @type {number}
     * @memberof Persona
     */
    'offerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Persona
     */
    'purchaseCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Persona
     */
    'roles'?: Array<string>;
    /**
     * Either email or the mobile phone number
     * @type {string}
     * @memberof Persona
     */
    'userIdentifier'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}
/**
    * @export
    * @enum {string}
    */
export enum PersonaRiskLevelEnum {
    Weak = 'WEAK',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface PersonaAuthReturn
 */
export interface PersonaAuthReturn {
    /**
     * Url that is able to bypass MFA for a single user. Please note that this should not be shared between the complainant and the seller or anyone external to them.
     * @type {string}
     * @memberof PersonaAuthReturn
     */
    'authUrl'?: string | null;
    /**
     * This authenticated-URL cannot be renewed, you will have to re-create one each time. Typically valid for a single hour.
     * @type {string}
     * @memberof PersonaAuthReturn
     */
    'expireAt'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaCollectionRead
 */
export interface PersonaCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof PersonaCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'lastName'?: string;
}
/**
 * 
 * @export
 * @interface PersonaDisputeRead
 */
export interface PersonaDisputeRead {
    /**
     * 
     * @type {number}
     * @memberof PersonaDisputeRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PersonaDisputeRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaDisputeRead
     */
    'lastName'?: string;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof PersonaDisputeRead
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaDisputeRead
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaDisputeRead
     */
    'mobilePhoneNumber'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaExternalAuth
 */
export interface PersonaExternalAuth {
    /**
     * 
     * @type {string}
     * @memberof PersonaExternalAuth
     */
    'captcha'?: string | null;
    /**
     * The URL you wish that Persona to go to without additional MFA. The URL MUST concern that Persona.
     * @type {string}
     * @memberof PersonaExternalAuth
     */
    'targetUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaExternalAuth
     */
    'plainPassword'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaExternalAuth
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaExternalAuth
     */
    'mobilePhoneNumber'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaIndependentWrite
 */
export interface PersonaIndependentWrite {
    /**
     * 
     * @type {string}
     * @memberof PersonaIndependentWrite
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaIndependentWrite
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaIndependentWrite
     */
    'gender': PersonaIndependentWriteGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof PersonaIndependentWrite
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof PersonaIndependentWrite
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaIndependentWrite
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaIndependentWrite
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {AddressIndependentWrite}
     * @memberof PersonaIndependentWrite
     */
    'address'?: AddressIndependentWrite | null;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof PersonaIndependentWrite
     */
    'externalPurchaseCount'?: number;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof PersonaIndependentWrite
     */
    'externalSellCount'?: number;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<MetadataIndependentWrite>}
     * @memberof PersonaIndependentWrite
     */
    'metadata'?: Array<MetadataIndependentWrite>;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaIndependentWriteGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * 
 * @export
 * @interface PersonaPostAuthRead
 */
export interface PersonaPostAuthRead {
    /**
     * Url that is able to bypass MFA for a single user. Please note that this should not be shared between the complainant and the seller or anyone external to them.
     * @type {string}
     * @memberof PersonaPostAuthRead
     */
    'authUrl'?: string | null;
    /**
     * This authenticated-URL cannot be renewed, you will have to re-create one each time. Typically valid for a single hour.
     * @type {string}
     * @memberof PersonaPostAuthRead
     */
    'expireAt'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaRead
 */
export interface PersonaRead {
    /**
     * 
     * @type {number}
     * @memberof PersonaRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'lastName'?: string;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof PersonaRead
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'mobilePhoneNumber'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaRegister
 */
export interface PersonaRegister {
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'captcha'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'plainPassword'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'gender': PersonaRegisterGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof PersonaRegister
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'mobilePhoneNumber'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaRegisterGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * 
 * @export
 * @interface PersonaTokenWrite
 */
export interface PersonaTokenWrite {
    /**
     * The URL you wish that Persona to go to without additional MFA. The URL MUST concern that Persona.
     * @type {string}
     * @memberof PersonaTokenWrite
     */
    'targetUrl': string | null;
}
/**
 * 
 * @export
 * @interface PersonaUpdate
 */
export interface PersonaUpdate {
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'gender': PersonaUpdateGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof PersonaUpdate
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {AddressUpdate}
     * @memberof PersonaUpdate
     */
    'address'?: AddressUpdate | null;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof PersonaUpdate
     */
    'externalPurchaseCount'?: number;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof PersonaUpdate
     */
    'externalSellCount'?: number;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<MetadataUpdate>}
     * @memberof PersonaUpdate
     */
    'metadata'?: Array<MetadataUpdate>;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaUpdateGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * 
 * @export
 * @interface PersonaWrite
 */
export interface PersonaWrite {
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'gender': PersonaWriteGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof PersonaWrite
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {AddressWrite}
     * @memberof PersonaWrite
     */
    'address'?: AddressWrite | null;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof PersonaWrite
     */
    'externalPurchaseCount'?: number;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof PersonaWrite
     */
    'externalSellCount'?: number;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<MetadataWrite>}
     * @memberof PersonaWrite
     */
    'metadata'?: Array<MetadataWrite>;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaWriteGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * 
 * @export
 * @interface TransactionCollectionRead
 */
export interface TransactionCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof TransactionCollectionRead
     */
    'ulid': string;
    /**
     * 
     * @type {OfferCollectionRead}
     * @memberof TransactionCollectionRead
     */
    'offer': OfferCollectionRead;
    /**
     * 
     * @type {PersonaCollectionRead}
     * @memberof TransactionCollectionRead
     */
    'buyer': PersonaCollectionRead;
}
/**
 * 
 * @export
 * @interface TransactionDisputeRead
 */
export interface TransactionDisputeRead {
    /**
     * 
     * @type {string}
     * @memberof TransactionDisputeRead
     */
    'ulid': string;
    /**
     * 
     * @type {OfferDisputeRead}
     * @memberof TransactionDisputeRead
     */
    'offer': OfferDisputeRead;
    /**
     * 
     * @type {PersonaDisputeRead}
     * @memberof TransactionDisputeRead
     */
    'buyer': PersonaDisputeRead;
    /**
     * 
     * @type {number}
     * @memberof TransactionDisputeRead
     */
    'fees'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionDisputeRead
     */
    'refundableFees'?: boolean;
    /**
     * 
     * @type {Array<MetadataDisputeRead>}
     * @memberof TransactionDisputeRead
     */
    'metadata'?: Array<MetadataDisputeRead>;
    /**
     * 
     * @type {Array<ParcelDisputeRead>}
     * @memberof TransactionDisputeRead
     */
    'parcels'?: Array<ParcelDisputeRead>;
}
/**
 * 
 * @export
 * @interface TransactionIndependentWrite
 */
export interface TransactionIndependentWrite {
    /**
     * 
     * @type {OfferIndependentWrite}
     * @memberof TransactionIndependentWrite
     */
    'offer': OfferIndependentWrite;
    /**
     * 
     * @type {PersonaIndependentWrite}
     * @memberof TransactionIndependentWrite
     */
    'buyer': PersonaIndependentWrite;
    /**
     * 
     * @type {number}
     * @memberof TransactionIndependentWrite
     */
    'fees'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIndependentWrite
     */
    'refundableFees'?: boolean;
    /**
     * 
     * @type {Array<MetadataIndependentWrite>}
     * @memberof TransactionIndependentWrite
     */
    'metadata'?: Array<MetadataIndependentWrite>;
    /**
     * 
     * @type {Array<ParcelIndependentWrite>}
     * @memberof TransactionIndependentWrite
     */
    'parcels'?: Array<ParcelIndependentWrite>;
}
/**
 * 
 * @export
 * @interface TransactionRead
 */
export interface TransactionRead {
    /**
     * 
     * @type {string}
     * @memberof TransactionRead
     */
    'ulid': string;
    /**
     * 
     * @type {OfferRead}
     * @memberof TransactionRead
     */
    'offer': OfferRead;
    /**
     * 
     * @type {PersonaRead}
     * @memberof TransactionRead
     */
    'buyer': PersonaRead;
    /**
     * 
     * @type {number}
     * @memberof TransactionRead
     */
    'fees'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionRead
     */
    'refundableFees'?: boolean;
    /**
     * 
     * @type {Array<MetadataRead>}
     * @memberof TransactionRead
     */
    'metadata'?: Array<MetadataRead>;
    /**
     * 
     * @type {Array<ParcelRead>}
     * @memberof TransactionRead
     */
    'parcels'?: Array<ParcelRead>;
}
/**
 * 
 * @export
 * @interface UnprocessableEntity
 */
export interface UnprocessableEntity {
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntity
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntity
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntity
     */
    'detail'?: string;
    /**
     * 
     * @type {Array<UnprocessableEntityViolationsInner>}
     * @memberof UnprocessableEntity
     */
    'violations'?: Array<UnprocessableEntityViolationsInner>;
}
/**
 * 
 * @export
 * @interface UnprocessableEntityViolationsInner
 */
export interface UnprocessableEntityViolationsInner {
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntityViolationsInner
     */
    'propertyPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntityViolationsInner
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntityViolationsInner
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'captcha'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'invitedRole'?: Array<UserInvitedRoleEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'roles': Array<UserRolesEnum>;
    /**
     * The hashed password
     * @type {string}
     * @memberof User
     */
    'password'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'plainPassword'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'intlPhoneNumber'?: string | null;
    /**
     * The originating country
     * @type {string}
     * @memberof User
     */
    'originCountry'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'preferredLanguage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastSuccessfulLogIn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'emailVerificationCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'emailVerificationInput'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phoneVerificationCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phoneVerificationInput'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'avatar'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'notifications'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'medias'?: Array<string>;
    /**
     * 
     * @type {Array<View>}
     * @memberof User
     */
    'views': Array<View>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'consentMailNotification': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'consentMailAds': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'keys': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'organization'?: string | null;
    /**
     * A visual identifier that represents this user.
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'salt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'userIdentifier'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum UserInvitedRoleEnum {
    Admin = 'ROLE_ADMIN',
    Consultant = 'ROLE_CONSULTANT',
    AccountingManager = 'ROLE_ACCOUNTING_MANAGER',
    BillingManager = 'ROLE_BILLING_MANAGER',
    CustomerService = 'ROLE_CUSTOMER_SERVICE'
}
/**
    * @export
    * @enum {string}
    */
export enum UserRolesEnum {
    OrganizationOwner = 'ROLE_ORGANIZATION_OWNER',
    Admin = 'ROLE_ADMIN',
    Consultant = 'ROLE_CONSULTANT',
    AccountingManager = 'ROLE_ACCOUNTING_MANAGER',
    BillingManager = 'ROLE_BILLING_MANAGER',
    CustomerService = 'ROLE_CUSTOMER_SERVICE',
    PlatformSupport = 'ROLE_PLATFORM_SUPPORT',
    PlatformAdmin = 'ROLE_PLATFORM_ADMIN',
    User = 'ROLE_USER'
}

/**
 * 
 * @export
 * @interface UserAuthenticatedRead
 */
export interface UserAuthenticatedRead {
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserAuthenticatedRead
     */
    'roles': Array<UserAuthenticatedReadRolesEnum>;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'intlPhoneNumber'?: string | null;
    /**
     * The originating country
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'originCountry'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'preferredLanguage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'lastSuccessfulLogIn'?: string | null;
    /**
     * 
     * @type {MediaAuthenticatedRead}
     * @memberof UserAuthenticatedRead
     */
    'avatar'?: MediaAuthenticatedRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserAuthenticatedRead
     */
    'consentMailNotification': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserAuthenticatedRead
     */
    'consentMailAds': boolean;
    /**
     * 
     * @type {OrganizationAuthenticatedRead}
     * @memberof UserAuthenticatedRead
     */
    'organization'?: OrganizationAuthenticatedRead | null;
}

/**
    * @export
    * @enum {string}
    */
export enum UserAuthenticatedReadRolesEnum {
    OrganizationOwner = 'ROLE_ORGANIZATION_OWNER',
    Admin = 'ROLE_ADMIN',
    Consultant = 'ROLE_CONSULTANT',
    AccountingManager = 'ROLE_ACCOUNTING_MANAGER',
    BillingManager = 'ROLE_BILLING_MANAGER',
    CustomerService = 'ROLE_CUSTOMER_SERVICE',
    PlatformSupport = 'ROLE_PLATFORM_SUPPORT',
    PlatformAdmin = 'ROLE_PLATFORM_ADMIN',
    User = 'ROLE_USER'
}

/**
 * 
 * @export
 * @interface UserCollectionRead
 */
export interface UserCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserCollectionRead
     */
    'roles': Array<UserCollectionReadRolesEnum>;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'intlPhoneNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'lastSuccessfulLogIn'?: string | null;
    /**
     * 
     * @type {MediaCollectionRead}
     * @memberof UserCollectionRead
     */
    'avatar'?: MediaCollectionRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {OrganizationCollectionRead}
     * @memberof UserCollectionRead
     */
    'organization'?: OrganizationCollectionRead | null;
}

/**
    * @export
    * @enum {string}
    */
export enum UserCollectionReadRolesEnum {
    OrganizationOwner = 'ROLE_ORGANIZATION_OWNER',
    Admin = 'ROLE_ADMIN',
    Consultant = 'ROLE_CONSULTANT',
    AccountingManager = 'ROLE_ACCOUNTING_MANAGER',
    BillingManager = 'ROLE_BILLING_MANAGER',
    CustomerService = 'ROLE_CUSTOMER_SERVICE',
    PlatformSupport = 'ROLE_PLATFORM_SUPPORT',
    PlatformAdmin = 'ROLE_PLATFORM_ADMIN',
    User = 'ROLE_USER'
}

/**
 * 
 * @export
 * @interface UserEmailValidationWrite
 */
export interface UserEmailValidationWrite {
    /**
     * 
     * @type {string}
     * @memberof UserEmailValidationWrite
     */
    'captcha': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserEmailValidationWrite
     */
    'plainPassword'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserEmailValidationWrite
     */
    'emailVerificationInput': string | null;
}
/**
 * 
 * @export
 * @interface UserInvite
 */
export interface UserInvite {
    /**
     * 
     * @type {string}
     * @memberof UserInvite
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserInvite
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof UserInvite
     */
    'email': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserInvite
     */
    'invitedRole': Array<UserInviteInvitedRoleEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum UserInviteInvitedRoleEnum {
    Admin = 'ROLE_ADMIN',
    Consultant = 'ROLE_CONSULTANT',
    AccountingManager = 'ROLE_ACCOUNTING_MANAGER',
    BillingManager = 'ROLE_BILLING_MANAGER',
    CustomerService = 'ROLE_CUSTOMER_SERVICE'
}

/**
 * 
 * @export
 * @interface UserPostRegisterRead
 */
export interface UserPostRegisterRead {
    /**
     * 
     * @type {string}
     * @memberof UserPostRegisterRead
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'intlPhoneNumber'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdate
     */
    'consentMailNotification': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdate
     */
    'consentMailAds': boolean;
}
/**
 * 
 * @export
 * @interface UserWrite
 */
export interface UserWrite {
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'captcha': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'publicName': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'roleInCompany': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'plainPassword': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'intlPhoneNumber'?: string | null;
    /**
     * The originating country
     * @type {string}
     * @memberof UserWrite
     */
    'originCountry': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'preferredLanguage': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserWrite
     */
    'consentMailNotification'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserWrite
     */
    'consentMailAds'?: boolean;
    /**
     * 
     * @type {OrganizationWrite}
     * @memberof UserWrite
     */
    'organization'?: OrganizationWrite | null;
}
/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * 
     * @type {number}
     * @memberof View
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'ipAddress': string;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'offer'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'dispute'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'persona'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'user'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof View
     */
    'hitCount': number;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'namedSource'?: ViewNamedSourceEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ViewNamedSourceEnum {
    Buyer = 'BUYER',
    Platform = 'PLATFORM',
    Seller = 'SELLER',
    Other = 'OTHER'
}

/**
 * 
 * @export
 * @interface ViewDisputeRead
 */
export interface ViewDisputeRead {
    /**
     * 
     * @type {number}
     * @memberof ViewDisputeRead
     */
    'hitCount': number;
    /**
     * 
     * @type {string}
     * @memberof ViewDisputeRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViewDisputeRead
     */
    'namedSource'?: ViewDisputeReadNamedSourceEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ViewDisputeReadNamedSourceEnum {
    Buyer = 'BUYER',
    Platform = 'PLATFORM',
    Seller = 'SELLER',
    Other = 'OTHER'
}

/**
 * 
 * @export
 * @interface ViewRead
 */
export interface ViewRead {
    /**
     * 
     * @type {number}
     * @memberof ViewRead
     */
    'hitCount': number;
    /**
     * 
     * @type {string}
     * @memberof ViewRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViewRead
     */
    'namedSource'?: ViewReadNamedSourceEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ViewReadNamedSourceEnum {
    Buyer = 'BUYER',
    Platform = 'PLATFORM',
    Seller = 'SELLER',
    Other = 'OTHER'
}

/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * 
     * @type {number}
     * @memberof Webhook
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'event'?: WebhookEventEnum;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'iri'?: string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'occurredAt'?: string;
    /**
     * 
     * @type {WebhookObject}
     * @memberof Webhook
     */
    'object'?: WebhookObject;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookEventEnum {
    DisputeOpened = 'dispute.opened',
    DisputeSubmitted = 'dispute.submitted',
    DisputeCreated = 'dispute.created',
    DisputeAbandoned = 'dispute.abandoned',
    DisputeSettlement = 'dispute.settlement',
    DisputeClosed = 'dispute.closed',
    DisputeExpired = 'dispute.expired',
    DisputeManualArbitrationRequired = 'dispute.manual_arbitration_required',
    DisputeUpdated = 'dispute.updated',
    DisputeReminder = 'dispute.reminder',
    OfferCreated = 'offer.created',
    OfferExpired = 'offer.expired',
    OfferUpdated = 'offer.updated',
    OfferCrawlFailure = 'offer.crawl_failure',
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionReconciled = 'offer.transaction.reconciled',
    OfferTransactionAbandoned = 'offer.transaction.abandoned',
    OfferClosed = 'offer.closed',
    OfferTransactionRefund = 'offer.transaction.refund',
    PersonaAdded = 'persona.added'
}

/**
 * 
 * @export
 * @interface WebhookHistoryCollectionRead
 */
export interface WebhookHistoryCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryCollectionRead
     */
    'objectId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryCollectionRead
     */
    'event': WebhookHistoryCollectionReadEventEnum;
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryCollectionRead
     */
    'responseCode'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryCollectionRead
     */
    'occurredAt': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryCollectionRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryCollectionRead
     */
    'attemptedAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryCollectionRead
     */
    'retryCount': number;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookHistoryCollectionRead
     */
    'inProgress'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookHistoryCollectionReadEventEnum {
    DisputeOpened = 'dispute.opened',
    DisputeSubmitted = 'dispute.submitted',
    DisputeCreated = 'dispute.created',
    DisputeAbandoned = 'dispute.abandoned',
    DisputeSettlement = 'dispute.settlement',
    DisputeClosed = 'dispute.closed',
    DisputeExpired = 'dispute.expired',
    DisputeManualArbitrationRequired = 'dispute.manual_arbitration_required',
    DisputeUpdated = 'dispute.updated',
    DisputeReminder = 'dispute.reminder',
    OfferCreated = 'offer.created',
    OfferExpired = 'offer.expired',
    OfferUpdated = 'offer.updated',
    OfferCrawlFailure = 'offer.crawl_failure',
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionReconciled = 'offer.transaction.reconciled',
    OfferTransactionAbandoned = 'offer.transaction.abandoned',
    OfferClosed = 'offer.closed',
    OfferTransactionRefund = 'offer.transaction.refund',
    PersonaAdded = 'persona.added'
}

/**
 * 
 * @export
 * @interface WebhookHistoryRead
 */
export interface WebhookHistoryRead {
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'objectId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'event': WebhookHistoryReadEventEnum;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'url': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WebhookHistoryRead
     */
    'normalizedObject'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryRead
     */
    'responseCode'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'responseBody'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'occurredAt': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'attemptedAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryRead
     */
    'retryCount': number;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookHistoryRead
     */
    'inProgress'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookHistoryReadEventEnum {
    DisputeOpened = 'dispute.opened',
    DisputeSubmitted = 'dispute.submitted',
    DisputeCreated = 'dispute.created',
    DisputeAbandoned = 'dispute.abandoned',
    DisputeSettlement = 'dispute.settlement',
    DisputeClosed = 'dispute.closed',
    DisputeExpired = 'dispute.expired',
    DisputeManualArbitrationRequired = 'dispute.manual_arbitration_required',
    DisputeUpdated = 'dispute.updated',
    DisputeReminder = 'dispute.reminder',
    OfferCreated = 'offer.created',
    OfferExpired = 'offer.expired',
    OfferUpdated = 'offer.updated',
    OfferCrawlFailure = 'offer.crawl_failure',
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionReconciled = 'offer.transaction.reconciled',
    OfferTransactionAbandoned = 'offer.transaction.abandoned',
    OfferClosed = 'offer.closed',
    OfferTransactionRefund = 'offer.transaction.refund',
    PersonaAdded = 'persona.added'
}

/**
 * 
 * @export
 * @interface WebhookObject
 */
export interface WebhookObject {
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'ulid': any;
    /**
     * 
     * @type {TransactionRead}
     * @memberof WebhookObject
     */
    'transaction'?: TransactionRead;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'status': WebhookObjectStatusEnum;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {any}
     * @memberof WebhookObject
     */
    'redirectUrl'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'itemCount'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'issueType'?: WebhookObjectIssueTypeEnum;
    /**
     * To be set only in conjunction of issueType = NOT_AS_DESCRIBED.
     * @type {any}
     * @memberof WebhookObject
     */
    'issueInDescriptionType'?: WebhookObjectIssueInDescriptionTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'issueMentionedInOffer'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'issueDetails'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'complainantTruthfulnessScore': any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'sellerTruthfulnessScore': any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'complainantStake'?: WebhookObjectComplainantStakeEnum;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'inferredStake'?: WebhookObjectInferredStakeEnum;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'recommendedSolution'?: WebhookObjectRecommendedSolutionEnum;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'recommendedPartialRefundAmount'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'chosenSolution'?: WebhookObjectChosenSolutionEnum;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'chosenPartialRefundAmount'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'counterSolution'?: WebhookObjectCounterSolutionEnum;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'counterPartialRefundAmount'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'sellerNotes'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'sellerRejectionReason'?: WebhookObjectSellerRejectionReasonEnum;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'complainantApproval'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'sellerApproval'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'platformSolution'?: WebhookObjectPlatformSolutionEnum;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'platformPartialRefundAmount'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'platformApproval'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'platformActorType'?: WebhookObjectPlatformActorTypeEnum;
    /**
     * Explicit additional information about the platform decision. Could be written by AI, Ruling or Customer Care.
     * @type {any}
     * @memberof WebhookObject
     */
    'platformReasoning'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'arbitrationBy'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'parcels': any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'views': any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'metadata': any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'events'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'createdAt'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'updatedAt'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'viewCount'?: any;
    /**
     * Yield if eligible the date-time at which the dispute state expire.
     * @type {any}
     * @memberof WebhookObject
     */
    'statusExpiration'?: any;
    /**
     * Determine who is awaited (actor) for the next transition
     * @type {any}
     * @memberof WebhookObject
     */
    'awaitedParty'?: WebhookObjectAwaitedPartyEnum;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'iri'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'messageCount'?: any;
    /**
     * Determine who won the case, if not specified, then it is ongoing.
     * @type {any}
     * @memberof WebhookObject
     */
    'closedInFavorOf'?: WebhookObjectClosedInFavorOfEnum;
    /**
     * Total amount disbursed by the buyer to acquire the item.
     * @type {any}
     * @memberof WebhookObject
     */
    'disbursedByBuyer'?: any;
    /**
     * How much the buyer can actually receive back in case of a full refund.
     * @type {any}
     * @memberof WebhookObject
     */
    'maxRefundableForBuyer'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'firstName'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'lastName'?: any;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {any}
     * @memberof WebhookObject
     */
    'language'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'email'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'mobilePhoneNumber'?: any;
    /**
     * If specified, there would be not need for you to fill-in details. Must be accessible over WAN.
     * @type {any}
     * @memberof WebhookObject
     */
    'publicUrl'?: any;
    /**
     * 
     * @type {OrganizationRead}
     * @memberof WebhookObject
     */
    'organization'?: OrganizationRead;
    /**
     * If the seller is actually YOUR organization, set it to NULL.
     * @type {PersonaRead}
     * @memberof WebhookObject
     */
    'seller': PersonaRead;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {any}
     * @memberof WebhookObject
     */
    'nature': WebhookObjectNatureEnum;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'title'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'unitPrice'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'currencyCode'?: any;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'condition'?: WebhookObjectConditionEnum;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'medias': any;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectStatusEnum {
    Created = 'CREATED',
    Submitted = 'SUBMITTED',
    Opened = 'OPENED',
    Abandoned = 'ABANDONED',
    Objected = 'OBJECTED',
    PendingShipment = 'PENDING_SHIPMENT',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Returned = 'RETURNED',
    Dismissed = 'DISMISSED',
    Resolved = 'RESOLVED',
    Pending = 'PENDING'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectIssueTypeEnum {
    NotAsDescribed = 'NOT_AS_DESCRIBED',
    DoesNotWork = 'DOES_NOT_WORK',
    IsIncomplete = 'IS_INCOMPLETE',
    DeliveryIssue = 'DELIVERY_ISSUE',
    AllegedFraud = 'ALLEGED_FRAUD',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectIssueInDescriptionTypeEnum {
    WrongColour = 'WRONG_COLOUR',
    DamagedOrUsed = 'DAMAGED_OR_USED',
    IncorrectFormatOrSize = 'INCORRECT_FORMAT_OR_SIZE',
    DifferentMaterial = 'DIFFERENT_MATERIAL',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectComplainantStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectInferredStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectRecommendedSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectChosenSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectCounterSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectSellerRejectionReasonEnum {
    UnjustifiedRequest = 'UNJUSTIFIED_REQUEST',
    AbusiveRequest = 'ABUSIVE_REQUEST',
    FraudAttempt = 'FRAUD_ATTEMPT',
    Other = 'OTHER',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectPlatformSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectPlatformActorTypeEnum {
    Ruling = 'RULING',
    Ai = 'AI',
    CustomerCare = 'CUSTOMER_CARE',
    PlatformSupport = 'PLATFORM_SUPPORT',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectAwaitedPartyEnum {
    Buyer = 'BUYER',
    Platform = 'PLATFORM',
    Seller = 'SELLER'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectClosedInFavorOfEnum {
    Buyer = 'BUYER',
    Seller = 'SELLER'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}

/**
 * 
 * @export
 * @interface WebhookSubscriptionRead
 */
export interface WebhookSubscriptionRead {
    /**
     * 
     * @type {number}
     * @memberof WebhookSubscriptionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionRead
     */
    'event'?: WebhookSubscriptionReadEventEnum | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionRead
     */
    'callbackUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionRead
     */
    'webhookSecret': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionRead
     */
    'createdAt'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookSubscriptionReadEventEnum {
    DisputeOpened = 'dispute.opened',
    DisputeSubmitted = 'dispute.submitted',
    DisputeCreated = 'dispute.created',
    DisputeAbandoned = 'dispute.abandoned',
    DisputeSettlement = 'dispute.settlement',
    DisputeClosed = 'dispute.closed',
    DisputeExpired = 'dispute.expired',
    DisputeManualArbitrationRequired = 'dispute.manual_arbitration_required',
    DisputeUpdated = 'dispute.updated',
    DisputeReminder = 'dispute.reminder',
    OfferCreated = 'offer.created',
    OfferExpired = 'offer.expired',
    OfferUpdated = 'offer.updated',
    OfferCrawlFailure = 'offer.crawl_failure',
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionReconciled = 'offer.transaction.reconciled',
    OfferTransactionAbandoned = 'offer.transaction.abandoned',
    OfferClosed = 'offer.closed',
    OfferTransactionRefund = 'offer.transaction.refund',
    PersonaAdded = 'persona.added',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface WebhookSubscriptionWrite
 */
export interface WebhookSubscriptionWrite {
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionWrite
     */
    'event'?: WebhookSubscriptionWriteEventEnum | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionWrite
     */
    'callbackUrl': string;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookSubscriptionWriteEventEnum {
    DisputeOpened = 'dispute.opened',
    DisputeSubmitted = 'dispute.submitted',
    DisputeCreated = 'dispute.created',
    DisputeAbandoned = 'dispute.abandoned',
    DisputeSettlement = 'dispute.settlement',
    DisputeClosed = 'dispute.closed',
    DisputeExpired = 'dispute.expired',
    DisputeManualArbitrationRequired = 'dispute.manual_arbitration_required',
    DisputeUpdated = 'dispute.updated',
    DisputeReminder = 'dispute.reminder',
    OfferCreated = 'offer.created',
    OfferExpired = 'offer.expired',
    OfferUpdated = 'offer.updated',
    OfferCrawlFailure = 'offer.crawl_failure',
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionReconciled = 'offer.transaction.reconciled',
    OfferTransactionAbandoned = 'offer.transaction.abandoned',
    OfferClosed = 'offer.closed',
    OfferTransactionRefund = 'offer.transaction.refund',
    PersonaAdded = 'persona.added',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface WorkflowEventDisputeRead
 */
export interface WorkflowEventDisputeRead {
    /**
     * 
     * @type {string}
     * @memberof WorkflowEventDisputeRead
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowEventDisputeRead
     */
    'from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowEventDisputeRead
     */
    'to'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowEventDisputeRead
     */
    'event'?: WorkflowEventDisputeReadEventEnum | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowEventDisputeRead
     */
    'occurredAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowEventDisputeRead
     */
    'initiator'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum WorkflowEventDisputeReadEventEnum {
    DisputeOpened = 'dispute.opened',
    DisputeSubmitted = 'dispute.submitted',
    DisputeCreated = 'dispute.created',
    DisputeAbandoned = 'dispute.abandoned',
    DisputeSettlement = 'dispute.settlement',
    DisputeClosed = 'dispute.closed',
    DisputeExpired = 'dispute.expired',
    DisputeManualArbitrationRequired = 'dispute.manual_arbitration_required',
    DisputeUpdated = 'dispute.updated',
    DisputeReminder = 'dispute.reminder',
    OfferCreated = 'offer.created',
    OfferExpired = 'offer.expired',
    OfferUpdated = 'offer.updated',
    OfferCrawlFailure = 'offer.crawl_failure',
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionReconciled = 'offer.transaction.reconciled',
    OfferTransactionAbandoned = 'offer.transaction.abandoned',
    OfferClosed = 'offer.closed',
    OfferTransactionRefund = 'offer.transaction.refund',
    PersonaAdded = 'persona.added',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface WorkflowEventRead
 */
export interface WorkflowEventRead {
    /**
     * 
     * @type {string}
     * @memberof WorkflowEventRead
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowEventRead
     */
    'from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowEventRead
     */
    'to'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowEventRead
     */
    'event'?: WorkflowEventReadEventEnum | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowEventRead
     */
    'occurredAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowEventRead
     */
    'initiator'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum WorkflowEventReadEventEnum {
    DisputeOpened = 'dispute.opened',
    DisputeSubmitted = 'dispute.submitted',
    DisputeCreated = 'dispute.created',
    DisputeAbandoned = 'dispute.abandoned',
    DisputeSettlement = 'dispute.settlement',
    DisputeClosed = 'dispute.closed',
    DisputeExpired = 'dispute.expired',
    DisputeManualArbitrationRequired = 'dispute.manual_arbitration_required',
    DisputeUpdated = 'dispute.updated',
    DisputeReminder = 'dispute.reminder',
    OfferCreated = 'offer.created',
    OfferExpired = 'offer.expired',
    OfferUpdated = 'offer.updated',
    OfferCrawlFailure = 'offer.crawl_failure',
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionReconciled = 'offer.transaction.reconciled',
    OfferTransactionAbandoned = 'offer.transaction.abandoned',
    OfferClosed = 'offer.closed',
    OfferTransactionRefund = 'offer.transaction.refund',
    PersonaAdded = 'persona.added',
    Null = 'null'
}


/**
 * BrandingApi - axios parameter creator
 * @export
 */
export const BrandingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Updates the Organization resource.
         * @summary Update your Organization details, branding or parameters
         * @param {string} id Organization identifier
         * @param {OrganizationUpdate} organizationUpdate The updated Organization resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdPatch: async (id: string, organizationUpdate: OrganizationUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdPatch', 'id', id)
            // verify required parameter 'organizationUpdate' is not null or undefined
            assertParamExists('apiOrganizationsIdPatch', 'organizationUpdate', organizationUpdate)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Icon
         * @param {string} id Media identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdiconDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdiconDelete', 'id', id)
            const localVarPath = `/organizations/{id}/icon`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization Icon
         * @param {string} id Media identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdiconPost: async (id: string, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdiconPost', 'id', id)
            const localVarPath = `/organizations/{id}/icon`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Logo
         * @param {string} id Media identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdlogoDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdlogoDelete', 'id', id)
            const localVarPath = `/organizations/{id}/logo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization logo
         * @param {string} id Media identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdlogoPost: async (id: string, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdlogoPost', 'id', id)
            const localVarPath = `/organizations/{id}/logo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrandingApi - functional programming interface
 * @export
 */
export const BrandingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrandingApiAxiosParamCreator(configuration)
    return {
        /**
         * Updates the Organization resource.
         * @summary Update your Organization details, branding or parameters
         * @param {string} id Organization identifier
         * @param {OrganizationUpdate} organizationUpdate The updated Organization resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdPatch(id: string, organizationUpdate: OrganizationUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdPatch(id, organizationUpdate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BrandingApi.apiOrganizationsIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Icon
         * @param {string} id Media identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdiconDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdiconDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BrandingApi.apiOrganizationsIdiconDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization Icon
         * @param {string} id Media identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdiconPost(id: string, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdiconPost(id, file, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BrandingApi.apiOrganizationsIdiconPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Logo
         * @param {string} id Media identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdlogoDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdlogoDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BrandingApi.apiOrganizationsIdlogoDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization logo
         * @param {string} id Media identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdlogoPost(id: string, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdlogoPost(id, file, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BrandingApi.apiOrganizationsIdlogoPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * BrandingApi - factory interface
 * @export
 */
export const BrandingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrandingApiFp(configuration)
    return {
        /**
         * Updates the Organization resource.
         * @summary Update your Organization details, branding or parameters
         * @param {string} id Organization identifier
         * @param {OrganizationUpdate} organizationUpdate The updated Organization resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdPatch(id: string, organizationUpdate: OrganizationUpdate, options?: any): AxiosPromise<OrganizationRead> {
            return localVarFp.apiOrganizationsIdPatch(id, organizationUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Icon
         * @param {string} id Media identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdiconDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdiconDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization Icon
         * @param {string} id Media identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdiconPost(id: string, file?: File, options?: any): AxiosPromise<MediaRead> {
            return localVarFp.apiOrganizationsIdiconPost(id, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Logo
         * @param {string} id Media identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdlogoDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdlogoDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization logo
         * @param {string} id Media identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdlogoPost(id: string, file?: File, options?: any): AxiosPromise<MediaRead> {
            return localVarFp.apiOrganizationsIdlogoPost(id, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrandingApi - object-oriented interface
 * @export
 * @class BrandingApi
 * @extends {BaseAPI}
 */
export class BrandingApi extends BaseAPI {
    /**
     * Updates the Organization resource.
     * @summary Update your Organization details, branding or parameters
     * @param {string} id Organization identifier
     * @param {OrganizationUpdate} organizationUpdate The updated Organization resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdPatch(id: string, organizationUpdate: OrganizationUpdate, options?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdPatch(id, organizationUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Media resource.
     * @summary Unset your Organization Icon
     * @param {string} id Media identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdiconDelete(id: string, options?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdiconDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Media resource.
     * @summary Upload your Organization Icon
     * @param {string} id Media identifier
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdiconPost(id: string, file?: File, options?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdiconPost(id, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Media resource.
     * @summary Unset your Organization Logo
     * @param {string} id Media identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdlogoDelete(id: string, options?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdlogoDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Media resource.
     * @summary Upload your Organization logo
     * @param {string} id Media identifier
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdlogoPost(id: string, file?: File, options?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdlogoPost(id, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationApi - axios parameter creator
 * @export
 */
export const NotificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieve pending notifications for Persona
         * @param {string} id Persona identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdnotificationsGetCollection: async (id: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdnotificationsGetCollection', 'id', id)
            const localVarPath = `/personas/{id}/notifications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for Persona
         * @param {string} personaId Persona identifier
         * @param {string} id Notification identifier
         * @param {NotificationUpdate} notificationUpdate The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasPersonaIdnotificationsIdPatch: async (personaId: string, id: string, notificationUpdate: NotificationUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('apiPersonasPersonaIdnotificationsIdPatch', 'personaId', personaId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasPersonaIdnotificationsIdPatch', 'id', id)
            // verify required parameter 'notificationUpdate' is not null or undefined
            assertParamExists('apiPersonasPersonaIdnotificationsIdPatch', 'notificationUpdate', notificationUpdate)
            const localVarPath = `/personas/{personaId}/notifications/{id}`
                .replace(`{${"personaId"}}`, encodeURIComponent(String(personaId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieves the collection of Notification resources.
         * @param {string} id User identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdnotificationsGetCollection: async (id: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdnotificationsGetCollection', 'id', id)
            const localVarPath = `/users/{id}/notifications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for User
         * @param {string} userId User identifier
         * @param {string} id Notification identifier
         * @param {NotificationUpdate} notificationUpdate The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdnotificationsIdPatch: async (userId: string, id: string, notificationUpdate: NotificationUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdnotificationsIdPatch', 'userId', userId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersUserIdnotificationsIdPatch', 'id', id)
            // verify required parameter 'notificationUpdate' is not null or undefined
            assertParamExists('apiUsersUserIdnotificationsIdPatch', 'notificationUpdate', notificationUpdate)
            const localVarPath = `/users/{userId}/notifications/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationApi - functional programming interface
 * @export
 */
export const NotificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieve pending notifications for Persona
         * @param {string} id Persona identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdnotificationsGetCollection(id: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdnotificationsGetCollection(id, page, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NotificationApi.apiPersonasIdnotificationsGetCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for Persona
         * @param {string} personaId Persona identifier
         * @param {string} id Notification identifier
         * @param {NotificationUpdate} notificationUpdate The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasPersonaIdnotificationsIdPatch(personaId: string, id: string, notificationUpdate: NotificationUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasPersonaIdnotificationsIdPatch(personaId, id, notificationUpdate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NotificationApi.apiPersonasPersonaIdnotificationsIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieves the collection of Notification resources.
         * @param {string} id User identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdnotificationsGetCollection(id: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdnotificationsGetCollection(id, page, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NotificationApi.apiUsersIdnotificationsGetCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for User
         * @param {string} userId User identifier
         * @param {string} id Notification identifier
         * @param {NotificationUpdate} notificationUpdate The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdnotificationsIdPatch(userId: string, id: string, notificationUpdate: NotificationUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdnotificationsIdPatch(userId, id, notificationUpdate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NotificationApi.apiUsersUserIdnotificationsIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * NotificationApi - factory interface
 * @export
 */
export const NotificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieve pending notifications for Persona
         * @param {string} id Persona identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdnotificationsGetCollection(id: string, page?: number, options?: any): AxiosPromise<Array<NotificationRead>> {
            return localVarFp.apiPersonasIdnotificationsGetCollection(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for Persona
         * @param {string} personaId Persona identifier
         * @param {string} id Notification identifier
         * @param {NotificationUpdate} notificationUpdate The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasPersonaIdnotificationsIdPatch(personaId: string, id: string, notificationUpdate: NotificationUpdate, options?: any): AxiosPromise<NotificationRead> {
            return localVarFp.apiPersonasPersonaIdnotificationsIdPatch(personaId, id, notificationUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieves the collection of Notification resources.
         * @param {string} id User identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdnotificationsGetCollection(id: string, page?: number, options?: any): AxiosPromise<Array<NotificationRead>> {
            return localVarFp.apiUsersIdnotificationsGetCollection(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for User
         * @param {string} userId User identifier
         * @param {string} id Notification identifier
         * @param {NotificationUpdate} notificationUpdate The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdnotificationsIdPatch(userId: string, id: string, notificationUpdate: NotificationUpdate, options?: any): AxiosPromise<NotificationRead> {
            return localVarFp.apiUsersUserIdnotificationsIdPatch(userId, id, notificationUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
export class NotificationApi extends BaseAPI {
    /**
     * Retrieves the collection of Notification resources.
     * @summary Retrieve pending notifications for Persona
     * @param {string} id Persona identifier
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public apiPersonasIdnotificationsGetCollection(id: string, page?: number, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).apiPersonasIdnotificationsGetCollection(id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the Notification resource.
     * @summary Mark as read/unread a notification for Persona
     * @param {string} personaId Persona identifier
     * @param {string} id Notification identifier
     * @param {NotificationUpdate} notificationUpdate The updated Notification resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public apiPersonasPersonaIdnotificationsIdPatch(personaId: string, id: string, notificationUpdate: NotificationUpdate, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).apiPersonasPersonaIdnotificationsIdPatch(personaId, id, notificationUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of Notification resources.
     * @summary Retrieves the collection of Notification resources.
     * @param {string} id User identifier
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public apiUsersIdnotificationsGetCollection(id: string, page?: number, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).apiUsersIdnotificationsGetCollection(id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the Notification resource.
     * @summary Mark as read/unread a notification for User
     * @param {string} userId User identifier
     * @param {string} id Notification identifier
     * @param {NotificationUpdate} notificationUpdate The updated Notification resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public apiUsersUserIdnotificationsIdPatch(userId: string, id: string, notificationUpdate: NotificationUpdate, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).apiUsersUserIdnotificationsIdPatch(userId, id, notificationUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Organization resources.
         * @summary Retrieves the collection of Organization resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsGetCollection: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Organization resource.
         * @summary Retrieves a Organization resource.
         * @param {string} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdGet', 'id', id)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Organization resources.
         * @summary Retrieves the collection of Organization resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsGetCollection(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsGetCollection(page, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OrganizationApi.apiOrganizationsGetCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves a Organization resource.
         * @summary Retrieves a Organization resource.
         * @param {string} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OrganizationApi.apiOrganizationsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Organization resources.
         * @summary Retrieves the collection of Organization resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsGetCollection(page?: number, options?: any): AxiosPromise<Array<OrganizationCollectionRead>> {
            return localVarFp.apiOrganizationsGetCollection(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Organization resource.
         * @summary Retrieves a Organization resource.
         * @param {string} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdGet(id: string, options?: any): AxiosPromise<OrganizationRead> {
            return localVarFp.apiOrganizationsIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * Retrieves the collection of Organization resources.
     * @summary Retrieves the collection of Organization resources.
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public apiOrganizationsGetCollection(page?: number, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).apiOrganizationsGetCollection(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Organization resource.
     * @summary Retrieves a Organization resource.
     * @param {string} id Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public apiOrganizationsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).apiOrganizationsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PersonaApi - axios parameter creator
 * @export
 */
export const PersonaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Persona resources.
         * @summary Retrieves the collection of Persona resources.
         * @param {number} [page] The collection page number
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {Array<string>} [email2] 
         * @param {string} [mobilePhoneNumber] 
         * @param {Array<string>} [mobilePhoneNumber2] 
         * @param {ApiPersonasGetCollectionGenderEnum} [gender] Filter on a limited subset of gender
         * @param {ApiPersonasGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {string} [dateOfBirthBefore] 
         * @param {string} [dateOfBirthStrictlyBefore] 
         * @param {string} [dateOfBirthAfter] 
         * @param {string} [dateOfBirthStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasGetCollection: async (page?: number, firstName?: string, lastName?: string, email?: string, email2?: Array<string>, mobilePhoneNumber?: string, mobilePhoneNumber2?: Array<string>, gender?: ApiPersonasGetCollectionGenderEnum, orderCreatedAt?: ApiPersonasGetCollectionOrderCreatedAtEnum, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, dateOfBirthBefore?: string, dateOfBirthStrictlyBefore?: string, dateOfBirthAfter?: string, dateOfBirthStrictlyAfter?: string, metadata?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/personas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['firstName'] = firstName;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['lastName'] = lastName;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (email2) {
                localVarQueryParameter['email[]'] = email2;
            }

            if (mobilePhoneNumber !== undefined) {
                localVarQueryParameter['mobilePhoneNumber'] = mobilePhoneNumber;
            }

            if (mobilePhoneNumber2) {
                localVarQueryParameter['mobilePhoneNumber[]'] = mobilePhoneNumber2;
            }

            if (gender !== undefined) {
                localVarQueryParameter['gender'] = gender;
            }

            if (orderCreatedAt !== undefined) {
                localVarQueryParameter['order[createdAt]'] = orderCreatedAt;
            }

            if (createdAtBefore !== undefined) {
                localVarQueryParameter['createdAt[before]'] = createdAtBefore;
            }

            if (createdAtStrictlyBefore !== undefined) {
                localVarQueryParameter['createdAt[strictly_before]'] = createdAtStrictlyBefore;
            }

            if (createdAtAfter !== undefined) {
                localVarQueryParameter['createdAt[after]'] = createdAtAfter;
            }

            if (createdAtStrictlyAfter !== undefined) {
                localVarQueryParameter['createdAt[strictly_after]'] = createdAtStrictlyAfter;
            }

            if (dateOfBirthBefore !== undefined) {
                localVarQueryParameter['dateOfBirth[before]'] = dateOfBirthBefore;
            }

            if (dateOfBirthStrictlyBefore !== undefined) {
                localVarQueryParameter['dateOfBirth[strictly_before]'] = dateOfBirthStrictlyBefore;
            }

            if (dateOfBirthAfter !== undefined) {
                localVarQueryParameter['dateOfBirth[after]'] = dateOfBirthAfter;
            }

            if (dateOfBirthStrictlyAfter !== undefined) {
                localVarQueryParameter['dateOfBirth[strictly_after]'] = dateOfBirthStrictlyAfter;
            }

            if (metadata) {
                localVarQueryParameter['metadata[]'] = metadata.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You **MAY** unregister (or free the email/phone number) your Persona entry using that endpoint. *Please note that* this operation will fail if that Persona have any ongoing operations.
         * @summary Unregister a Persona (Your customer)
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdDelete', 'id', id)
            const localVarPath = `/personas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_WRITE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Persona resource.
         * @summary Retrieves a Persona resource.
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdGet', 'id', id)
            const localVarPath = `/personas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update your Persona (eg. your customer/user entry) through that API call. _Beware that updating_ **email** and/or the **mobile phone number** must be done using non reserved values. Otherwise this operation will be rejected.
         * @summary Updates the Persona resource.
         * @param {string} id Persona identifier
         * @param {PersonaUpdate} personaUpdate The updated Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdPatch: async (id: string, personaUpdate: PersonaUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdPatch', 'id', id)
            // verify required parameter 'personaUpdate' is not null or undefined
            assertParamExists('apiPersonasIdPatch', 'personaUpdate', personaUpdate)
            const localVarPath = `/personas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Without this, your users may be required to pass a MFA challenge even if they are already logged-in from your website. Pass the URL you wish your user access, either a Dispute or Safe-checkout resource.
         * @summary Issue authenticated URL for single end-user
         * @param {string} id Persona identifier
         * @param {PersonaTokenWrite} personaTokenWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdtokenPost: async (id: string, personaTokenWrite: PersonaTokenWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdtokenPost', 'id', id)
            // verify required parameter 'personaTokenWrite' is not null or undefined
            assertParamExists('apiPersonasIdtokenPost', 'personaTokenWrite', personaTokenWrite)
            const localVarPath = `/personas/{id}/token`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_AUTH"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaTokenWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You should not register your whole database of users, only those who are concerned by a Safe-checkout or Dispute operation. One Persona entry for your organization can be assigned as a seller or buyer.  **Notes:**   - (i) There is a unique constraint for the mobile phone numbers and email.   - (ii) You will have to issue a DELETE operation on a Persona that withhold a specific phone number or email.   - (iii) You are NOT REQUIRED to provide email OR a mobile phone number but it is highly recommended, if none provided the email will be generated as \'{ulid}@your-domain.tld\'. In that case, please specify at least one metadata in order to find your entry with ease.
         * @summary Register a Persona (Your customer)
         * @param {PersonaWrite} personaWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasPost: async (personaWrite: PersonaWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaWrite' is not null or undefined
            assertParamExists('apiPersonasPost', 'personaWrite', personaWrite)
            const localVarPath = `/personas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonaApi - functional programming interface
 * @export
 */
export const PersonaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonaApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Persona resources.
         * @summary Retrieves the collection of Persona resources.
         * @param {number} [page] The collection page number
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {Array<string>} [email2] 
         * @param {string} [mobilePhoneNumber] 
         * @param {Array<string>} [mobilePhoneNumber2] 
         * @param {ApiPersonasGetCollectionGenderEnum} [gender] Filter on a limited subset of gender
         * @param {ApiPersonasGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {string} [dateOfBirthBefore] 
         * @param {string} [dateOfBirthStrictlyBefore] 
         * @param {string} [dateOfBirthAfter] 
         * @param {string} [dateOfBirthStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasGetCollection(page?: number, firstName?: string, lastName?: string, email?: string, email2?: Array<string>, mobilePhoneNumber?: string, mobilePhoneNumber2?: Array<string>, gender?: ApiPersonasGetCollectionGenderEnum, orderCreatedAt?: ApiPersonasGetCollectionOrderCreatedAtEnum, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, dateOfBirthBefore?: string, dateOfBirthStrictlyBefore?: string, dateOfBirthAfter?: string, dateOfBirthStrictlyAfter?: string, metadata?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PersonaCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasGetCollection(page, firstName, lastName, email, email2, mobilePhoneNumber, mobilePhoneNumber2, gender, orderCreatedAt, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, dateOfBirthBefore, dateOfBirthStrictlyBefore, dateOfBirthAfter, dateOfBirthStrictlyAfter, metadata, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PersonaApi.apiPersonasGetCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * You **MAY** unregister (or free the email/phone number) your Persona entry using that endpoint. *Please note that* this operation will fail if that Persona have any ongoing operations.
         * @summary Unregister a Persona (Your customer)
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PersonaApi.apiPersonasIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves a Persona resource.
         * @summary Retrieves a Persona resource.
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PersonaApi.apiPersonasIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update your Persona (eg. your customer/user entry) through that API call. _Beware that updating_ **email** and/or the **mobile phone number** must be done using non reserved values. Otherwise this operation will be rejected.
         * @summary Updates the Persona resource.
         * @param {string} id Persona identifier
         * @param {PersonaUpdate} personaUpdate The updated Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdPatch(id: string, personaUpdate: PersonaUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdPatch(id, personaUpdate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PersonaApi.apiPersonasIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Without this, your users may be required to pass a MFA challenge even if they are already logged-in from your website. Pass the URL you wish your user access, either a Dispute or Safe-checkout resource.
         * @summary Issue authenticated URL for single end-user
         * @param {string} id Persona identifier
         * @param {PersonaTokenWrite} personaTokenWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdtokenPost(id: string, personaTokenWrite: PersonaTokenWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaPostAuthRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdtokenPost(id, personaTokenWrite, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PersonaApi.apiPersonasIdtokenPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * You should not register your whole database of users, only those who are concerned by a Safe-checkout or Dispute operation. One Persona entry for your organization can be assigned as a seller or buyer.  **Notes:**   - (i) There is a unique constraint for the mobile phone numbers and email.   - (ii) You will have to issue a DELETE operation on a Persona that withhold a specific phone number or email.   - (iii) You are NOT REQUIRED to provide email OR a mobile phone number but it is highly recommended, if none provided the email will be generated as \'{ulid}@your-domain.tld\'. In that case, please specify at least one metadata in order to find your entry with ease.
         * @summary Register a Persona (Your customer)
         * @param {PersonaWrite} personaWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasPost(personaWrite: PersonaWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasPost(personaWrite, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PersonaApi.apiPersonasPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PersonaApi - factory interface
 * @export
 */
export const PersonaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonaApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Persona resources.
         * @summary Retrieves the collection of Persona resources.
         * @param {number} [page] The collection page number
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {Array<string>} [email2] 
         * @param {string} [mobilePhoneNumber] 
         * @param {Array<string>} [mobilePhoneNumber2] 
         * @param {ApiPersonasGetCollectionGenderEnum} [gender] Filter on a limited subset of gender
         * @param {ApiPersonasGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {string} [dateOfBirthBefore] 
         * @param {string} [dateOfBirthStrictlyBefore] 
         * @param {string} [dateOfBirthAfter] 
         * @param {string} [dateOfBirthStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasGetCollection(page?: number, firstName?: string, lastName?: string, email?: string, email2?: Array<string>, mobilePhoneNumber?: string, mobilePhoneNumber2?: Array<string>, gender?: ApiPersonasGetCollectionGenderEnum, orderCreatedAt?: ApiPersonasGetCollectionOrderCreatedAtEnum, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, dateOfBirthBefore?: string, dateOfBirthStrictlyBefore?: string, dateOfBirthAfter?: string, dateOfBirthStrictlyAfter?: string, metadata?: Array<string>, options?: any): AxiosPromise<Array<PersonaCollectionRead>> {
            return localVarFp.apiPersonasGetCollection(page, firstName, lastName, email, email2, mobilePhoneNumber, mobilePhoneNumber2, gender, orderCreatedAt, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, dateOfBirthBefore, dateOfBirthStrictlyBefore, dateOfBirthAfter, dateOfBirthStrictlyAfter, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * You **MAY** unregister (or free the email/phone number) your Persona entry using that endpoint. *Please note that* this operation will fail if that Persona have any ongoing operations.
         * @summary Unregister a Persona (Your customer)
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiPersonasIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Persona resource.
         * @summary Retrieves a Persona resource.
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdGet(id: string, options?: any): AxiosPromise<PersonaRead> {
            return localVarFp.apiPersonasIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update your Persona (eg. your customer/user entry) through that API call. _Beware that updating_ **email** and/or the **mobile phone number** must be done using non reserved values. Otherwise this operation will be rejected.
         * @summary Updates the Persona resource.
         * @param {string} id Persona identifier
         * @param {PersonaUpdate} personaUpdate The updated Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdPatch(id: string, personaUpdate: PersonaUpdate, options?: any): AxiosPromise<PersonaRead> {
            return localVarFp.apiPersonasIdPatch(id, personaUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Without this, your users may be required to pass a MFA challenge even if they are already logged-in from your website. Pass the URL you wish your user access, either a Dispute or Safe-checkout resource.
         * @summary Issue authenticated URL for single end-user
         * @param {string} id Persona identifier
         * @param {PersonaTokenWrite} personaTokenWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdtokenPost(id: string, personaTokenWrite: PersonaTokenWrite, options?: any): AxiosPromise<PersonaPostAuthRead> {
            return localVarFp.apiPersonasIdtokenPost(id, personaTokenWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * You should not register your whole database of users, only those who are concerned by a Safe-checkout or Dispute operation. One Persona entry for your organization can be assigned as a seller or buyer.  **Notes:**   - (i) There is a unique constraint for the mobile phone numbers and email.   - (ii) You will have to issue a DELETE operation on a Persona that withhold a specific phone number or email.   - (iii) You are NOT REQUIRED to provide email OR a mobile phone number but it is highly recommended, if none provided the email will be generated as \'{ulid}@your-domain.tld\'. In that case, please specify at least one metadata in order to find your entry with ease.
         * @summary Register a Persona (Your customer)
         * @param {PersonaWrite} personaWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasPost(personaWrite: PersonaWrite, options?: any): AxiosPromise<PersonaRead> {
            return localVarFp.apiPersonasPost(personaWrite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonaApi - object-oriented interface
 * @export
 * @class PersonaApi
 * @extends {BaseAPI}
 */
export class PersonaApi extends BaseAPI {
    /**
     * Retrieves the collection of Persona resources.
     * @summary Retrieves the collection of Persona resources.
     * @param {number} [page] The collection page number
     * @param {string} [firstName] 
     * @param {string} [lastName] 
     * @param {string} [email] 
     * @param {Array<string>} [email2] 
     * @param {string} [mobilePhoneNumber] 
     * @param {Array<string>} [mobilePhoneNumber2] 
     * @param {ApiPersonasGetCollectionGenderEnum} [gender] Filter on a limited subset of gender
     * @param {ApiPersonasGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
     * @param {string} [createdAtBefore] 
     * @param {string} [createdAtStrictlyBefore] 
     * @param {string} [createdAtAfter] 
     * @param {string} [createdAtStrictlyAfter] 
     * @param {string} [dateOfBirthBefore] 
     * @param {string} [dateOfBirthStrictlyBefore] 
     * @param {string} [dateOfBirthAfter] 
     * @param {string} [dateOfBirthStrictlyAfter] 
     * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasGetCollection(page?: number, firstName?: string, lastName?: string, email?: string, email2?: Array<string>, mobilePhoneNumber?: string, mobilePhoneNumber2?: Array<string>, gender?: ApiPersonasGetCollectionGenderEnum, orderCreatedAt?: ApiPersonasGetCollectionOrderCreatedAtEnum, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, dateOfBirthBefore?: string, dateOfBirthStrictlyBefore?: string, dateOfBirthAfter?: string, dateOfBirthStrictlyAfter?: string, metadata?: Array<string>, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasGetCollection(page, firstName, lastName, email, email2, mobilePhoneNumber, mobilePhoneNumber2, gender, orderCreatedAt, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, dateOfBirthBefore, dateOfBirthStrictlyBefore, dateOfBirthAfter, dateOfBirthStrictlyAfter, metadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You **MAY** unregister (or free the email/phone number) your Persona entry using that endpoint. *Please note that* this operation will fail if that Persona have any ongoing operations.
     * @summary Unregister a Persona (Your customer)
     * @param {string} id Persona identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Persona resource.
     * @summary Retrieves a Persona resource.
     * @param {string} id Persona identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasIdGet(id: string, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update your Persona (eg. your customer/user entry) through that API call. _Beware that updating_ **email** and/or the **mobile phone number** must be done using non reserved values. Otherwise this operation will be rejected.
     * @summary Updates the Persona resource.
     * @param {string} id Persona identifier
     * @param {PersonaUpdate} personaUpdate The updated Persona resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasIdPatch(id: string, personaUpdate: PersonaUpdate, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasIdPatch(id, personaUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Without this, your users may be required to pass a MFA challenge even if they are already logged-in from your website. Pass the URL you wish your user access, either a Dispute or Safe-checkout resource.
     * @summary Issue authenticated URL for single end-user
     * @param {string} id Persona identifier
     * @param {PersonaTokenWrite} personaTokenWrite The new Persona resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasIdtokenPost(id: string, personaTokenWrite: PersonaTokenWrite, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasIdtokenPost(id, personaTokenWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You should not register your whole database of users, only those who are concerned by a Safe-checkout or Dispute operation. One Persona entry for your organization can be assigned as a seller or buyer.  **Notes:**   - (i) There is a unique constraint for the mobile phone numbers and email.   - (ii) You will have to issue a DELETE operation on a Persona that withhold a specific phone number or email.   - (iii) You are NOT REQUIRED to provide email OR a mobile phone number but it is highly recommended, if none provided the email will be generated as \'{ulid}@your-domain.tld\'. In that case, please specify at least one metadata in order to find your entry with ease.
     * @summary Register a Persona (Your customer)
     * @param {PersonaWrite} personaWrite The new Persona resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasPost(personaWrite: PersonaWrite, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasPost(personaWrite, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum ApiPersonasGetCollectionGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiPersonasGetCollectionOrderCreatedAtEnum {
    Asc = 'asc',
    Desc = 'desc'
}


/**
 * ResolutionCenterApi - axios parameter creator
 * @export
 */
export const ResolutionCenterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Dispute resources.
         * @summary Retrieves the collection of Dispute resources.
         * @param {number} [page] The collection page number
         * @param {ApiDisputesGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
         * @param {ApiDisputesGetCollectionOrderStatusEnum} [orderStatus] 
         * @param {ApiDisputesGetCollectionOrderUpdatedAtEnum} [orderUpdatedAt] 
         * @param {string} [transactionOfferPublicUrl] 
         * @param {Array<string>} [transactionOfferPublicUrl2] 
         * @param {string} [transactionOfferTitle] 
         * @param {number} [transactionBuyerId] 
         * @param {Array<number>} [transactionBuyerId2] 
         * @param {string} [transactionBuyerEmail] 
         * @param {number} [transactionOfferSellerId] 
         * @param {Array<number>} [transactionOfferSellerId2] 
         * @param {string} [transactionOfferSellerEmail] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {ApiDisputesGetCollectionStatusEnum} [status] Filter on a limited subset of status
         * @param {ApiDisputesGetCollectionTransactionStatusEnum} [transactionStatus] Filter on a limited subset of transaction.status
         * @param {boolean} [existsRecommendedSolution] 
         * @param {boolean} [existsChosenSolution] 
         * @param {boolean} [existsCounterSolution] 
         * @param {boolean} [existsPlatformSolution] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [transactionMetadata] Flattened OrderedMap for transaction.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [transactionOfferMetadata] Flattened OrderedMap for transaction.offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesGetCollection: async (page?: number, orderCreatedAt?: ApiDisputesGetCollectionOrderCreatedAtEnum, orderStatus?: ApiDisputesGetCollectionOrderStatusEnum, orderUpdatedAt?: ApiDisputesGetCollectionOrderUpdatedAtEnum, transactionOfferPublicUrl?: string, transactionOfferPublicUrl2?: Array<string>, transactionOfferTitle?: string, transactionBuyerId?: number, transactionBuyerId2?: Array<number>, transactionBuyerEmail?: string, transactionOfferSellerId?: number, transactionOfferSellerId2?: Array<number>, transactionOfferSellerEmail?: string, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, status?: ApiDisputesGetCollectionStatusEnum, transactionStatus?: ApiDisputesGetCollectionTransactionStatusEnum, existsRecommendedSolution?: boolean, existsChosenSolution?: boolean, existsCounterSolution?: boolean, existsPlatformSolution?: boolean, metadata?: Array<string>, transactionMetadata?: Array<string>, transactionOfferMetadata?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/disputes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderCreatedAt !== undefined) {
                localVarQueryParameter['order[createdAt]'] = orderCreatedAt;
            }

            if (orderStatus !== undefined) {
                localVarQueryParameter['order[status]'] = orderStatus;
            }

            if (orderUpdatedAt !== undefined) {
                localVarQueryParameter['order[updatedAt]'] = orderUpdatedAt;
            }

            if (transactionOfferPublicUrl !== undefined) {
                localVarQueryParameter['transaction.offer.publicUrl'] = transactionOfferPublicUrl;
            }

            if (transactionOfferPublicUrl2) {
                localVarQueryParameter['transaction.offer.publicUrl[]'] = transactionOfferPublicUrl2;
            }

            if (transactionOfferTitle !== undefined) {
                localVarQueryParameter['transaction.offer.title'] = transactionOfferTitle;
            }

            if (transactionBuyerId !== undefined) {
                localVarQueryParameter['transaction.buyer.id'] = transactionBuyerId;
            }

            if (transactionBuyerId2) {
                localVarQueryParameter['transaction.buyer.id[]'] = transactionBuyerId2;
            }

            if (transactionBuyerEmail !== undefined) {
                localVarQueryParameter['transaction.buyer.email'] = transactionBuyerEmail;
            }

            if (transactionOfferSellerId !== undefined) {
                localVarQueryParameter['transaction.offer.seller.id'] = transactionOfferSellerId;
            }

            if (transactionOfferSellerId2) {
                localVarQueryParameter['transaction.offer.seller.id[]'] = transactionOfferSellerId2;
            }

            if (transactionOfferSellerEmail !== undefined) {
                localVarQueryParameter['transaction.offer.seller.email'] = transactionOfferSellerEmail;
            }

            if (createdAtBefore !== undefined) {
                localVarQueryParameter['createdAt[before]'] = createdAtBefore;
            }

            if (createdAtStrictlyBefore !== undefined) {
                localVarQueryParameter['createdAt[strictly_before]'] = createdAtStrictlyBefore;
            }

            if (createdAtAfter !== undefined) {
                localVarQueryParameter['createdAt[after]'] = createdAtAfter;
            }

            if (createdAtStrictlyAfter !== undefined) {
                localVarQueryParameter['createdAt[strictly_after]'] = createdAtStrictlyAfter;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (transactionStatus !== undefined) {
                localVarQueryParameter['transaction.status'] = transactionStatus;
            }

            if (existsRecommendedSolution !== undefined) {
                localVarQueryParameter['exists[recommendedSolution]'] = existsRecommendedSolution;
            }

            if (existsChosenSolution !== undefined) {
                localVarQueryParameter['exists[chosenSolution]'] = existsChosenSolution;
            }

            if (existsCounterSolution !== undefined) {
                localVarQueryParameter['exists[counterSolution]'] = existsCounterSolution;
            }

            if (existsPlatformSolution !== undefined) {
                localVarQueryParameter['exists[platformSolution]'] = existsPlatformSolution;
            }

            if (metadata) {
                localVarQueryParameter['metadata[]'] = metadata.join(COLLECTION_FORMATS.csv);
            }

            if (transactionMetadata) {
                localVarQueryParameter['transaction.metadata[]'] = transactionMetadata.join(COLLECTION_FORMATS.csv);
            }

            if (transactionOfferMetadata) {
                localVarQueryParameter['transaction.offer.metadata[]'] = transactionOfferMetadata.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a draft dispute to be filled by an alleged aggrieved customer. Do not use that endpoint if the transaction took place using our safe-checkout tunnel. This endpoint return a unique URL that can be accessed by both the complainant and seller (if individual).  **Note:** You can generate at your own discretion tokens for both parties, thus avoiding the secondary authentication.
         * @summary Draft a standalone Dispute
         * @param {DisputeIndependentWrite} disputeIndependentWrite The new Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesPost: async (disputeIndependentWrite: DisputeIndependentWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'disputeIndependentWrite' is not null or undefined
            assertParamExists('apiDisputesPost', 'disputeIndependentWrite', disputeIndependentWrite)
            const localVarPath = `/disputes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_WRITE", "PERSONA_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disputeIndependentWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Only the buyer/complainant** can dismiss the case immediately. Otherwise, the support can but in a limited ranges of Dispute status.
         * @summary Abandon claims on Dispute
         * @param {string} ulid Dispute identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidDelete: async (ulid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidDelete', 'ulid', ulid)
            const localVarPath = `/disputes/{ulid}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_WRITE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Dispute resource.
         * @summary Retrieves a Dispute resource.
         * @param {string} ulid Dispute identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidGet: async (ulid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidGet', 'ulid', ulid)
            const localVarPath = `/disputes/{ulid}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the Dispute resource.
         * @summary Update the Dispute
         * @param {string} ulid Dispute identifier
         * @param {DisputeUpdate} disputeUpdate The updated Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidPatch: async (ulid: string, disputeUpdate: DisputeUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidPatch', 'ulid', ulid)
            // verify required parameter 'disputeUpdate' is not null or undefined
            assertParamExists('apiDisputesUlidPatch', 'disputeUpdate', disputeUpdate)
            const localVarPath = `/disputes/{ulid}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_ARBITRATION"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disputeUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Only authenticated** complainant and seller **CAN** issue an evaluation **WHEN** the dispute reached a final state.
         * @summary Submit an Evaluation for the Dispute
         * @param {string} ulid Dispute identifier
         * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevaluationsPost: async (ulid: string, evaluationWrite: EvaluationWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidevaluationsPost', 'ulid', ulid)
            // verify required parameter 'evaluationWrite' is not null or undefined
            assertParamExists('apiDisputesUlidevaluationsPost', 'evaluationWrite', evaluationWrite)
            const localVarPath = `/disputes/{ulid}/evaluations`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(evaluationWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of Evidence resources.
         * @summary Retrieve all Evidences in Dispute
         * @param {string} ulid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesGetCollection: async (ulid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidevidencesGetCollection', 'ulid', ulid)
            const localVarPath = `/disputes/{ulid}/evidences`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Evidence resource.
         * @summary Withdraw an Evidence from a Dispute
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesIdDelete: async (ulid: string, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidevidencesIdDelete', 'ulid', ulid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiDisputesUlidevidencesIdDelete', 'id', id)
            const localVarPath = `/disputes/{ulid}/evidences/{id}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Media resource.
         * @summary Upload attachment in regard of described Evidence
         * @param {string} ulid 
         * @param {number} id 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesIdmediaPost: async (ulid: string, id: number, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidevidencesIdmediaPost', 'ulid', ulid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiDisputesUlidevidencesIdmediaPost', 'id', id)
            const localVarPath = `/disputes/{ulid}/evidences/{id}/media`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This action does not held the actual upload, you will have to do the upload in a dedicated request.
         * @summary Submit an Evidence to the Dispute case
         * @param {string} ulid 
         * @param {EvidenceWrite} evidenceWrite The new Evidence resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesPost: async (ulid: string, evidenceWrite: EvidenceWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidevidencesPost', 'ulid', ulid)
            // verify required parameter 'evidenceWrite' is not null or undefined
            assertParamExists('apiDisputesUlidevidencesPost', 'evidenceWrite', evidenceWrite)
            const localVarPath = `/disputes/{ulid}/evidences`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(evidenceWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of Parcel resources.
         * @summary Retrieves the collection of Parcel resources.
         * @param {string} ulid 
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidparcelsGetCollection: async (ulid: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidparcelsGetCollection', 'ulid', ulid)
            const localVarPath = `/disputes/{ulid}/parcels`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Parcel resource.
         * @summary Removes the Parcel resource.
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidparcelsIdDelete: async (ulid: string, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidparcelsIdDelete', 'ulid', ulid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiDisputesUlidparcelsIdDelete', 'id', id)
            const localVarPath = `/disputes/{ulid}/parcels/{id}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Parcel resource.
         * @summary Creates a Parcel resource.
         * @param {string} ulid 
         * @param {ParcelWrite} parcelWrite The new Parcel resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidparcelsPost: async (ulid: string, parcelWrite: ParcelWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidparcelsPost', 'ulid', ulid)
            // verify required parameter 'parcelWrite' is not null or undefined
            assertParamExists('apiDisputesUlidparcelsPost', 'parcelWrite', parcelWrite)
            const localVarPath = `/disputes/{ulid}/parcels`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(parcelWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Media resource.
         * @summary Upload a picture for a given Offer
         * @param {string} ulid 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasPost: async (ulid: string, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidmediasPost', 'ulid', ulid)
            const localVarPath = `/offers/{ulid}/medias`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResolutionCenterApi - functional programming interface
 * @export
 */
export const ResolutionCenterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResolutionCenterApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Dispute resources.
         * @summary Retrieves the collection of Dispute resources.
         * @param {number} [page] The collection page number
         * @param {ApiDisputesGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
         * @param {ApiDisputesGetCollectionOrderStatusEnum} [orderStatus] 
         * @param {ApiDisputesGetCollectionOrderUpdatedAtEnum} [orderUpdatedAt] 
         * @param {string} [transactionOfferPublicUrl] 
         * @param {Array<string>} [transactionOfferPublicUrl2] 
         * @param {string} [transactionOfferTitle] 
         * @param {number} [transactionBuyerId] 
         * @param {Array<number>} [transactionBuyerId2] 
         * @param {string} [transactionBuyerEmail] 
         * @param {number} [transactionOfferSellerId] 
         * @param {Array<number>} [transactionOfferSellerId2] 
         * @param {string} [transactionOfferSellerEmail] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {ApiDisputesGetCollectionStatusEnum} [status] Filter on a limited subset of status
         * @param {ApiDisputesGetCollectionTransactionStatusEnum} [transactionStatus] Filter on a limited subset of transaction.status
         * @param {boolean} [existsRecommendedSolution] 
         * @param {boolean} [existsChosenSolution] 
         * @param {boolean} [existsCounterSolution] 
         * @param {boolean} [existsPlatformSolution] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [transactionMetadata] Flattened OrderedMap for transaction.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [transactionOfferMetadata] Flattened OrderedMap for transaction.offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesGetCollection(page?: number, orderCreatedAt?: ApiDisputesGetCollectionOrderCreatedAtEnum, orderStatus?: ApiDisputesGetCollectionOrderStatusEnum, orderUpdatedAt?: ApiDisputesGetCollectionOrderUpdatedAtEnum, transactionOfferPublicUrl?: string, transactionOfferPublicUrl2?: Array<string>, transactionOfferTitle?: string, transactionBuyerId?: number, transactionBuyerId2?: Array<number>, transactionBuyerEmail?: string, transactionOfferSellerId?: number, transactionOfferSellerId2?: Array<number>, transactionOfferSellerEmail?: string, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, status?: ApiDisputesGetCollectionStatusEnum, transactionStatus?: ApiDisputesGetCollectionTransactionStatusEnum, existsRecommendedSolution?: boolean, existsChosenSolution?: boolean, existsCounterSolution?: boolean, existsPlatformSolution?: boolean, metadata?: Array<string>, transactionMetadata?: Array<string>, transactionOfferMetadata?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DisputeCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesGetCollection(page, orderCreatedAt, orderStatus, orderUpdatedAt, transactionOfferPublicUrl, transactionOfferPublicUrl2, transactionOfferTitle, transactionBuyerId, transactionBuyerId2, transactionBuyerEmail, transactionOfferSellerId, transactionOfferSellerId2, transactionOfferSellerEmail, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, status, transactionStatus, existsRecommendedSolution, existsChosenSolution, existsCounterSolution, existsPlatformSolution, metadata, transactionMetadata, transactionOfferMetadata, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ResolutionCenterApi.apiDisputesGetCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create a draft dispute to be filled by an alleged aggrieved customer. Do not use that endpoint if the transaction took place using our safe-checkout tunnel. This endpoint return a unique URL that can be accessed by both the complainant and seller (if individual).  **Note:** You can generate at your own discretion tokens for both parties, thus avoiding the secondary authentication.
         * @summary Draft a standalone Dispute
         * @param {DisputeIndependentWrite} disputeIndependentWrite The new Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesPost(disputeIndependentWrite: DisputeIndependentWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisputePostCreationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesPost(disputeIndependentWrite, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ResolutionCenterApi.apiDisputesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **Only the buyer/complainant** can dismiss the case immediately. Otherwise, the support can but in a limited ranges of Dispute status.
         * @summary Abandon claims on Dispute
         * @param {string} ulid Dispute identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidDelete(ulid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidDelete(ulid, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ResolutionCenterApi.apiDisputesUlidDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves a Dispute resource.
         * @summary Retrieves a Dispute resource.
         * @param {string} ulid Dispute identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidGet(ulid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisputeRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidGet(ulid, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ResolutionCenterApi.apiDisputesUlidGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates the Dispute resource.
         * @summary Update the Dispute
         * @param {string} ulid Dispute identifier
         * @param {DisputeUpdate} disputeUpdate The updated Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidPatch(ulid: string, disputeUpdate: DisputeUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisputeRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidPatch(ulid, disputeUpdate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ResolutionCenterApi.apiDisputesUlidPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **Only authenticated** complainant and seller **CAN** issue an evaluation **WHEN** the dispute reached a final state.
         * @summary Submit an Evaluation for the Dispute
         * @param {string} ulid Dispute identifier
         * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidevaluationsPost(ulid: string, evaluationWrite: EvaluationWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EvaluationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidevaluationsPost(ulid, evaluationWrite, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ResolutionCenterApi.apiDisputesUlidevaluationsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves the collection of Evidence resources.
         * @summary Retrieve all Evidences in Dispute
         * @param {string} ulid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidevidencesGetCollection(ulid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EvidenceRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidevidencesGetCollection(ulid, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ResolutionCenterApi.apiDisputesUlidevidencesGetCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Removes the Evidence resource.
         * @summary Withdraw an Evidence from a Dispute
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidevidencesIdDelete(ulid: string, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidevidencesIdDelete(ulid, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ResolutionCenterApi.apiDisputesUlidevidencesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates a Media resource.
         * @summary Upload attachment in regard of described Evidence
         * @param {string} ulid 
         * @param {number} id 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidevidencesIdmediaPost(ulid: string, id: number, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidevidencesIdmediaPost(ulid, id, file, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ResolutionCenterApi.apiDisputesUlidevidencesIdmediaPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This action does not held the actual upload, you will have to do the upload in a dedicated request.
         * @summary Submit an Evidence to the Dispute case
         * @param {string} ulid 
         * @param {EvidenceWrite} evidenceWrite The new Evidence resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidevidencesPost(ulid: string, evidenceWrite: EvidenceWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EvidenceRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidevidencesPost(ulid, evidenceWrite, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ResolutionCenterApi.apiDisputesUlidevidencesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves the collection of Parcel resources.
         * @summary Retrieves the collection of Parcel resources.
         * @param {string} ulid 
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidparcelsGetCollection(ulid: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidparcelsGetCollection(ulid, page, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ResolutionCenterApi.apiDisputesUlidparcelsGetCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Removes the Parcel resource.
         * @summary Removes the Parcel resource.
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidparcelsIdDelete(ulid: string, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidparcelsIdDelete(ulid, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ResolutionCenterApi.apiDisputesUlidparcelsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates a Parcel resource.
         * @summary Creates a Parcel resource.
         * @param {string} ulid 
         * @param {ParcelWrite} parcelWrite The new Parcel resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidparcelsPost(ulid: string, parcelWrite: ParcelWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParcelRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidparcelsPost(ulid, parcelWrite, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ResolutionCenterApi.apiDisputesUlidparcelsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates a Media resource.
         * @summary Upload a picture for a given Offer
         * @param {string} ulid 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidmediasPost(ulid: string, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidmediasPost(ulid, file, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ResolutionCenterApi.apiOffersUlidmediasPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ResolutionCenterApi - factory interface
 * @export
 */
export const ResolutionCenterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResolutionCenterApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Dispute resources.
         * @summary Retrieves the collection of Dispute resources.
         * @param {number} [page] The collection page number
         * @param {ApiDisputesGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
         * @param {ApiDisputesGetCollectionOrderStatusEnum} [orderStatus] 
         * @param {ApiDisputesGetCollectionOrderUpdatedAtEnum} [orderUpdatedAt] 
         * @param {string} [transactionOfferPublicUrl] 
         * @param {Array<string>} [transactionOfferPublicUrl2] 
         * @param {string} [transactionOfferTitle] 
         * @param {number} [transactionBuyerId] 
         * @param {Array<number>} [transactionBuyerId2] 
         * @param {string} [transactionBuyerEmail] 
         * @param {number} [transactionOfferSellerId] 
         * @param {Array<number>} [transactionOfferSellerId2] 
         * @param {string} [transactionOfferSellerEmail] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {ApiDisputesGetCollectionStatusEnum} [status] Filter on a limited subset of status
         * @param {ApiDisputesGetCollectionTransactionStatusEnum} [transactionStatus] Filter on a limited subset of transaction.status
         * @param {boolean} [existsRecommendedSolution] 
         * @param {boolean} [existsChosenSolution] 
         * @param {boolean} [existsCounterSolution] 
         * @param {boolean} [existsPlatformSolution] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [transactionMetadata] Flattened OrderedMap for transaction.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [transactionOfferMetadata] Flattened OrderedMap for transaction.offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesGetCollection(page?: number, orderCreatedAt?: ApiDisputesGetCollectionOrderCreatedAtEnum, orderStatus?: ApiDisputesGetCollectionOrderStatusEnum, orderUpdatedAt?: ApiDisputesGetCollectionOrderUpdatedAtEnum, transactionOfferPublicUrl?: string, transactionOfferPublicUrl2?: Array<string>, transactionOfferTitle?: string, transactionBuyerId?: number, transactionBuyerId2?: Array<number>, transactionBuyerEmail?: string, transactionOfferSellerId?: number, transactionOfferSellerId2?: Array<number>, transactionOfferSellerEmail?: string, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, status?: ApiDisputesGetCollectionStatusEnum, transactionStatus?: ApiDisputesGetCollectionTransactionStatusEnum, existsRecommendedSolution?: boolean, existsChosenSolution?: boolean, existsCounterSolution?: boolean, existsPlatformSolution?: boolean, metadata?: Array<string>, transactionMetadata?: Array<string>, transactionOfferMetadata?: Array<string>, options?: any): AxiosPromise<Array<DisputeCollectionRead>> {
            return localVarFp.apiDisputesGetCollection(page, orderCreatedAt, orderStatus, orderUpdatedAt, transactionOfferPublicUrl, transactionOfferPublicUrl2, transactionOfferTitle, transactionBuyerId, transactionBuyerId2, transactionBuyerEmail, transactionOfferSellerId, transactionOfferSellerId2, transactionOfferSellerEmail, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, status, transactionStatus, existsRecommendedSolution, existsChosenSolution, existsCounterSolution, existsPlatformSolution, metadata, transactionMetadata, transactionOfferMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a draft dispute to be filled by an alleged aggrieved customer. Do not use that endpoint if the transaction took place using our safe-checkout tunnel. This endpoint return a unique URL that can be accessed by both the complainant and seller (if individual).  **Note:** You can generate at your own discretion tokens for both parties, thus avoiding the secondary authentication.
         * @summary Draft a standalone Dispute
         * @param {DisputeIndependentWrite} disputeIndependentWrite The new Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesPost(disputeIndependentWrite: DisputeIndependentWrite, options?: any): AxiosPromise<DisputePostCreationRead> {
            return localVarFp.apiDisputesPost(disputeIndependentWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * **Only the buyer/complainant** can dismiss the case immediately. Otherwise, the support can but in a limited ranges of Dispute status.
         * @summary Abandon claims on Dispute
         * @param {string} ulid Dispute identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidDelete(ulid: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiDisputesUlidDelete(ulid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Dispute resource.
         * @summary Retrieves a Dispute resource.
         * @param {string} ulid Dispute identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidGet(ulid: string, options?: any): AxiosPromise<DisputeRead> {
            return localVarFp.apiDisputesUlidGet(ulid, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the Dispute resource.
         * @summary Update the Dispute
         * @param {string} ulid Dispute identifier
         * @param {DisputeUpdate} disputeUpdate The updated Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidPatch(ulid: string, disputeUpdate: DisputeUpdate, options?: any): AxiosPromise<DisputeRead> {
            return localVarFp.apiDisputesUlidPatch(ulid, disputeUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * **Only authenticated** complainant and seller **CAN** issue an evaluation **WHEN** the dispute reached a final state.
         * @summary Submit an Evaluation for the Dispute
         * @param {string} ulid Dispute identifier
         * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevaluationsPost(ulid: string, evaluationWrite: EvaluationWrite, options?: any): AxiosPromise<EvaluationRead> {
            return localVarFp.apiDisputesUlidevaluationsPost(ulid, evaluationWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of Evidence resources.
         * @summary Retrieve all Evidences in Dispute
         * @param {string} ulid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesGetCollection(ulid: string, options?: any): AxiosPromise<Array<EvidenceRead>> {
            return localVarFp.apiDisputesUlidevidencesGetCollection(ulid, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Evidence resource.
         * @summary Withdraw an Evidence from a Dispute
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesIdDelete(ulid: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiDisputesUlidevidencesIdDelete(ulid, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Media resource.
         * @summary Upload attachment in regard of described Evidence
         * @param {string} ulid 
         * @param {number} id 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesIdmediaPost(ulid: string, id: number, file?: File, options?: any): AxiosPromise<MediaRead> {
            return localVarFp.apiDisputesUlidevidencesIdmediaPost(ulid, id, file, options).then((request) => request(axios, basePath));
        },
        /**
         * This action does not held the actual upload, you will have to do the upload in a dedicated request.
         * @summary Submit an Evidence to the Dispute case
         * @param {string} ulid 
         * @param {EvidenceWrite} evidenceWrite The new Evidence resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesPost(ulid: string, evidenceWrite: EvidenceWrite, options?: any): AxiosPromise<EvidenceRead> {
            return localVarFp.apiDisputesUlidevidencesPost(ulid, evidenceWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of Parcel resources.
         * @summary Retrieves the collection of Parcel resources.
         * @param {string} ulid 
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidparcelsGetCollection(ulid: string, page?: number, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.apiDisputesUlidparcelsGetCollection(ulid, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Parcel resource.
         * @summary Removes the Parcel resource.
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidparcelsIdDelete(ulid: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiDisputesUlidparcelsIdDelete(ulid, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Parcel resource.
         * @summary Creates a Parcel resource.
         * @param {string} ulid 
         * @param {ParcelWrite} parcelWrite The new Parcel resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidparcelsPost(ulid: string, parcelWrite: ParcelWrite, options?: any): AxiosPromise<ParcelRead> {
            return localVarFp.apiDisputesUlidparcelsPost(ulid, parcelWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Media resource.
         * @summary Upload a picture for a given Offer
         * @param {string} ulid 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasPost(ulid: string, file?: File, options?: any): AxiosPromise<MediaRead> {
            return localVarFp.apiOffersUlidmediasPost(ulid, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResolutionCenterApi - object-oriented interface
 * @export
 * @class ResolutionCenterApi
 * @extends {BaseAPI}
 */
export class ResolutionCenterApi extends BaseAPI {
    /**
     * Retrieves the collection of Dispute resources.
     * @summary Retrieves the collection of Dispute resources.
     * @param {number} [page] The collection page number
     * @param {ApiDisputesGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
     * @param {ApiDisputesGetCollectionOrderStatusEnum} [orderStatus] 
     * @param {ApiDisputesGetCollectionOrderUpdatedAtEnum} [orderUpdatedAt] 
     * @param {string} [transactionOfferPublicUrl] 
     * @param {Array<string>} [transactionOfferPublicUrl2] 
     * @param {string} [transactionOfferTitle] 
     * @param {number} [transactionBuyerId] 
     * @param {Array<number>} [transactionBuyerId2] 
     * @param {string} [transactionBuyerEmail] 
     * @param {number} [transactionOfferSellerId] 
     * @param {Array<number>} [transactionOfferSellerId2] 
     * @param {string} [transactionOfferSellerEmail] 
     * @param {string} [createdAtBefore] 
     * @param {string} [createdAtStrictlyBefore] 
     * @param {string} [createdAtAfter] 
     * @param {string} [createdAtStrictlyAfter] 
     * @param {ApiDisputesGetCollectionStatusEnum} [status] Filter on a limited subset of status
     * @param {ApiDisputesGetCollectionTransactionStatusEnum} [transactionStatus] Filter on a limited subset of transaction.status
     * @param {boolean} [existsRecommendedSolution] 
     * @param {boolean} [existsChosenSolution] 
     * @param {boolean} [existsCounterSolution] 
     * @param {boolean} [existsPlatformSolution] 
     * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {Array<string>} [transactionMetadata] Flattened OrderedMap for transaction.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {Array<string>} [transactionOfferMetadata] Flattened OrderedMap for transaction.offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesGetCollection(page?: number, orderCreatedAt?: ApiDisputesGetCollectionOrderCreatedAtEnum, orderStatus?: ApiDisputesGetCollectionOrderStatusEnum, orderUpdatedAt?: ApiDisputesGetCollectionOrderUpdatedAtEnum, transactionOfferPublicUrl?: string, transactionOfferPublicUrl2?: Array<string>, transactionOfferTitle?: string, transactionBuyerId?: number, transactionBuyerId2?: Array<number>, transactionBuyerEmail?: string, transactionOfferSellerId?: number, transactionOfferSellerId2?: Array<number>, transactionOfferSellerEmail?: string, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, status?: ApiDisputesGetCollectionStatusEnum, transactionStatus?: ApiDisputesGetCollectionTransactionStatusEnum, existsRecommendedSolution?: boolean, existsChosenSolution?: boolean, existsCounterSolution?: boolean, existsPlatformSolution?: boolean, metadata?: Array<string>, transactionMetadata?: Array<string>, transactionOfferMetadata?: Array<string>, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesGetCollection(page, orderCreatedAt, orderStatus, orderUpdatedAt, transactionOfferPublicUrl, transactionOfferPublicUrl2, transactionOfferTitle, transactionBuyerId, transactionBuyerId2, transactionBuyerEmail, transactionOfferSellerId, transactionOfferSellerId2, transactionOfferSellerEmail, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, status, transactionStatus, existsRecommendedSolution, existsChosenSolution, existsCounterSolution, existsPlatformSolution, metadata, transactionMetadata, transactionOfferMetadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a draft dispute to be filled by an alleged aggrieved customer. Do not use that endpoint if the transaction took place using our safe-checkout tunnel. This endpoint return a unique URL that can be accessed by both the complainant and seller (if individual).  **Note:** You can generate at your own discretion tokens for both parties, thus avoiding the secondary authentication.
     * @summary Draft a standalone Dispute
     * @param {DisputeIndependentWrite} disputeIndependentWrite The new Dispute resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesPost(disputeIndependentWrite: DisputeIndependentWrite, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesPost(disputeIndependentWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Only the buyer/complainant** can dismiss the case immediately. Otherwise, the support can but in a limited ranges of Dispute status.
     * @summary Abandon claims on Dispute
     * @param {string} ulid Dispute identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidDelete(ulid: string, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidDelete(ulid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Dispute resource.
     * @summary Retrieves a Dispute resource.
     * @param {string} ulid Dispute identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidGet(ulid: string, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidGet(ulid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the Dispute resource.
     * @summary Update the Dispute
     * @param {string} ulid Dispute identifier
     * @param {DisputeUpdate} disputeUpdate The updated Dispute resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidPatch(ulid: string, disputeUpdate: DisputeUpdate, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidPatch(ulid, disputeUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Only authenticated** complainant and seller **CAN** issue an evaluation **WHEN** the dispute reached a final state.
     * @summary Submit an Evaluation for the Dispute
     * @param {string} ulid Dispute identifier
     * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidevaluationsPost(ulid: string, evaluationWrite: EvaluationWrite, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidevaluationsPost(ulid, evaluationWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of Evidence resources.
     * @summary Retrieve all Evidences in Dispute
     * @param {string} ulid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidevidencesGetCollection(ulid: string, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidevidencesGetCollection(ulid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Evidence resource.
     * @summary Withdraw an Evidence from a Dispute
     * @param {string} ulid 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidevidencesIdDelete(ulid: string, id: number, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidevidencesIdDelete(ulid, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Media resource.
     * @summary Upload attachment in regard of described Evidence
     * @param {string} ulid 
     * @param {number} id 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidevidencesIdmediaPost(ulid: string, id: number, file?: File, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidevidencesIdmediaPost(ulid, id, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This action does not held the actual upload, you will have to do the upload in a dedicated request.
     * @summary Submit an Evidence to the Dispute case
     * @param {string} ulid 
     * @param {EvidenceWrite} evidenceWrite The new Evidence resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidevidencesPost(ulid: string, evidenceWrite: EvidenceWrite, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidevidencesPost(ulid, evidenceWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of Parcel resources.
     * @summary Retrieves the collection of Parcel resources.
     * @param {string} ulid 
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidparcelsGetCollection(ulid: string, page?: number, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidparcelsGetCollection(ulid, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Parcel resource.
     * @summary Removes the Parcel resource.
     * @param {string} ulid 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidparcelsIdDelete(ulid: string, id: number, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidparcelsIdDelete(ulid, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Parcel resource.
     * @summary Creates a Parcel resource.
     * @param {string} ulid 
     * @param {ParcelWrite} parcelWrite The new Parcel resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidparcelsPost(ulid: string, parcelWrite: ParcelWrite, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidparcelsPost(ulid, parcelWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Media resource.
     * @summary Upload a picture for a given Offer
     * @param {string} ulid 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiOffersUlidmediasPost(ulid: string, file?: File, options?: RawAxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiOffersUlidmediasPost(ulid, file, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum ApiDisputesGetCollectionOrderCreatedAtEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiDisputesGetCollectionOrderStatusEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiDisputesGetCollectionOrderUpdatedAtEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiDisputesGetCollectionStatusEnum {
    Created = 'CREATED',
    Submitted = 'SUBMITTED',
    Opened = 'OPENED',
    Abandoned = 'ABANDONED',
    Objected = 'OBJECTED',
    PendingShipment = 'PENDING_SHIPMENT',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Returned = 'RETURNED',
    Dismissed = 'DISMISSED',
    Resolved = 'RESOLVED',
    Pending = 'PENDING'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiDisputesGetCollectionTransactionStatusEnum {
    Created = 'CREATED',
    Authorized = 'AUTHORIZED',
    Refused = 'REFUSED',
    Accepted = 'ACCEPTED',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Delivered = 'DELIVERED',
    Completed = 'COMPLETED',
    Disputed = 'DISPUTED'
}


/**
 * SafeCheckoutApi - axios parameter creator
 * @export
 */
export const SafeCheckoutApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Offer resources.
         * @summary Read issued Offers
         * @param {number} [page] The collection page number
         * @param {string} [title] 
         * @param {string} [publicUrl] 
         * @param {Array<string>} [publicUrl2] 
         * @param {number} [unitPrice] 
         * @param {Array<number>} [unitPrice2] 
         * @param {number} [itemCount] 
         * @param {Array<number>} [itemCount2] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {ApiOffersGetCollectionNatureEnum} [nature] Filter on a limited subset of nature
         * @param {ApiOffersGetCollectionConditionEnum} [condition] Filter on a limited subset of condition
         * @param {boolean} [shippingAllowed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersGetCollection: async (page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: number, unitPrice2?: Array<number>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, nature?: ApiOffersGetCollectionNatureEnum, condition?: ApiOffersGetCollectionConditionEnum, shippingAllowed?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/offers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (publicUrl !== undefined) {
                localVarQueryParameter['publicUrl'] = publicUrl;
            }

            if (publicUrl2) {
                localVarQueryParameter['publicUrl[]'] = publicUrl2;
            }

            if (unitPrice !== undefined) {
                localVarQueryParameter['unitPrice'] = unitPrice;
            }

            if (unitPrice2) {
                localVarQueryParameter['unitPrice[]'] = unitPrice2;
            }

            if (itemCount !== undefined) {
                localVarQueryParameter['itemCount'] = itemCount;
            }

            if (itemCount2) {
                localVarQueryParameter['itemCount[]'] = itemCount2;
            }

            if (createdAtBefore !== undefined) {
                localVarQueryParameter['createdAt[before]'] = createdAtBefore;
            }

            if (createdAtStrictlyBefore !== undefined) {
                localVarQueryParameter['createdAt[strictly_before]'] = createdAtStrictlyBefore;
            }

            if (createdAtAfter !== undefined) {
                localVarQueryParameter['createdAt[after]'] = createdAtAfter;
            }

            if (createdAtStrictlyAfter !== undefined) {
                localVarQueryParameter['createdAt[strictly_after]'] = createdAtStrictlyAfter;
            }

            if (metadata) {
                localVarQueryParameter['metadata[]'] = metadata.join(COLLECTION_FORMATS.csv);
            }

            if (offerMetadata) {
                localVarQueryParameter['offer.metadata[]'] = offerMetadata.join(COLLECTION_FORMATS.csv);
            }

            if (nature !== undefined) {
                localVarQueryParameter['nature'] = nature;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }

            if (shippingAllowed !== undefined) {
                localVarQueryParameter['shippingAllowed'] = shippingAllowed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publish an offer so that you can safely retrieve a safe-checkout unique link from us
         * @summary Create an Offer and retrieve url
         * @param {OfferIndependentWrite} offerIndependentWrite The new Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersPost: async (offerIndependentWrite: OfferIndependentWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'offerIndependentWrite' is not null or undefined
            assertParamExists('apiOffersPost', 'offerIndependentWrite', offerIndependentWrite)
            const localVarPath = `/offers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(offerIndependentWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Offer resource.
         * @summary Read an Offer
         * @param {string} ulid Offer identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidGet: async (ulid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidGet', 'ulid', ulid)
            const localVarPath = `/offers/{ulid}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Media resource.
         * @summary Removes the Media resource.
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasIdDelete: async (ulid: string, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidmediasIdDelete', 'ulid', ulid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOffersUlidmediasIdDelete', 'id', id)
            const localVarPath = `/offers/{ulid}/medias/{id}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Media resource.
         * @summary Upload a picture for a given Offer
         * @param {string} ulid 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasPost: async (ulid: string, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidmediasPost', 'ulid', ulid)
            const localVarPath = `/offers/{ulid}/medias`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of Transaction resources.
         * @summary Retrieve Payment Intents for Offer
         * @param {string} ulid Offer identifier
         * @param {number} [page] The collection page number
         * @param {ApiOffersUlidtransactionsGetCollectionOrderStatusEnum} [orderStatus] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {ApiOffersUlidtransactionsGetCollectionStatusEnum} [status] Filter on a limited subset of status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidtransactionsGetCollection: async (ulid: string, page?: number, orderStatus?: ApiOffersUlidtransactionsGetCollectionOrderStatusEnum, metadata?: Array<string>, status?: ApiOffersUlidtransactionsGetCollectionStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidtransactionsGetCollection', 'ulid', ulid)
            const localVarPath = `/offers/{ulid}/transactions`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderStatus !== undefined) {
                localVarQueryParameter['order[status]'] = orderStatus;
            }

            if (metadata) {
                localVarQueryParameter['metadata[]'] = metadata.join(COLLECTION_FORMATS.csv);
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Only authenticated** buyer and seller **CAN** issue an evaluation **WHEN** the transaction reached a final state.
         * @summary Submit an Evaluation for the Offer
         * @param {string} ulid Dispute identifier
         * @param {string} id Transaction identifier
         * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidtransactionsIdevaluationsPost: async (ulid: string, id: string, evaluationWrite: EvaluationWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidtransactionsIdevaluationsPost', 'ulid', ulid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOffersUlidtransactionsIdevaluationsPost', 'id', id)
            // verify required parameter 'evaluationWrite' is not null or undefined
            assertParamExists('apiOffersUlidtransactionsIdevaluationsPost', 'evaluationWrite', evaluationWrite)
            const localVarPath = `/offers/{ulid}/transactions/{id}/evaluations`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(evaluationWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cannot be used outside of a Persona (buyer)
         * @summary Create a Payment Intent for Offer
         * @param {string} ulid Offer identifier
         * @param {object} body The new Transaction resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidtransactionsPost: async (ulid: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidtransactionsPost', 'ulid', ulid)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('apiOffersUlidtransactionsPost', 'body', body)
            const localVarPath = `/offers/{ulid}/transactions`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * That goes without says, if that **Offer** have a _Transaction_ **that is ongoing**, you **MAY NOT** revoke the **Offer**.
         * @summary Revoke an Offer for given Persona
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdoffersDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdoffersDelete', 'id', id)
            const localVarPath = `/personas/{id}/offers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of Offer resources.
         * @summary List or Search Offers for given Persona
         * @param {string} id Persona identifier
         * @param {number} [page] The collection page number
         * @param {string} [title] 
         * @param {string} [publicUrl] 
         * @param {Array<string>} [publicUrl2] 
         * @param {number} [unitPrice] 
         * @param {Array<number>} [unitPrice2] 
         * @param {number} [itemCount] 
         * @param {Array<number>} [itemCount2] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {ApiPersonasIdoffersGetCollectionNatureEnum} [nature] Filter on a limited subset of nature
         * @param {ApiPersonasIdoffersGetCollectionConditionEnum} [condition] Filter on a limited subset of condition
         * @param {boolean} [shippingAllowed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdoffersGetCollection: async (id: string, page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: number, unitPrice2?: Array<number>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, nature?: ApiPersonasIdoffersGetCollectionNatureEnum, condition?: ApiPersonasIdoffersGetCollectionConditionEnum, shippingAllowed?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdoffersGetCollection', 'id', id)
            const localVarPath = `/personas/{id}/offers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (publicUrl !== undefined) {
                localVarQueryParameter['publicUrl'] = publicUrl;
            }

            if (publicUrl2) {
                localVarQueryParameter['publicUrl[]'] = publicUrl2;
            }

            if (unitPrice !== undefined) {
                localVarQueryParameter['unitPrice'] = unitPrice;
            }

            if (unitPrice2) {
                localVarQueryParameter['unitPrice[]'] = unitPrice2;
            }

            if (itemCount !== undefined) {
                localVarQueryParameter['itemCount'] = itemCount;
            }

            if (itemCount2) {
                localVarQueryParameter['itemCount[]'] = itemCount2;
            }

            if (createdAtBefore !== undefined) {
                localVarQueryParameter['createdAt[before]'] = createdAtBefore;
            }

            if (createdAtStrictlyBefore !== undefined) {
                localVarQueryParameter['createdAt[strictly_before]'] = createdAtStrictlyBefore;
            }

            if (createdAtAfter !== undefined) {
                localVarQueryParameter['createdAt[after]'] = createdAtAfter;
            }

            if (createdAtStrictlyAfter !== undefined) {
                localVarQueryParameter['createdAt[strictly_after]'] = createdAtStrictlyAfter;
            }

            if (metadata) {
                localVarQueryParameter['metadata[]'] = metadata.join(COLLECTION_FORMATS.csv);
            }

            if (offerMetadata) {
                localVarQueryParameter['offer.metadata[]'] = offerMetadata.join(COLLECTION_FORMATS.csv);
            }

            if (nature !== undefined) {
                localVarQueryParameter['nature'] = nature;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }

            if (shippingAllowed !== undefined) {
                localVarQueryParameter['shippingAllowed'] = shippingAllowed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the Offer resource.
         * @summary Update an Offer for given Persona
         * @param {string} id Persona identifier
         * @param {OfferUpdate} offerUpdate The updated Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdoffersPatch: async (id: string, offerUpdate: OfferUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdoffersPatch', 'id', id)
            // verify required parameter 'offerUpdate' is not null or undefined
            assertParamExists('apiPersonasIdoffersPatch', 'offerUpdate', offerUpdate)
            const localVarPath = `/personas/{id}/offers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(offerUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Offer resource.
         * @summary Create an Offer for given Persona
         * @param {string} id Persona identifier
         * @param {OfferWrite} offerWrite The new Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdoffersPost: async (id: string, offerWrite: OfferWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdoffersPost', 'id', id)
            // verify required parameter 'offerWrite' is not null or undefined
            assertParamExists('apiPersonasIdoffersPost', 'offerWrite', offerWrite)
            const localVarPath = `/personas/{id}/offers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(offerWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of Transaction resources.
         * @summary Retrieves the collection of Transaction resources.
         * @param {number} [page] The collection page number
         * @param {ApiTransactionsGetCollectionOrderStatusEnum} [orderStatus] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {ApiTransactionsGetCollectionStatusEnum} [status] Filter on a limited subset of status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsGetCollection: async (page?: number, orderStatus?: ApiTransactionsGetCollectionOrderStatusEnum, metadata?: Array<string>, status?: ApiTransactionsGetCollectionStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderStatus !== undefined) {
                localVarQueryParameter['order[status]'] = orderStatus;
            }

            if (metadata) {
                localVarQueryParameter['metadata[]'] = metadata.join(COLLECTION_FORMATS.csv);
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Only the buyer/complainant** can dismiss the case immediately. Otherwise, the support can but in a limited ranges of Dispute status.
         * @summary Abandon claims on Dispute
         * @param {string} ulid Transaction identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUliddisputeDelete: async (ulid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiTransactionsUliddisputeDelete', 'ulid', ulid)
            const localVarPath = `/transactions/{ulid}/dispute`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_ARBITRATION"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Dispute resource.
         * @summary Read Dispute from existing Transaction
         * @param {string} ulid Transaction identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUliddisputeGet: async (ulid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiTransactionsUliddisputeGet', 'ulid', ulid)
            const localVarPath = `/transactions/{ulid}/dispute`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only authenticated Persona can interact with a Dispute object. Usually through our web application.
         * @summary Interact with a Dispute
         * @param {string} ulid Transaction identifier
         * @param {DisputeUpdate} disputeUpdate The updated Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUliddisputePatch: async (ulid: string, disputeUpdate: DisputeUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiTransactionsUliddisputePatch', 'ulid', ulid)
            // verify required parameter 'disputeUpdate' is not null or undefined
            assertParamExists('apiTransactionsUliddisputePatch', 'disputeUpdate', disputeUpdate)
            const localVarPath = `/transactions/{ulid}/dispute`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disputeUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Dispute resource.
         * @summary Open a Dispute related to existing Transaction
         * @param {string} ulid Transaction identifier
         * @param {DisputeWrite} disputeWrite The new Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUliddisputePost: async (ulid: string, disputeWrite: DisputeWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiTransactionsUliddisputePost', 'ulid', ulid)
            // verify required parameter 'disputeWrite' is not null or undefined
            assertParamExists('apiTransactionsUliddisputePost', 'disputeWrite', disputeWrite)
            const localVarPath = `/transactions/{ulid}/dispute`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disputeWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of Parcel resources.
         * @summary Read shipments from Transaction
         * @param {string} ulid 
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidparcelsGetCollection: async (ulid: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiTransactionsUlidparcelsGetCollection', 'ulid', ulid)
            const localVarPath = `/transactions/{ulid}/parcels`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * No one except the support can do that manoeuvre.
         * @summary Withdraw shipment from Transaction
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidparcelsIdDelete: async (ulid: string, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiTransactionsUlidparcelsIdDelete', 'ulid', ulid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiTransactionsUlidparcelsIdDelete', 'id', id)
            const localVarPath = `/transactions/{ulid}/parcels/{id}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Parcel resource.
         * @summary Manually declare package shipped for Transaction
         * @param {string} ulid 
         * @param {ParcelWrite} parcelWrite The new Parcel resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidparcelsPost: async (ulid: string, parcelWrite: ParcelWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiTransactionsUlidparcelsPost', 'ulid', ulid)
            // verify required parameter 'parcelWrite' is not null or undefined
            assertParamExists('apiTransactionsUlidparcelsPost', 'parcelWrite', parcelWrite)
            const localVarPath = `/transactions/{ulid}/parcels`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(parcelWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SafeCheckoutApi - functional programming interface
 * @export
 */
export const SafeCheckoutApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SafeCheckoutApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Offer resources.
         * @summary Read issued Offers
         * @param {number} [page] The collection page number
         * @param {string} [title] 
         * @param {string} [publicUrl] 
         * @param {Array<string>} [publicUrl2] 
         * @param {number} [unitPrice] 
         * @param {Array<number>} [unitPrice2] 
         * @param {number} [itemCount] 
         * @param {Array<number>} [itemCount2] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {ApiOffersGetCollectionNatureEnum} [nature] Filter on a limited subset of nature
         * @param {ApiOffersGetCollectionConditionEnum} [condition] Filter on a limited subset of condition
         * @param {boolean} [shippingAllowed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersGetCollection(page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: number, unitPrice2?: Array<number>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, nature?: ApiOffersGetCollectionNatureEnum, condition?: ApiOffersGetCollectionConditionEnum, shippingAllowed?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OfferCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersGetCollection(page, title, publicUrl, publicUrl2, unitPrice, unitPrice2, itemCount, itemCount2, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, metadata, offerMetadata, nature, condition, shippingAllowed, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SafeCheckoutApi.apiOffersGetCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Publish an offer so that you can safely retrieve a safe-checkout unique link from us
         * @summary Create an Offer and retrieve url
         * @param {OfferIndependentWrite} offerIndependentWrite The new Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersPost(offerIndependentWrite: OfferIndependentWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferPostCreationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersPost(offerIndependentWrite, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SafeCheckoutApi.apiOffersPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves a Offer resource.
         * @summary Read an Offer
         * @param {string} ulid Offer identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidGet(ulid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidGet(ulid, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SafeCheckoutApi.apiOffersUlidGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Removes the Media resource.
         * @summary Removes the Media resource.
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidmediasIdDelete(ulid: string, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidmediasIdDelete(ulid, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SafeCheckoutApi.apiOffersUlidmediasIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates a Media resource.
         * @summary Upload a picture for a given Offer
         * @param {string} ulid 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidmediasPost(ulid: string, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidmediasPost(ulid, file, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SafeCheckoutApi.apiOffersUlidmediasPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves the collection of Transaction resources.
         * @summary Retrieve Payment Intents for Offer
         * @param {string} ulid Offer identifier
         * @param {number} [page] The collection page number
         * @param {ApiOffersUlidtransactionsGetCollectionOrderStatusEnum} [orderStatus] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {ApiOffersUlidtransactionsGetCollectionStatusEnum} [status] Filter on a limited subset of status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidtransactionsGetCollection(ulid: string, page?: number, orderStatus?: ApiOffersUlidtransactionsGetCollectionOrderStatusEnum, metadata?: Array<string>, status?: ApiOffersUlidtransactionsGetCollectionStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidtransactionsGetCollection(ulid, page, orderStatus, metadata, status, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SafeCheckoutApi.apiOffersUlidtransactionsGetCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **Only authenticated** buyer and seller **CAN** issue an evaluation **WHEN** the transaction reached a final state.
         * @summary Submit an Evaluation for the Offer
         * @param {string} ulid Dispute identifier
         * @param {string} id Transaction identifier
         * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidtransactionsIdevaluationsPost(ulid: string, id: string, evaluationWrite: EvaluationWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EvaluationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidtransactionsIdevaluationsPost(ulid, id, evaluationWrite, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SafeCheckoutApi.apiOffersUlidtransactionsIdevaluationsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Cannot be used outside of a Persona (buyer)
         * @summary Create a Payment Intent for Offer
         * @param {string} ulid Offer identifier
         * @param {object} body The new Transaction resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidtransactionsPost(ulid: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidtransactionsPost(ulid, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SafeCheckoutApi.apiOffersUlidtransactionsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * That goes without says, if that **Offer** have a _Transaction_ **that is ongoing**, you **MAY NOT** revoke the **Offer**.
         * @summary Revoke an Offer for given Persona
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdoffersDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdoffersDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SafeCheckoutApi.apiPersonasIdoffersDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves the collection of Offer resources.
         * @summary List or Search Offers for given Persona
         * @param {string} id Persona identifier
         * @param {number} [page] The collection page number
         * @param {string} [title] 
         * @param {string} [publicUrl] 
         * @param {Array<string>} [publicUrl2] 
         * @param {number} [unitPrice] 
         * @param {Array<number>} [unitPrice2] 
         * @param {number} [itemCount] 
         * @param {Array<number>} [itemCount2] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {ApiPersonasIdoffersGetCollectionNatureEnum} [nature] Filter on a limited subset of nature
         * @param {ApiPersonasIdoffersGetCollectionConditionEnum} [condition] Filter on a limited subset of condition
         * @param {boolean} [shippingAllowed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdoffersGetCollection(id: string, page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: number, unitPrice2?: Array<number>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, nature?: ApiPersonasIdoffersGetCollectionNatureEnum, condition?: ApiPersonasIdoffersGetCollectionConditionEnum, shippingAllowed?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OfferCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdoffersGetCollection(id, page, title, publicUrl, publicUrl2, unitPrice, unitPrice2, itemCount, itemCount2, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, metadata, offerMetadata, nature, condition, shippingAllowed, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SafeCheckoutApi.apiPersonasIdoffersGetCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates the Offer resource.
         * @summary Update an Offer for given Persona
         * @param {string} id Persona identifier
         * @param {OfferUpdate} offerUpdate The updated Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdoffersPatch(id: string, offerUpdate: OfferUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdoffersPatch(id, offerUpdate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SafeCheckoutApi.apiPersonasIdoffersPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates a Offer resource.
         * @summary Create an Offer for given Persona
         * @param {string} id Persona identifier
         * @param {OfferWrite} offerWrite The new Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdoffersPost(id: string, offerWrite: OfferWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferPostCreationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdoffersPost(id, offerWrite, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SafeCheckoutApi.apiPersonasIdoffersPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves the collection of Transaction resources.
         * @summary Retrieves the collection of Transaction resources.
         * @param {number} [page] The collection page number
         * @param {ApiTransactionsGetCollectionOrderStatusEnum} [orderStatus] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {ApiTransactionsGetCollectionStatusEnum} [status] Filter on a limited subset of status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsGetCollection(page?: number, orderStatus?: ApiTransactionsGetCollectionOrderStatusEnum, metadata?: Array<string>, status?: ApiTransactionsGetCollectionStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsGetCollection(page, orderStatus, metadata, status, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SafeCheckoutApi.apiTransactionsGetCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * **Only the buyer/complainant** can dismiss the case immediately. Otherwise, the support can but in a limited ranges of Dispute status.
         * @summary Abandon claims on Dispute
         * @param {string} ulid Transaction identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsUliddisputeDelete(ulid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsUliddisputeDelete(ulid, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SafeCheckoutApi.apiTransactionsUliddisputeDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves a Dispute resource.
         * @summary Read Dispute from existing Transaction
         * @param {string} ulid Transaction identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsUliddisputeGet(ulid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisputeRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsUliddisputeGet(ulid, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SafeCheckoutApi.apiTransactionsUliddisputeGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Only authenticated Persona can interact with a Dispute object. Usually through our web application.
         * @summary Interact with a Dispute
         * @param {string} ulid Transaction identifier
         * @param {DisputeUpdate} disputeUpdate The updated Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsUliddisputePatch(ulid: string, disputeUpdate: DisputeUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisputeRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsUliddisputePatch(ulid, disputeUpdate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SafeCheckoutApi.apiTransactionsUliddisputePatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates a Dispute resource.
         * @summary Open a Dispute related to existing Transaction
         * @param {string} ulid Transaction identifier
         * @param {DisputeWrite} disputeWrite The new Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsUliddisputePost(ulid: string, disputeWrite: DisputeWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisputePostCreationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsUliddisputePost(ulid, disputeWrite, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SafeCheckoutApi.apiTransactionsUliddisputePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves the collection of Parcel resources.
         * @summary Read shipments from Transaction
         * @param {string} ulid 
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsUlidparcelsGetCollection(ulid: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsUlidparcelsGetCollection(ulid, page, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SafeCheckoutApi.apiTransactionsUlidparcelsGetCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * No one except the support can do that manoeuvre.
         * @summary Withdraw shipment from Transaction
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsUlidparcelsIdDelete(ulid: string, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsUlidparcelsIdDelete(ulid, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SafeCheckoutApi.apiTransactionsUlidparcelsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates a Parcel resource.
         * @summary Manually declare package shipped for Transaction
         * @param {string} ulid 
         * @param {ParcelWrite} parcelWrite The new Parcel resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsUlidparcelsPost(ulid: string, parcelWrite: ParcelWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParcelRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsUlidparcelsPost(ulid, parcelWrite, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SafeCheckoutApi.apiTransactionsUlidparcelsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SafeCheckoutApi - factory interface
 * @export
 */
export const SafeCheckoutApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SafeCheckoutApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Offer resources.
         * @summary Read issued Offers
         * @param {number} [page] The collection page number
         * @param {string} [title] 
         * @param {string} [publicUrl] 
         * @param {Array<string>} [publicUrl2] 
         * @param {number} [unitPrice] 
         * @param {Array<number>} [unitPrice2] 
         * @param {number} [itemCount] 
         * @param {Array<number>} [itemCount2] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {ApiOffersGetCollectionNatureEnum} [nature] Filter on a limited subset of nature
         * @param {ApiOffersGetCollectionConditionEnum} [condition] Filter on a limited subset of condition
         * @param {boolean} [shippingAllowed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersGetCollection(page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: number, unitPrice2?: Array<number>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, nature?: ApiOffersGetCollectionNatureEnum, condition?: ApiOffersGetCollectionConditionEnum, shippingAllowed?: boolean, options?: any): AxiosPromise<Array<OfferCollectionRead>> {
            return localVarFp.apiOffersGetCollection(page, title, publicUrl, publicUrl2, unitPrice, unitPrice2, itemCount, itemCount2, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, metadata, offerMetadata, nature, condition, shippingAllowed, options).then((request) => request(axios, basePath));
        },
        /**
         * Publish an offer so that you can safely retrieve a safe-checkout unique link from us
         * @summary Create an Offer and retrieve url
         * @param {OfferIndependentWrite} offerIndependentWrite The new Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersPost(offerIndependentWrite: OfferIndependentWrite, options?: any): AxiosPromise<OfferPostCreationRead> {
            return localVarFp.apiOffersPost(offerIndependentWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Offer resource.
         * @summary Read an Offer
         * @param {string} ulid Offer identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidGet(ulid: string, options?: any): AxiosPromise<OfferRead> {
            return localVarFp.apiOffersUlidGet(ulid, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Media resource.
         * @summary Removes the Media resource.
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasIdDelete(ulid: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiOffersUlidmediasIdDelete(ulid, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Media resource.
         * @summary Upload a picture for a given Offer
         * @param {string} ulid 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasPost(ulid: string, file?: File, options?: any): AxiosPromise<MediaRead> {
            return localVarFp.apiOffersUlidmediasPost(ulid, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of Transaction resources.
         * @summary Retrieve Payment Intents for Offer
         * @param {string} ulid Offer identifier
         * @param {number} [page] The collection page number
         * @param {ApiOffersUlidtransactionsGetCollectionOrderStatusEnum} [orderStatus] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {ApiOffersUlidtransactionsGetCollectionStatusEnum} [status] Filter on a limited subset of status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidtransactionsGetCollection(ulid: string, page?: number, orderStatus?: ApiOffersUlidtransactionsGetCollectionOrderStatusEnum, metadata?: Array<string>, status?: ApiOffersUlidtransactionsGetCollectionStatusEnum, options?: any): AxiosPromise<Array<TransactionCollectionRead>> {
            return localVarFp.apiOffersUlidtransactionsGetCollection(ulid, page, orderStatus, metadata, status, options).then((request) => request(axios, basePath));
        },
        /**
         * **Only authenticated** buyer and seller **CAN** issue an evaluation **WHEN** the transaction reached a final state.
         * @summary Submit an Evaluation for the Offer
         * @param {string} ulid Dispute identifier
         * @param {string} id Transaction identifier
         * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidtransactionsIdevaluationsPost(ulid: string, id: string, evaluationWrite: EvaluationWrite, options?: any): AxiosPromise<EvaluationRead> {
            return localVarFp.apiOffersUlidtransactionsIdevaluationsPost(ulid, id, evaluationWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Cannot be used outside of a Persona (buyer)
         * @summary Create a Payment Intent for Offer
         * @param {string} ulid Offer identifier
         * @param {object} body The new Transaction resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidtransactionsPost(ulid: string, body: object, options?: any): AxiosPromise<TransactionRead> {
            return localVarFp.apiOffersUlidtransactionsPost(ulid, body, options).then((request) => request(axios, basePath));
        },
        /**
         * That goes without says, if that **Offer** have a _Transaction_ **that is ongoing**, you **MAY NOT** revoke the **Offer**.
         * @summary Revoke an Offer for given Persona
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdoffersDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiPersonasIdoffersDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of Offer resources.
         * @summary List or Search Offers for given Persona
         * @param {string} id Persona identifier
         * @param {number} [page] The collection page number
         * @param {string} [title] 
         * @param {string} [publicUrl] 
         * @param {Array<string>} [publicUrl2] 
         * @param {number} [unitPrice] 
         * @param {Array<number>} [unitPrice2] 
         * @param {number} [itemCount] 
         * @param {Array<number>} [itemCount2] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {ApiPersonasIdoffersGetCollectionNatureEnum} [nature] Filter on a limited subset of nature
         * @param {ApiPersonasIdoffersGetCollectionConditionEnum} [condition] Filter on a limited subset of condition
         * @param {boolean} [shippingAllowed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdoffersGetCollection(id: string, page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: number, unitPrice2?: Array<number>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, nature?: ApiPersonasIdoffersGetCollectionNatureEnum, condition?: ApiPersonasIdoffersGetCollectionConditionEnum, shippingAllowed?: boolean, options?: any): AxiosPromise<Array<OfferCollectionRead>> {
            return localVarFp.apiPersonasIdoffersGetCollection(id, page, title, publicUrl, publicUrl2, unitPrice, unitPrice2, itemCount, itemCount2, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, metadata, offerMetadata, nature, condition, shippingAllowed, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the Offer resource.
         * @summary Update an Offer for given Persona
         * @param {string} id Persona identifier
         * @param {OfferUpdate} offerUpdate The updated Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdoffersPatch(id: string, offerUpdate: OfferUpdate, options?: any): AxiosPromise<OfferRead> {
            return localVarFp.apiPersonasIdoffersPatch(id, offerUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Offer resource.
         * @summary Create an Offer for given Persona
         * @param {string} id Persona identifier
         * @param {OfferWrite} offerWrite The new Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdoffersPost(id: string, offerWrite: OfferWrite, options?: any): AxiosPromise<OfferPostCreationRead> {
            return localVarFp.apiPersonasIdoffersPost(id, offerWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of Transaction resources.
         * @summary Retrieves the collection of Transaction resources.
         * @param {number} [page] The collection page number
         * @param {ApiTransactionsGetCollectionOrderStatusEnum} [orderStatus] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {ApiTransactionsGetCollectionStatusEnum} [status] Filter on a limited subset of status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsGetCollection(page?: number, orderStatus?: ApiTransactionsGetCollectionOrderStatusEnum, metadata?: Array<string>, status?: ApiTransactionsGetCollectionStatusEnum, options?: any): AxiosPromise<Array<TransactionCollectionRead>> {
            return localVarFp.apiTransactionsGetCollection(page, orderStatus, metadata, status, options).then((request) => request(axios, basePath));
        },
        /**
         * **Only the buyer/complainant** can dismiss the case immediately. Otherwise, the support can but in a limited ranges of Dispute status.
         * @summary Abandon claims on Dispute
         * @param {string} ulid Transaction identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUliddisputeDelete(ulid: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiTransactionsUliddisputeDelete(ulid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Dispute resource.
         * @summary Read Dispute from existing Transaction
         * @param {string} ulid Transaction identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUliddisputeGet(ulid: string, options?: any): AxiosPromise<DisputeRead> {
            return localVarFp.apiTransactionsUliddisputeGet(ulid, options).then((request) => request(axios, basePath));
        },
        /**
         * Only authenticated Persona can interact with a Dispute object. Usually through our web application.
         * @summary Interact with a Dispute
         * @param {string} ulid Transaction identifier
         * @param {DisputeUpdate} disputeUpdate The updated Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUliddisputePatch(ulid: string, disputeUpdate: DisputeUpdate, options?: any): AxiosPromise<DisputeRead> {
            return localVarFp.apiTransactionsUliddisputePatch(ulid, disputeUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Dispute resource.
         * @summary Open a Dispute related to existing Transaction
         * @param {string} ulid Transaction identifier
         * @param {DisputeWrite} disputeWrite The new Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUliddisputePost(ulid: string, disputeWrite: DisputeWrite, options?: any): AxiosPromise<DisputePostCreationRead> {
            return localVarFp.apiTransactionsUliddisputePost(ulid, disputeWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of Parcel resources.
         * @summary Read shipments from Transaction
         * @param {string} ulid 
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidparcelsGetCollection(ulid: string, page?: number, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.apiTransactionsUlidparcelsGetCollection(ulid, page, options).then((request) => request(axios, basePath));
        },
        /**
         * No one except the support can do that manoeuvre.
         * @summary Withdraw shipment from Transaction
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidparcelsIdDelete(ulid: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiTransactionsUlidparcelsIdDelete(ulid, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Parcel resource.
         * @summary Manually declare package shipped for Transaction
         * @param {string} ulid 
         * @param {ParcelWrite} parcelWrite The new Parcel resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidparcelsPost(ulid: string, parcelWrite: ParcelWrite, options?: any): AxiosPromise<ParcelRead> {
            return localVarFp.apiTransactionsUlidparcelsPost(ulid, parcelWrite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SafeCheckoutApi - object-oriented interface
 * @export
 * @class SafeCheckoutApi
 * @extends {BaseAPI}
 */
export class SafeCheckoutApi extends BaseAPI {
    /**
     * Retrieves the collection of Offer resources.
     * @summary Read issued Offers
     * @param {number} [page] The collection page number
     * @param {string} [title] 
     * @param {string} [publicUrl] 
     * @param {Array<string>} [publicUrl2] 
     * @param {number} [unitPrice] 
     * @param {Array<number>} [unitPrice2] 
     * @param {number} [itemCount] 
     * @param {Array<number>} [itemCount2] 
     * @param {string} [createdAtBefore] 
     * @param {string} [createdAtStrictlyBefore] 
     * @param {string} [createdAtAfter] 
     * @param {string} [createdAtStrictlyAfter] 
     * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {ApiOffersGetCollectionNatureEnum} [nature] Filter on a limited subset of nature
     * @param {ApiOffersGetCollectionConditionEnum} [condition] Filter on a limited subset of condition
     * @param {boolean} [shippingAllowed] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersGetCollection(page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: number, unitPrice2?: Array<number>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, nature?: ApiOffersGetCollectionNatureEnum, condition?: ApiOffersGetCollectionConditionEnum, shippingAllowed?: boolean, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersGetCollection(page, title, publicUrl, publicUrl2, unitPrice, unitPrice2, itemCount, itemCount2, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, metadata, offerMetadata, nature, condition, shippingAllowed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publish an offer so that you can safely retrieve a safe-checkout unique link from us
     * @summary Create an Offer and retrieve url
     * @param {OfferIndependentWrite} offerIndependentWrite The new Offer resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersPost(offerIndependentWrite: OfferIndependentWrite, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersPost(offerIndependentWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Offer resource.
     * @summary Read an Offer
     * @param {string} ulid Offer identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersUlidGet(ulid: string, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersUlidGet(ulid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Media resource.
     * @summary Removes the Media resource.
     * @param {string} ulid 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersUlidmediasIdDelete(ulid: string, id: number, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersUlidmediasIdDelete(ulid, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Media resource.
     * @summary Upload a picture for a given Offer
     * @param {string} ulid 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersUlidmediasPost(ulid: string, file?: File, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersUlidmediasPost(ulid, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of Transaction resources.
     * @summary Retrieve Payment Intents for Offer
     * @param {string} ulid Offer identifier
     * @param {number} [page] The collection page number
     * @param {ApiOffersUlidtransactionsGetCollectionOrderStatusEnum} [orderStatus] 
     * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {ApiOffersUlidtransactionsGetCollectionStatusEnum} [status] Filter on a limited subset of status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersUlidtransactionsGetCollection(ulid: string, page?: number, orderStatus?: ApiOffersUlidtransactionsGetCollectionOrderStatusEnum, metadata?: Array<string>, status?: ApiOffersUlidtransactionsGetCollectionStatusEnum, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersUlidtransactionsGetCollection(ulid, page, orderStatus, metadata, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Only authenticated** buyer and seller **CAN** issue an evaluation **WHEN** the transaction reached a final state.
     * @summary Submit an Evaluation for the Offer
     * @param {string} ulid Dispute identifier
     * @param {string} id Transaction identifier
     * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersUlidtransactionsIdevaluationsPost(ulid: string, id: string, evaluationWrite: EvaluationWrite, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersUlidtransactionsIdevaluationsPost(ulid, id, evaluationWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cannot be used outside of a Persona (buyer)
     * @summary Create a Payment Intent for Offer
     * @param {string} ulid Offer identifier
     * @param {object} body The new Transaction resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersUlidtransactionsPost(ulid: string, body: object, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersUlidtransactionsPost(ulid, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * That goes without says, if that **Offer** have a _Transaction_ **that is ongoing**, you **MAY NOT** revoke the **Offer**.
     * @summary Revoke an Offer for given Persona
     * @param {string} id Persona identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiPersonasIdoffersDelete(id: string, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiPersonasIdoffersDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of Offer resources.
     * @summary List or Search Offers for given Persona
     * @param {string} id Persona identifier
     * @param {number} [page] The collection page number
     * @param {string} [title] 
     * @param {string} [publicUrl] 
     * @param {Array<string>} [publicUrl2] 
     * @param {number} [unitPrice] 
     * @param {Array<number>} [unitPrice2] 
     * @param {number} [itemCount] 
     * @param {Array<number>} [itemCount2] 
     * @param {string} [createdAtBefore] 
     * @param {string} [createdAtStrictlyBefore] 
     * @param {string} [createdAtAfter] 
     * @param {string} [createdAtStrictlyAfter] 
     * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {ApiPersonasIdoffersGetCollectionNatureEnum} [nature] Filter on a limited subset of nature
     * @param {ApiPersonasIdoffersGetCollectionConditionEnum} [condition] Filter on a limited subset of condition
     * @param {boolean} [shippingAllowed] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiPersonasIdoffersGetCollection(id: string, page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: number, unitPrice2?: Array<number>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, nature?: ApiPersonasIdoffersGetCollectionNatureEnum, condition?: ApiPersonasIdoffersGetCollectionConditionEnum, shippingAllowed?: boolean, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiPersonasIdoffersGetCollection(id, page, title, publicUrl, publicUrl2, unitPrice, unitPrice2, itemCount, itemCount2, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, metadata, offerMetadata, nature, condition, shippingAllowed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the Offer resource.
     * @summary Update an Offer for given Persona
     * @param {string} id Persona identifier
     * @param {OfferUpdate} offerUpdate The updated Offer resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiPersonasIdoffersPatch(id: string, offerUpdate: OfferUpdate, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiPersonasIdoffersPatch(id, offerUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Offer resource.
     * @summary Create an Offer for given Persona
     * @param {string} id Persona identifier
     * @param {OfferWrite} offerWrite The new Offer resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiPersonasIdoffersPost(id: string, offerWrite: OfferWrite, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiPersonasIdoffersPost(id, offerWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of Transaction resources.
     * @summary Retrieves the collection of Transaction resources.
     * @param {number} [page] The collection page number
     * @param {ApiTransactionsGetCollectionOrderStatusEnum} [orderStatus] 
     * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {ApiTransactionsGetCollectionStatusEnum} [status] Filter on a limited subset of status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiTransactionsGetCollection(page?: number, orderStatus?: ApiTransactionsGetCollectionOrderStatusEnum, metadata?: Array<string>, status?: ApiTransactionsGetCollectionStatusEnum, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiTransactionsGetCollection(page, orderStatus, metadata, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Only the buyer/complainant** can dismiss the case immediately. Otherwise, the support can but in a limited ranges of Dispute status.
     * @summary Abandon claims on Dispute
     * @param {string} ulid Transaction identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiTransactionsUliddisputeDelete(ulid: string, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiTransactionsUliddisputeDelete(ulid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Dispute resource.
     * @summary Read Dispute from existing Transaction
     * @param {string} ulid Transaction identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiTransactionsUliddisputeGet(ulid: string, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiTransactionsUliddisputeGet(ulid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only authenticated Persona can interact with a Dispute object. Usually through our web application.
     * @summary Interact with a Dispute
     * @param {string} ulid Transaction identifier
     * @param {DisputeUpdate} disputeUpdate The updated Dispute resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiTransactionsUliddisputePatch(ulid: string, disputeUpdate: DisputeUpdate, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiTransactionsUliddisputePatch(ulid, disputeUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Dispute resource.
     * @summary Open a Dispute related to existing Transaction
     * @param {string} ulid Transaction identifier
     * @param {DisputeWrite} disputeWrite The new Dispute resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiTransactionsUliddisputePost(ulid: string, disputeWrite: DisputeWrite, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiTransactionsUliddisputePost(ulid, disputeWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of Parcel resources.
     * @summary Read shipments from Transaction
     * @param {string} ulid 
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiTransactionsUlidparcelsGetCollection(ulid: string, page?: number, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiTransactionsUlidparcelsGetCollection(ulid, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * No one except the support can do that manoeuvre.
     * @summary Withdraw shipment from Transaction
     * @param {string} ulid 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiTransactionsUlidparcelsIdDelete(ulid: string, id: number, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiTransactionsUlidparcelsIdDelete(ulid, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Parcel resource.
     * @summary Manually declare package shipped for Transaction
     * @param {string} ulid 
     * @param {ParcelWrite} parcelWrite The new Parcel resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiTransactionsUlidparcelsPost(ulid: string, parcelWrite: ParcelWrite, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiTransactionsUlidparcelsPost(ulid, parcelWrite, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum ApiOffersGetCollectionNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiOffersGetCollectionConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiOffersUlidtransactionsGetCollectionOrderStatusEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiOffersUlidtransactionsGetCollectionStatusEnum {
    Created = 'CREATED',
    Authorized = 'AUTHORIZED',
    Refused = 'REFUSED',
    Accepted = 'ACCEPTED',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Delivered = 'DELIVERED',
    Completed = 'COMPLETED',
    Disputed = 'DISPUTED'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiPersonasIdoffersGetCollectionNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiPersonasIdoffersGetCollectionConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiTransactionsGetCollectionOrderStatusEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiTransactionsGetCollectionStatusEnum {
    Created = 'CREATED',
    Authorized = 'AUTHORIZED',
    Refused = 'REFUSED',
    Accepted = 'ACCEPTED',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Delivered = 'DELIVERED',
    Completed = 'COMPLETED',
    Disputed = 'DISPUTED'
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of ApiClient resources.
         * @summary Retrieves the collection of ApiClient resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsGetCollection: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the ApiClient resource.
         * @summary Removes the ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsIdentifierDelete: async (identifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('apiApiClientsIdentifierDelete', 'identifier', identifier)
            const localVarPath = `/api-clients/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a ApiClient resource.
         * @summary Retrieves a ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsIdentifierGet: async (identifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('apiApiClientsIdentifierGet', 'identifier', identifier)
            const localVarPath = `/api-clients/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a ApiClient resource.
         * @summary Creates a ApiClient resource.
         * @param {ApiClientWrite} apiClientWrite The new ApiClient resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsPost: async (apiClientWrite: ApiClientWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiClientWrite' is not null or undefined
            assertParamExists('apiApiClientsPost', 'apiClientWrite', apiClientWrite)
            const localVarPath = `/api-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiClientWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a user to your organization workspace
         * @summary Organization invite
         * @param {UserInvite} userInvite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInvitePost: async (userInvite: UserInvite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userInvite' is not null or undefined
            assertParamExists('apiInvitePost', 'userInvite', userInvite)
            const localVarPath = `/invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInvite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Main route for Persona (Organization customers) to authenticate themselves. Public access, captcha protected and MFA mandatory.
         * @summary Persona Authentication
         * @param {PersonaExternalAuth} personaExternalAuth The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasauthenticationPost: async (personaExternalAuth: PersonaExternalAuth, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaExternalAuth' is not null or undefined
            assertParamExists('apiPersonasauthenticationPost', 'personaExternalAuth', personaExternalAuth)
            const localVarPath = `/personas/authentication`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaExternalAuth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Persona resource.
         * @summary Retrieve your authenticated Persona
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasmeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/personas/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Persona resource.
         * @summary Persona external registration
         * @param {PersonaRegister} personaRegister The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasregisterPost: async (personaRegister: PersonaRegister, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaRegister' is not null or undefined
            assertParamExists('apiPersonasregisterPost', 'personaRegister', personaRegister)
            const localVarPath = `/personas/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaRegister, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Internal-use only, protected by a captcha. Organization first-enrollment
         * @summary Organization onboarding
         * @param {UserWrite} userWrite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRegisterPost: async (userWrite: UserWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userWrite' is not null or undefined
            assertParamExists('apiRegisterPost', 'userWrite', userWrite)
            const localVarPath = `/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of User resources.
         * @summary Retrieves the collection of User resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGetCollection: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdGet', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {UserUpdate} userUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdPatch: async (id: string, userUpdate: UserUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdPatch', 'id', id)
            // verify required parameter 'userUpdate' is not null or undefined
            assertParamExists('apiUsersIdPatch', 'userUpdate', userUpdate)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Validate email ownership
         * @param {string} id User identifier
         * @param {UserEmailValidationWrite} userEmailValidationWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdemailValidationPatch: async (id: string, userEmailValidationWrite: UserEmailValidationWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdemailValidationPatch', 'id', id)
            // verify required parameter 'userEmailValidationWrite' is not null or undefined
            assertParamExists('apiUsersIdemailValidationPatch', 'userEmailValidationWrite', userEmailValidationWrite)
            const localVarPath = `/users/{id}/email-validation`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userEmailValidationWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of ApiClient resources.
         * @summary Retrieves the collection of ApiClient resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApiClientsGetCollection(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiClientRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApiClientsGetCollection(page, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.apiApiClientsGetCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Removes the ApiClient resource.
         * @summary Removes the ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApiClientsIdentifierDelete(identifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApiClientsIdentifierDelete(identifier, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.apiApiClientsIdentifierDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves a ApiClient resource.
         * @summary Retrieves a ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApiClientsIdentifierGet(identifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClientRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApiClientsIdentifierGet(identifier, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.apiApiClientsIdentifierGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates a ApiClient resource.
         * @summary Creates a ApiClient resource.
         * @param {ApiClientWrite} apiClientWrite The new ApiClient resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApiClientsPost(apiClientWrite: ApiClientWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClientPostCreationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApiClientsPost(apiClientWrite, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.apiApiClientsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Invite a user to your organization workspace
         * @summary Organization invite
         * @param {UserInvite} userInvite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInvitePost(userInvite: UserInvite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPostRegisterRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInvitePost(userInvite, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.apiInvitePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuthenticatedRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMeGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.apiMeGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Main route for Persona (Organization customers) to authenticate themselves. Public access, captcha protected and MFA mandatory.
         * @summary Persona Authentication
         * @param {PersonaExternalAuth} personaExternalAuth The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasauthenticationPost(personaExternalAuth: PersonaExternalAuth, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaAuthReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasauthenticationPost(personaExternalAuth, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.apiPersonasauthenticationPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves a Persona resource.
         * @summary Retrieve your authenticated Persona
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasmeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasmeGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.apiPersonasmeGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates a Persona resource.
         * @summary Persona external registration
         * @param {PersonaRegister} personaRegister The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasregisterPost(personaRegister: PersonaRegister, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasregisterPost(personaRegister, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.apiPersonasregisterPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Internal-use only, protected by a captcha. Organization first-enrollment
         * @summary Organization onboarding
         * @param {UserWrite} userWrite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRegisterPost(userWrite: UserWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPostRegisterRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRegisterPost(userWrite, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.apiRegisterPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves the collection of User resources.
         * @summary Retrieves the collection of User resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersGetCollection(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersGetCollection(page, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.apiUsersGetCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.apiUsersIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {UserUpdate} userUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdPatch(id: string, userUpdate: UserUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPostRegisterRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdPatch(id, userUpdate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.apiUsersIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Validate email ownership
         * @param {string} id User identifier
         * @param {UserEmailValidationWrite} userEmailValidationWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdemailValidationPatch(id: string, userEmailValidationWrite: UserEmailValidationWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPostRegisterRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdemailValidationPatch(id, userEmailValidationWrite, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UserApi.apiUsersIdemailValidationPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Retrieves the collection of ApiClient resources.
         * @summary Retrieves the collection of ApiClient resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsGetCollection(page?: number, options?: any): AxiosPromise<Array<ApiClientRead>> {
            return localVarFp.apiApiClientsGetCollection(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the ApiClient resource.
         * @summary Removes the ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsIdentifierDelete(identifier: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiApiClientsIdentifierDelete(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a ApiClient resource.
         * @summary Retrieves a ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsIdentifierGet(identifier: string, options?: any): AxiosPromise<ApiClientRead> {
            return localVarFp.apiApiClientsIdentifierGet(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a ApiClient resource.
         * @summary Creates a ApiClient resource.
         * @param {ApiClientWrite} apiClientWrite The new ApiClient resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsPost(apiClientWrite: ApiClientWrite, options?: any): AxiosPromise<ApiClientPostCreationRead> {
            return localVarFp.apiApiClientsPost(apiClientWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a user to your organization workspace
         * @summary Organization invite
         * @param {UserInvite} userInvite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInvitePost(userInvite: UserInvite, options?: any): AxiosPromise<UserPostRegisterRead> {
            return localVarFp.apiInvitePost(userInvite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMeGet(options?: any): AxiosPromise<UserAuthenticatedRead> {
            return localVarFp.apiMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Main route for Persona (Organization customers) to authenticate themselves. Public access, captcha protected and MFA mandatory.
         * @summary Persona Authentication
         * @param {PersonaExternalAuth} personaExternalAuth The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasauthenticationPost(personaExternalAuth: PersonaExternalAuth, options?: any): AxiosPromise<PersonaAuthReturn> {
            return localVarFp.apiPersonasauthenticationPost(personaExternalAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Persona resource.
         * @summary Retrieve your authenticated Persona
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasmeGet(options?: any): AxiosPromise<PersonaRead> {
            return localVarFp.apiPersonasmeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Persona resource.
         * @summary Persona external registration
         * @param {PersonaRegister} personaRegister The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasregisterPost(personaRegister: PersonaRegister, options?: any): AxiosPromise<PersonaRead> {
            return localVarFp.apiPersonasregisterPost(personaRegister, options).then((request) => request(axios, basePath));
        },
        /**
         * Internal-use only, protected by a captcha. Organization first-enrollment
         * @summary Organization onboarding
         * @param {UserWrite} userWrite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRegisterPost(userWrite: UserWrite, options?: any): AxiosPromise<UserPostRegisterRead> {
            return localVarFp.apiRegisterPost(userWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of User resources.
         * @summary Retrieves the collection of User resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGetCollection(page?: number, options?: any): AxiosPromise<Array<UserCollectionRead>> {
            return localVarFp.apiUsersGetCollection(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdGet(id: string, options?: any): AxiosPromise<User> {
            return localVarFp.apiUsersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {UserUpdate} userUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdPatch(id: string, userUpdate: UserUpdate, options?: any): AxiosPromise<UserPostRegisterRead> {
            return localVarFp.apiUsersIdPatch(id, userUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Validate email ownership
         * @param {string} id User identifier
         * @param {UserEmailValidationWrite} userEmailValidationWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdemailValidationPatch(id: string, userEmailValidationWrite: UserEmailValidationWrite, options?: any): AxiosPromise<UserPostRegisterRead> {
            return localVarFp.apiUsersIdemailValidationPatch(id, userEmailValidationWrite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Retrieves the collection of ApiClient resources.
     * @summary Retrieves the collection of ApiClient resources.
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiApiClientsGetCollection(page?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiApiClientsGetCollection(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the ApiClient resource.
     * @summary Removes the ApiClient resource.
     * @param {string} identifier ApiClient identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiApiClientsIdentifierDelete(identifier: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiApiClientsIdentifierDelete(identifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a ApiClient resource.
     * @summary Retrieves a ApiClient resource.
     * @param {string} identifier ApiClient identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiApiClientsIdentifierGet(identifier: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiApiClientsIdentifierGet(identifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a ApiClient resource.
     * @summary Creates a ApiClient resource.
     * @param {ApiClientWrite} apiClientWrite The new ApiClient resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiApiClientsPost(apiClientWrite: ApiClientWrite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiApiClientsPost(apiClientWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invite a user to your organization workspace
     * @summary Organization invite
     * @param {UserInvite} userInvite The new User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiInvitePost(userInvite: UserInvite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiInvitePost(userInvite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a User resource.
     * @summary Retrieves a User resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiMeGet(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Main route for Persona (Organization customers) to authenticate themselves. Public access, captcha protected and MFA mandatory.
     * @summary Persona Authentication
     * @param {PersonaExternalAuth} personaExternalAuth The new Persona resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiPersonasauthenticationPost(personaExternalAuth: PersonaExternalAuth, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiPersonasauthenticationPost(personaExternalAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Persona resource.
     * @summary Retrieve your authenticated Persona
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiPersonasmeGet(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiPersonasmeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Persona resource.
     * @summary Persona external registration
     * @param {PersonaRegister} personaRegister The new Persona resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiPersonasregisterPost(personaRegister: PersonaRegister, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiPersonasregisterPost(personaRegister, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Internal-use only, protected by a captcha. Organization first-enrollment
     * @summary Organization onboarding
     * @param {UserWrite} userWrite The new User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiRegisterPost(userWrite: UserWrite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiRegisterPost(userWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of User resources.
     * @summary Retrieves the collection of User resources.
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersGetCollection(page?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersGetCollection(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a User resource.
     * @summary Retrieves a User resource.
     * @param {string} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdGet(id: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Updates the User resource.
     * @param {string} id User identifier
     * @param {UserUpdate} userUpdate The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdPatch(id: string, userUpdate: UserUpdate, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdPatch(id, userUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Validate email ownership
     * @param {string} id User identifier
     * @param {UserEmailValidationWrite} userEmailValidationWrite The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdemailValidationPatch(id: string, userEmailValidationWrite: UserEmailValidationWrite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdemailValidationPatch(id, userEmailValidationWrite, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of WebhookHistory resources.
         * @summary Retrieves the collection of WebhookHistory resources.
         * @param {number} [page] The collection page number
         * @param {string} [event] 
         * @param {Array<string>} [event2] 
         * @param {string} [objectId] 
         * @param {Array<string>} [objectId2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesGetCollection: async (page?: number, event?: string, event2?: Array<string>, objectId?: string, objectId2?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhook-histories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["ORGANIZATION_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }

            if (event2) {
                localVarQueryParameter['event[]'] = event2;
            }

            if (objectId !== undefined) {
                localVarQueryParameter['objectId'] = objectId;
            }

            if (objectId2) {
                localVarQueryParameter['objectId[]'] = objectId2;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a WebhookHistory resource.
         * @summary Retrieves a WebhookHistory resource.
         * @param {string} id WebhookHistory identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWebhookHistoriesIdGet', 'id', id)
            const localVarPath = `/webhook-histories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["ORGANIZATION_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces the WebhookHistory resource.
         * @summary Replay a Webhook that ended up in failure
         * @param {string} id WebhookHistory identifier
         * @param {object} body The updated WebhookHistory resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesIdPut: async (id: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWebhookHistoriesIdPut', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('apiWebhookHistoriesIdPut', 'body', body)
            const localVarPath = `/webhook-histories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of WebhookSubscription resources.
         * @summary Retrieves the collection of WebhookSubscription resources.
         * @param {number} [page] The collection page number
         * @param {ApiWebhookSubscriptionsGetCollectionEventEnum} [event] Filter on a limited subset of event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsGetCollection: async (page?: number, event?: ApiWebhookSubscriptionsGetCollectionEventEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhook-subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["ORGANIZATION_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the WebhookSubscription resource.
         * @summary Removes the WebhookSubscription resource.
         * @param {string} id WebhookSubscription identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWebhookSubscriptionsIdDelete', 'id', id)
            const localVarPath = `/webhook-subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a WebhookSubscription resource.
         * @summary Subscribe to Event(s)
         * @param {WebhookSubscriptionWrite} webhookSubscriptionWrite The new WebhookSubscription resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsPost: async (webhookSubscriptionWrite: WebhookSubscriptionWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookSubscriptionWrite' is not null or undefined
            assertParamExists('apiWebhookSubscriptionsPost', 'webhookSubscriptionWrite', webhookSubscriptionWrite)
            const localVarPath = `/webhook-subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookSubscriptionWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of WebhookHistory resources.
         * @summary Retrieves the collection of WebhookHistory resources.
         * @param {number} [page] The collection page number
         * @param {string} [event] 
         * @param {Array<string>} [event2] 
         * @param {string} [objectId] 
         * @param {Array<string>} [objectId2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookHistoriesGetCollection(page?: number, event?: string, event2?: Array<string>, objectId?: string, objectId2?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookHistoryCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookHistoriesGetCollection(page, event, event2, objectId, objectId2, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhookApi.apiWebhookHistoriesGetCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves a WebhookHistory resource.
         * @summary Retrieves a WebhookHistory resource.
         * @param {string} id WebhookHistory identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookHistoriesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookHistoryRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookHistoriesIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhookApi.apiWebhookHistoriesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Replaces the WebhookHistory resource.
         * @summary Replay a Webhook that ended up in failure
         * @param {string} id WebhookHistory identifier
         * @param {object} body The updated WebhookHistory resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookHistoriesIdPut(id: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookHistoryRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookHistoriesIdPut(id, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhookApi.apiWebhookHistoriesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves the collection of WebhookSubscription resources.
         * @summary Retrieves the collection of WebhookSubscription resources.
         * @param {number} [page] The collection page number
         * @param {ApiWebhookSubscriptionsGetCollectionEventEnum} [event] Filter on a limited subset of event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookSubscriptionsGetCollection(page?: number, event?: ApiWebhookSubscriptionsGetCollectionEventEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookSubscriptionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookSubscriptionsGetCollection(page, event, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhookApi.apiWebhookSubscriptionsGetCollection']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Removes the WebhookSubscription resource.
         * @summary Removes the WebhookSubscription resource.
         * @param {string} id WebhookSubscription identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookSubscriptionsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookSubscriptionsIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhookApi.apiWebhookSubscriptionsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates a WebhookSubscription resource.
         * @summary Subscribe to Event(s)
         * @param {WebhookSubscriptionWrite} webhookSubscriptionWrite The new WebhookSubscription resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookSubscriptionsPost(webhookSubscriptionWrite: WebhookSubscriptionWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSubscriptionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookSubscriptionsPost(webhookSubscriptionWrite, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhookApi.apiWebhookSubscriptionsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * Retrieves the collection of WebhookHistory resources.
         * @summary Retrieves the collection of WebhookHistory resources.
         * @param {number} [page] The collection page number
         * @param {string} [event] 
         * @param {Array<string>} [event2] 
         * @param {string} [objectId] 
         * @param {Array<string>} [objectId2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesGetCollection(page?: number, event?: string, event2?: Array<string>, objectId?: string, objectId2?: Array<string>, options?: any): AxiosPromise<Array<WebhookHistoryCollectionRead>> {
            return localVarFp.apiWebhookHistoriesGetCollection(page, event, event2, objectId, objectId2, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a WebhookHistory resource.
         * @summary Retrieves a WebhookHistory resource.
         * @param {string} id WebhookHistory identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesIdGet(id: string, options?: any): AxiosPromise<WebhookHistoryRead> {
            return localVarFp.apiWebhookHistoriesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the WebhookHistory resource.
         * @summary Replay a Webhook that ended up in failure
         * @param {string} id WebhookHistory identifier
         * @param {object} body The updated WebhookHistory resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesIdPut(id: string, body: object, options?: any): AxiosPromise<WebhookHistoryRead> {
            return localVarFp.apiWebhookHistoriesIdPut(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of WebhookSubscription resources.
         * @summary Retrieves the collection of WebhookSubscription resources.
         * @param {number} [page] The collection page number
         * @param {ApiWebhookSubscriptionsGetCollectionEventEnum} [event] Filter on a limited subset of event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsGetCollection(page?: number, event?: ApiWebhookSubscriptionsGetCollectionEventEnum, options?: any): AxiosPromise<Array<WebhookSubscriptionRead>> {
            return localVarFp.apiWebhookSubscriptionsGetCollection(page, event, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the WebhookSubscription resource.
         * @summary Removes the WebhookSubscription resource.
         * @param {string} id WebhookSubscription identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiWebhookSubscriptionsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a WebhookSubscription resource.
         * @summary Subscribe to Event(s)
         * @param {WebhookSubscriptionWrite} webhookSubscriptionWrite The new WebhookSubscription resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsPost(webhookSubscriptionWrite: WebhookSubscriptionWrite, options?: any): AxiosPromise<WebhookSubscriptionRead> {
            return localVarFp.apiWebhookSubscriptionsPost(webhookSubscriptionWrite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * Retrieves the collection of WebhookHistory resources.
     * @summary Retrieves the collection of WebhookHistory resources.
     * @param {number} [page] The collection page number
     * @param {string} [event] 
     * @param {Array<string>} [event2] 
     * @param {string} [objectId] 
     * @param {Array<string>} [objectId2] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookHistoriesGetCollection(page?: number, event?: string, event2?: Array<string>, objectId?: string, objectId2?: Array<string>, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookHistoriesGetCollection(page, event, event2, objectId, objectId2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a WebhookHistory resource.
     * @summary Retrieves a WebhookHistory resource.
     * @param {string} id WebhookHistory identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookHistoriesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookHistoriesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces the WebhookHistory resource.
     * @summary Replay a Webhook that ended up in failure
     * @param {string} id WebhookHistory identifier
     * @param {object} body The updated WebhookHistory resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookHistoriesIdPut(id: string, body: object, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookHistoriesIdPut(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of WebhookSubscription resources.
     * @summary Retrieves the collection of WebhookSubscription resources.
     * @param {number} [page] The collection page number
     * @param {ApiWebhookSubscriptionsGetCollectionEventEnum} [event] Filter on a limited subset of event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookSubscriptionsGetCollection(page?: number, event?: ApiWebhookSubscriptionsGetCollectionEventEnum, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookSubscriptionsGetCollection(page, event, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the WebhookSubscription resource.
     * @summary Removes the WebhookSubscription resource.
     * @param {string} id WebhookSubscription identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookSubscriptionsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookSubscriptionsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a WebhookSubscription resource.
     * @summary Subscribe to Event(s)
     * @param {WebhookSubscriptionWrite} webhookSubscriptionWrite The new WebhookSubscription resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookSubscriptionsPost(webhookSubscriptionWrite: WebhookSubscriptionWrite, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookSubscriptionsPost(webhookSubscriptionWrite, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum ApiWebhookSubscriptionsGetCollectionEventEnum {
    DisputeOpened = 'dispute.opened',
    DisputeSubmitted = 'dispute.submitted',
    DisputeCreated = 'dispute.created',
    DisputeAbandoned = 'dispute.abandoned',
    DisputeSettlement = 'dispute.settlement',
    DisputeClosed = 'dispute.closed',
    DisputeExpired = 'dispute.expired',
    DisputeManualArbitrationRequired = 'dispute.manual_arbitration_required',
    DisputeUpdated = 'dispute.updated',
    DisputeReminder = 'dispute.reminder',
    OfferCreated = 'offer.created',
    OfferExpired = 'offer.expired',
    OfferUpdated = 'offer.updated',
    OfferCrawlFailure = 'offer.crawl_failure',
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionReconciled = 'offer.transaction.reconciled',
    OfferTransactionAbandoned = 'offer.transaction.abandoned',
    OfferClosed = 'offer.closed',
    OfferTransactionRefund = 'offer.transaction.refund',
    PersonaAdded = 'persona.added'
}


