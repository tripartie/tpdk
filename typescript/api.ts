/* tslint:disable */
/* eslint-disable */
/**
 * Tripartie
 * Our API suite for the **Resolution Center** and the **Safe Checkout** features. Simple, yet elegant web interfaces for your convenience. One request away from your first automated resolution or safe-checkout.
 *
 * The version of the OpenAPI document: 2.0.9
 * Contact: noc@tripartie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {number}
     * @memberof Address
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'countryCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'gateOrPortalOrInboxCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'updatedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface AddressIndependentWrite
 */
export interface AddressIndependentWrite {
    /**
     * 
     * @type {string}
     * @memberof AddressIndependentWrite
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressIndependentWrite
     */
    'countryCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressIndependentWrite
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressIndependentWrite
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressIndependentWrite
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressIndependentWrite
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressIndependentWrite
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressIndependentWrite
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressIndependentWrite
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * 
 * @export
 * @interface AddressRead
 */
export interface AddressRead {
    /**
     * 
     * @type {string}
     * @memberof AddressRead
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressRead
     */
    'countryCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressRead
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressRead
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressRead
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressRead
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressRead
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressRead
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressRead
     */
    'gateOrPortalOrInboxCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressRead
     */
    'updatedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface AddressUpdate
 */
export interface AddressUpdate {
    /**
     * 
     * @type {string}
     * @memberof AddressUpdate
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdate
     */
    'countryCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdate
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdate
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdate
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdate
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdate
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdate
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressUpdate
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * 
 * @export
 * @interface AddressWrite
 */
export interface AddressWrite {
    /**
     * 
     * @type {string}
     * @memberof AddressWrite
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressWrite
     */
    'countryCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressWrite
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressWrite
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressWrite
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressWrite
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressWrite
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressWrite
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressWrite
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * 
 * @export
 * @interface AiHint
 */
export interface AiHint {
    /**
     * 
     * @type {number}
     * @memberof AiHint
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AiHint
     */
    'dispute'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AiHint
     */
    'evidence'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AiHint
     */
    'scoreOfTrust': number;
    /**
     * 
     * @type {string}
     * @memberof AiHint
     */
    'label': string;
    /**
     * 
     * @type {boolean}
     * @memberof AiHint
     */
    'dismissed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AiHint
     */
    'toBeDisclosed': boolean;
    /**
     * 
     * @type {string}
     * @memberof AiHint
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AiHint
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ApiClient
 */
export interface ApiClient {
    /**
     * 
     * @type {string}
     * @memberof ApiClient
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof ApiClient
     */
    'owner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiClient
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ApiClient
     */
    'secret'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiClient
     */
    'name'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof ApiClient
     */
    'redirectUris'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof ApiClient
     */
    'grants'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof ApiClient
     */
    'scopes'?: Array<object>;
    /**
     * 
     * @type {boolean}
     * @memberof ApiClient
     */
    'active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiClient
     */
    'allowPlainTextPkce'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiClient
     */
    'confidential'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiClient
     */
    'plainTextPkceAllowed'?: boolean;
}
/**
 * Access directly our resolution center without having used the safe-checkout feature.
 * @export
 * @interface Dispute
 */
export interface Dispute {
    /**
     * 
     * @type {number}
     * @memberof Dispute
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'ulid': string;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'transaction'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'status': DisputeStatusEnum;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof Dispute
     */
    'redirectUrl'?: string | null;
    /**
     * The dispute may concern only PART of the package. Specify it there.
     * @type {number}
     * @memberof Dispute
     */
    'itemCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'issueType': DisputeIssueTypeEnum;
    /**
     * To be set only in conjunction of issueType = NOT_AS_DESCRIBED.
     * @type {string}
     * @memberof Dispute
     */
    'issueInDescriptionType'?: DisputeIssueInDescriptionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'issueDetails'?: string;
    /**
     * 
     * @type {number}
     * @memberof Dispute
     */
    'complainantTruthfulnessScore': number;
    /**
     * 
     * @type {number}
     * @memberof Dispute
     */
    'sellerTruthfulnessScore': number;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'complainantStake': DisputeComplainantStakeEnum;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'inferredStake'?: DisputeInferredStakeEnum;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'recommendedSolution'?: DisputeRecommendedSolutionEnum;
    /**
     * 
     * @type {number}
     * @memberof Dispute
     */
    'recommendedPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'chosenSolution'?: DisputeChosenSolutionEnum;
    /**
     * 
     * @type {number}
     * @memberof Dispute
     */
    'chosenPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'counterSolution'?: DisputeCounterSolutionEnum;
    /**
     * 
     * @type {number}
     * @memberof Dispute
     */
    'counterPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof Dispute
     */
    'complainantApproval'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof Dispute
     */
    'sellerApproval': boolean | null;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'platformSolution'?: DisputePlatformSolutionEnum;
    /**
     * 
     * @type {number}
     * @memberof Dispute
     */
    'platformPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof Dispute
     */
    'platformApproval'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'arbitrationBy'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Dispute
     */
    'parcels': Array<string>;
    /**
     * 
     * @type {Array<Message>}
     * @memberof Dispute
     */
    'messages': Array<Message>;
    /**
     * 
     * @type {Array<View>}
     * @memberof Dispute
     */
    'views': Array<View>;
    /**
     * 
     * @type {Array<Metadata>}
     * @memberof Dispute
     */
    'metadata': Array<Metadata>;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'updatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Dispute
     */
    'iri'?: string;
    /**
     * 
     * @type {number}
     * @memberof Dispute
     */
    'messageCount'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum DisputeStatusEnum {
    Created = 'CREATED',
    Submitted = 'SUBMITTED',
    Opened = 'OPENED',
    Abandoned = 'ABANDONED',
    Pending = 'PENDING',
    Objected = 'OBJECTED',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Returned = 'RETURNED',
    Dismissed = 'DISMISSED',
    Resolved = 'RESOLVED'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeIssueTypeEnum {
    NotAsDescribed = 'NOT_AS_DESCRIBED',
    DoesNotWork = 'DOES_NOT_WORK',
    IsIncomplete = 'IS_INCOMPLETE',
    DeliveryIssue = 'DELIVERY_ISSUE',
    AllegedFraud = 'ALLEGED_FRAUD'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeIssueInDescriptionTypeEnum {
    WrongColour = 'WRONG_COLOUR',
    DamagedOrUsed = 'DAMAGED_OR_USED',
    IncorrectFormatOrSize = 'INCORRECT_FORMAT_OR_SIZE',
    DifferentMaterial = 'DIFFERENT_MATERIAL',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeComplainantStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeInferredStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeRecommendedSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeChosenSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeCounterSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputePlatformSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}

/**
 * Access directly our resolution center without having used the safe-checkout feature.
 * @export
 * @interface DisputeCollectionRead
 */
export interface DisputeCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'ulid': string;
    /**
     * 
     * @type {TransactionCollectionRead}
     * @memberof DisputeCollectionRead
     */
    'transaction'?: TransactionCollectionRead;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'status': DisputeCollectionReadStatusEnum;
    /**
     * The dispute may concern only PART of the package. Specify it there.
     * @type {number}
     * @memberof DisputeCollectionRead
     */
    'itemCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'issueType': DisputeCollectionReadIssueTypeEnum;
    /**
     * To be set only in conjunction of issueType = NOT_AS_DESCRIBED.
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'issueInDescriptionType'?: DisputeCollectionReadIssueInDescriptionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'complainantStake': DisputeCollectionReadComplainantStakeEnum;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'inferredStake'?: DisputeCollectionReadInferredStakeEnum;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'updatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeCollectionRead
     */
    'iri'?: string;
    /**
     * 
     * @type {number}
     * @memberof DisputeCollectionRead
     */
    'messageCount'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadStatusEnum {
    Created = 'CREATED',
    Submitted = 'SUBMITTED',
    Opened = 'OPENED',
    Abandoned = 'ABANDONED',
    Pending = 'PENDING',
    Objected = 'OBJECTED',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Returned = 'RETURNED',
    Dismissed = 'DISMISSED',
    Resolved = 'RESOLVED'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadIssueTypeEnum {
    NotAsDescribed = 'NOT_AS_DESCRIBED',
    DoesNotWork = 'DOES_NOT_WORK',
    IsIncomplete = 'IS_INCOMPLETE',
    DeliveryIssue = 'DELIVERY_ISSUE',
    AllegedFraud = 'ALLEGED_FRAUD'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadIssueInDescriptionTypeEnum {
    WrongColour = 'WRONG_COLOUR',
    DamagedOrUsed = 'DAMAGED_OR_USED',
    IncorrectFormatOrSize = 'INCORRECT_FORMAT_OR_SIZE',
    DifferentMaterial = 'DIFFERENT_MATERIAL',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadComplainantStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeCollectionReadInferredStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}

/**
 * Access directly our resolution center without having used the safe-checkout feature.
 * @export
 * @interface DisputeIndependentWrite
 */
export interface DisputeIndependentWrite {
    /**
     * 
     * @type {TransactionIndependentWrite}
     * @memberof DisputeIndependentWrite
     */
    'transaction'?: TransactionIndependentWrite;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof DisputeIndependentWrite
     */
    'redirectUrl'?: string | null;
    /**
     * 
     * @type {Array<MetadataIndependentWrite>}
     * @memberof DisputeIndependentWrite
     */
    'metadata': Array<MetadataIndependentWrite>;
}
/**
 * Access directly our resolution center without having used the safe-checkout feature.
 * @export
 * @interface DisputePostCreationRead
 */
export interface DisputePostCreationRead {
    /**
     * 
     * @type {string}
     * @memberof DisputePostCreationRead
     */
    'ulid': string;
    /**
     * 
     * @type {string}
     * @memberof DisputePostCreationRead
     */
    'url'?: string | null;
}
/**
 * Access directly our resolution center without having used the safe-checkout feature.
 * @export
 * @interface DisputeRead
 */
export interface DisputeRead {
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'ulid': string;
    /**
     * 
     * @type {TransactionRead}
     * @memberof DisputeRead
     */
    'transaction'?: TransactionRead;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'status': DisputeReadStatusEnum;
    /**
     * The dispute may concern only PART of the package. Specify it there.
     * @type {number}
     * @memberof DisputeRead
     */
    'itemCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'issueType': DisputeReadIssueTypeEnum;
    /**
     * To be set only in conjunction of issueType = NOT_AS_DESCRIBED.
     * @type {string}
     * @memberof DisputeRead
     */
    'issueInDescriptionType'?: DisputeReadIssueInDescriptionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'issueDetails'?: string;
    /**
     * 
     * @type {number}
     * @memberof DisputeRead
     */
    'complainantTruthfulnessScore': number;
    /**
     * 
     * @type {number}
     * @memberof DisputeRead
     */
    'sellerTruthfulnessScore': number;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'complainantStake': DisputeReadComplainantStakeEnum;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'inferredStake'?: DisputeReadInferredStakeEnum;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'recommendedSolution'?: DisputeReadRecommendedSolutionEnum;
    /**
     * 
     * @type {number}
     * @memberof DisputeRead
     */
    'recommendedPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'chosenSolution'?: DisputeReadChosenSolutionEnum;
    /**
     * 
     * @type {number}
     * @memberof DisputeRead
     */
    'chosenPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'counterSolution'?: DisputeReadCounterSolutionEnum;
    /**
     * 
     * @type {number}
     * @memberof DisputeRead
     */
    'counterPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeRead
     */
    'complainantApproval'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeRead
     */
    'sellerApproval': boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'platformSolution'?: DisputeReadPlatformSolutionEnum;
    /**
     * 
     * @type {number}
     * @memberof DisputeRead
     */
    'platformPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeRead
     */
    'platformApproval'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'arbitrationBy'?: string | null;
    /**
     * 
     * @type {Array<ParcelRead>}
     * @memberof DisputeRead
     */
    'parcels': Array<ParcelRead>;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'updatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeRead
     */
    'iri'?: string;
    /**
     * 
     * @type {number}
     * @memberof DisputeRead
     */
    'messageCount'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum DisputeReadStatusEnum {
    Created = 'CREATED',
    Submitted = 'SUBMITTED',
    Opened = 'OPENED',
    Abandoned = 'ABANDONED',
    Pending = 'PENDING',
    Objected = 'OBJECTED',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Returned = 'RETURNED',
    Dismissed = 'DISMISSED',
    Resolved = 'RESOLVED'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadIssueTypeEnum {
    NotAsDescribed = 'NOT_AS_DESCRIBED',
    DoesNotWork = 'DOES_NOT_WORK',
    IsIncomplete = 'IS_INCOMPLETE',
    DeliveryIssue = 'DELIVERY_ISSUE',
    AllegedFraud = 'ALLEGED_FRAUD'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadIssueInDescriptionTypeEnum {
    WrongColour = 'WRONG_COLOUR',
    DamagedOrUsed = 'DAMAGED_OR_USED',
    IncorrectFormatOrSize = 'INCORRECT_FORMAT_OR_SIZE',
    DifferentMaterial = 'DIFFERENT_MATERIAL',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadComplainantStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadInferredStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadRecommendedSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadChosenSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadCounterSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeReadPlatformSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}

/**
 * Access directly our resolution center without having used the safe-checkout feature.
 * @export
 * @interface DisputeUpdate
 */
export interface DisputeUpdate {
    /**
     * The dispute may concern only PART of the package. Specify it there.
     * @type {number}
     * @memberof DisputeUpdate
     */
    'itemCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeUpdate
     */
    'issueType': DisputeUpdateIssueTypeEnum;
    /**
     * To be set only in conjunction of issueType = NOT_AS_DESCRIBED.
     * @type {string}
     * @memberof DisputeUpdate
     */
    'issueInDescriptionType'?: DisputeUpdateIssueInDescriptionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DisputeUpdate
     */
    'issueDetails'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeUpdate
     */
    'complainantStake': DisputeUpdateComplainantStakeEnum;
    /**
     * 
     * @type {string}
     * @memberof DisputeUpdate
     */
    'chosenSolution'?: DisputeUpdateChosenSolutionEnum;
    /**
     * 
     * @type {number}
     * @memberof DisputeUpdate
     */
    'chosenPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DisputeUpdate
     */
    'counterSolution'?: DisputeUpdateCounterSolutionEnum;
    /**
     * 
     * @type {number}
     * @memberof DisputeUpdate
     */
    'counterPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeUpdate
     */
    'complainantApproval'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeUpdate
     */
    'sellerApproval': boolean | null;
}

/**
    * @export
    * @enum {string}
    */
export enum DisputeUpdateIssueTypeEnum {
    NotAsDescribed = 'NOT_AS_DESCRIBED',
    DoesNotWork = 'DOES_NOT_WORK',
    IsIncomplete = 'IS_INCOMPLETE',
    DeliveryIssue = 'DELIVERY_ISSUE',
    AllegedFraud = 'ALLEGED_FRAUD'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeUpdateIssueInDescriptionTypeEnum {
    WrongColour = 'WRONG_COLOUR',
    DamagedOrUsed = 'DAMAGED_OR_USED',
    IncorrectFormatOrSize = 'INCORRECT_FORMAT_OR_SIZE',
    DifferentMaterial = 'DIFFERENT_MATERIAL',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeUpdateComplainantStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeUpdateChosenSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum DisputeUpdateCounterSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface DisputeWrite
 */
export interface DisputeWrite {
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof DisputeWrite
     */
    'redirectUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface EvaluationRead
 */
export interface EvaluationRead {
    /**
     * 
     * @type {number}
     * @memberof EvaluationRead
     */
    'rating'?: number;
    /**
     * 
     * @type {string}
     * @memberof EvaluationRead
     */
    'comment'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EvaluationRead
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface EvaluationWrite
 */
export interface EvaluationWrite {
    /**
     * 
     * @type {number}
     * @memberof EvaluationWrite
     */
    'rating'?: number;
    /**
     * 
     * @type {string}
     * @memberof EvaluationWrite
     */
    'comment'?: string | null;
}
/**
 * 
 * @export
 * @interface Evidence
 */
export interface Evidence {
    /**
     * 
     * @type {number}
     * @memberof Evidence
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Evidence
     */
    'dispute'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Evidence
     */
    'owner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Evidence
     */
    'status': EvidenceStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Evidence
     */
    'media'?: string | null;
    /**
     * Description of what the evidence actually is.
     * @type {string}
     * @memberof Evidence
     */
    'additionalInformation'?: string;
    /**
     * 
     * @type {string}
     * @memberof Evidence
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Evidence
     */
    'updatedAt'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum EvidenceStatusEnum {
    Submitted = 'SUBMITTED',
    Correlated = 'CORRELATED',
    Unrelated = 'UNRELATED',
    Pending = 'PENDING',
    Tempered = 'TEMPERED',
    Rejected = 'REJECTED'
}

/**
 * 
 * @export
 * @interface EvidenceRead
 */
export interface EvidenceRead {
    /**
     * 
     * @type {number}
     * @memberof EvidenceRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EvidenceRead
     */
    'status': EvidenceReadStatusEnum;
    /**
     * 
     * @type {EvidenceReadMedia}
     * @memberof EvidenceRead
     */
    'media'?: EvidenceReadMedia | null;
    /**
     * Description of what the evidence actually is.
     * @type {string}
     * @memberof EvidenceRead
     */
    'additionalInformation'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceRead
     */
    'updatedAt'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum EvidenceReadStatusEnum {
    Submitted = 'SUBMITTED',
    Correlated = 'CORRELATED',
    Unrelated = 'UNRELATED',
    Pending = 'PENDING',
    Tempered = 'TEMPERED',
    Rejected = 'REJECTED'
}

/**
 * 
 * @export
 * @interface EvidenceReadMedia
 */
export interface EvidenceReadMedia {
    /**
     * 
     * @type {string}
     * @memberof EvidenceReadMedia
     */
    'publicUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface EvidenceWrite
 */
export interface EvidenceWrite {
    /**
     * Description of what the evidence actually is.
     * @type {string}
     * @memberof EvidenceWrite
     */
    'additionalInformation'?: string;
}
/**
 * 
 * @export
 * @interface Media
 */
export interface Media {
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'extension': string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'filename': string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'publicUrl'?: string | null;
    /**
     * 
     * @type {File}
     * @memberof Media
     */
    'file'?: File | null;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'b64EncodedTmpFile'?: string | null;
    /**
     * Associated 374x374 pixels small thumbnail
     * @type {string}
     * @memberof Media
     */
    'thumbnail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'original'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'owner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'thumbnailUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface MediaRead
 */
export interface MediaRead {
    /**
     * 
     * @type {string}
     * @memberof MediaRead
     */
    'publicUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {number}
     * @memberof Message
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'agent'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'to'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'body': string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * 
     * @type {number}
     * @memberof Metadata
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface MetadataIndependentWrite
 */
export interface MetadataIndependentWrite {
    /**
     * 
     * @type {string}
     * @memberof MetadataIndependentWrite
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof MetadataIndependentWrite
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface MetadataRead
 */
export interface MetadataRead {
    /**
     * 
     * @type {string}
     * @memberof MetadataRead
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof MetadataRead
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface MetadataUpdate
 */
export interface MetadataUpdate {
    /**
     * 
     * @type {string}
     * @memberof MetadataUpdate
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof MetadataUpdate
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface MetadataWrite
 */
export interface MetadataWrite {
    /**
     * 
     * @type {string}
     * @memberof MetadataWrite
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof MetadataWrite
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'type': NotificationTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Notification
     */
    'seen'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'createdAt'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum NotificationTypeEnum {
    DisputeStateUpdate = 'DISPUTE_STATE_UPDATE',
    MessageSent = 'MESSAGE_SENT',
    DisputeSettlement = 'DISPUTE_SETTLEMENT',
    DisputeArbitrationRequired = 'DISPUTE_ARBITRATION_REQUIRED',
    DisputeResolved = 'DISPUTE_RESOLVED'
}

/**
 * 
 * @export
 * @interface NotificationRead
 */
export interface NotificationRead {
    /**
     * 
     * @type {string}
     * @memberof NotificationRead
     */
    'type': NotificationReadTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationRead
     */
    'seen'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NotificationRead
     */
    'createdAt'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum NotificationReadTypeEnum {
    DisputeStateUpdate = 'DISPUTE_STATE_UPDATE',
    MessageSent = 'MESSAGE_SENT',
    DisputeSettlement = 'DISPUTE_SETTLEMENT',
    DisputeArbitrationRequired = 'DISPUTE_ARBITRATION_REQUIRED',
    DisputeResolved = 'DISPUTE_RESOLVED'
}

/**
 * 
 * @export
 * @interface NotificationUpdate
 */
export interface NotificationUpdate {
    /**
     * 
     * @type {boolean}
     * @memberof NotificationUpdate
     */
    'seen'?: boolean;
}
/**
 * 
 * @export
 * @interface Offer
 */
export interface Offer {
    /**
     * 
     * @type {number}
     * @memberof Offer
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'ulid': string;
    /**
     * If specified, there would be not need for you to fill-in details. Must be accessible over WAN.
     * @type {string}
     * @memberof Offer
     */
    'publicUrl'?: string | null;
    /**
     * Mean that the generated url cannot be accessed without a generated token for a Persona. Disallow external registration.
     * @type {boolean}
     * @memberof Offer
     */
    'enforcePersonaAuth': boolean;
    /**
     * Override YOUR platform fees for that particular Offer.
     * @type {number}
     * @memberof Offer
     */
    'overrideRateCommissionSafeCheckout': number;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof Offer
     */
    'redirectUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'url': string | null;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'organization'?: string | null;
    /**
     * If the seller is actually YOUR organization, set it to NULL.
     * @type {string}
     * @memberof Offer
     */
    'seller'?: string | null;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {string}
     * @memberof Offer
     */
    'nature': OfferNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Offer
     */
    'unitPrice'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'currencyCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Offer
     */
    'itemCount': number;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'condition': OfferConditionEnum;
    /**
     * 
     * @type {number}
     * @memberof Offer
     */
    'weightInGram'?: number | null;
    /**
     * That toggle allows the seller to propose shipping for its item. If set in conjunction of shippingCarrier, the label will be automatically generated. Also, it will restrict the carrier to the limited subset defined.
     * @type {boolean}
     * @memberof Offer
     */
    'shippingAllowed': boolean;
    /**
     * Enable both parties to finalize the transaction in person rather than using delivery. A QR Code must be scanned by the seller once the buyer claims the product.
     * @type {boolean}
     * @memberof Offer
     */
    'handDeliveryAllowed': boolean;
    /**
     * If you wish to enable automated shipping label generation through a specific provider, specify it there.
     * @type {Array<string>}
     * @memberof Offer
     */
    'shippingCarriers': Array<OfferShippingCarriersEnum>;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'eanCode'?: string | null;
    /**
     * Set this flag to false to forbid a potential buyer to acquire this item separately.          This is only useful in a BulkOffer context.
     * @type {boolean}
     * @memberof Offer
     */
    'canBeSoldSeparately': boolean;
    /**
     * 
     * @type {Array<Metadata>}
     * @memberof Offer
     */
    'metadata': Array<Metadata>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Offer
     */
    'medias': Array<string>;
    /**
     * 
     * @type {Array<View>}
     * @memberof Offer
     */
    'views': Array<View>;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'updatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'iri'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferShippingCarriersEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay'
}

/**
 * An Offer object represent a public listening
 * @export
 * @interface OfferCollectionRead
 */
export interface OfferCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'ulid': string;
    /**
     * If specified, there would be not need for you to fill-in details. Must be accessible over WAN.
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'publicUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof OfferCollectionRead
     */
    'unitPrice'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'currencyCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferCollectionRead
     */
    'itemCount': number;
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'condition': OfferCollectionReadConditionEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferCollectionReadConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}

/**
 * An Offer object represent a public listening
 * @export
 * @interface OfferIndependentWrite
 */
export interface OfferIndependentWrite {
    /**
     * If specified, there would be not need for you to fill-in details. Must be accessible over WAN.
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'publicUrl'?: string | null;
    /**
     * 
     * @type {OfferIndependentWriteSeller}
     * @memberof OfferIndependentWrite
     */
    'seller'?: OfferIndependentWriteSeller | null;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'nature': OfferIndependentWriteNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferIndependentWrite
     */
    'unitPrice'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'currencyCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferIndependentWrite
     */
    'itemCount': number;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'condition': OfferIndependentWriteConditionEnum;
    /**
     * 
     * @type {number}
     * @memberof OfferIndependentWrite
     */
    'weightInGram'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'eanCode'?: string | null;
    /**
     * Set this flag to false to forbid a potential buyer to acquire this item separately.          This is only useful in a BulkOffer context.
     * @type {boolean}
     * @memberof OfferIndependentWrite
     */
    'canBeSoldSeparately': boolean;
    /**
     * 
     * @type {Array<MetadataIndependentWrite>}
     * @memberof OfferIndependentWrite
     */
    'metadata': Array<MetadataIndependentWrite>;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferIndependentWriteNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferIndependentWriteConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}

/**
 * If the seller is actually YOUR organization, set it to NULL.
 * @export
 * @interface OfferIndependentWriteSeller
 */
export interface OfferIndependentWriteSeller {
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWriteSeller
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWriteSeller
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWriteSeller
     */
    'gender'?: OfferIndependentWriteSellerGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWriteSeller
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof OfferIndependentWriteSeller
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWriteSeller
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWriteSeller
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {PersonaIndependentWriteAddress}
     * @memberof OfferIndependentWriteSeller
     */
    'address'?: PersonaIndependentWriteAddress | null;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof OfferIndependentWriteSeller
     */
    'externalPurchaseCount'?: number;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof OfferIndependentWriteSeller
     */
    'externalSellCount'?: number;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<MetadataIndependentWrite>}
     * @memberof OfferIndependentWriteSeller
     */
    'metadata': Array<MetadataIndependentWrite>;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferIndependentWriteSellerGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * An Offer object represent a public listening
 * @export
 * @interface OfferPostCreationRead
 */
export interface OfferPostCreationRead {
    /**
     * 
     * @type {string}
     * @memberof OfferPostCreationRead
     */
    'url': string | null;
}
/**
 * An Offer object represent a public listening
 * @export
 * @interface OfferRead
 */
export interface OfferRead {
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'ulid': string;
    /**
     * If specified, there would be not need for you to fill-in details. Must be accessible over WAN.
     * @type {string}
     * @memberof OfferRead
     */
    'publicUrl'?: string | null;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {string}
     * @memberof OfferRead
     */
    'nature': OfferReadNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferRead
     */
    'unitPrice'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'currencyCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferRead
     */
    'itemCount': number;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'condition': OfferReadConditionEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferReadNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferReadConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}

/**
 * 
 * @export
 * @interface OfferUpdate
 */
export interface OfferUpdate {
    /**
     * If specified, there would be not need for you to fill-in details. Must be accessible over WAN.
     * @type {string}
     * @memberof OfferUpdate
     */
    'publicUrl'?: string | null;
    /**
     * Mean that the generated url cannot be accessed without a generated token for a Persona. Disallow external registration.
     * @type {boolean}
     * @memberof OfferUpdate
     */
    'enforcePersonaAuth': boolean;
    /**
     * Override YOUR platform fees for that particular Offer.
     * @type {number}
     * @memberof OfferUpdate
     */
    'overrideRateCommissionSafeCheckout': number;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof OfferUpdate
     */
    'redirectUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferUpdate
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferUpdate
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferUpdate
     */
    'unitPrice'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OfferUpdate
     */
    'currencyCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferUpdate
     */
    'itemCount': number;
    /**
     * 
     * @type {number}
     * @memberof OfferUpdate
     */
    'weightInGram'?: number | null;
    /**
     * That toggle allows the seller to propose shipping for its item. If set in conjunction of shippingCarrier, the label will be automatically generated. Also, it will restrict the carrier to the limited subset defined.
     * @type {boolean}
     * @memberof OfferUpdate
     */
    'shippingAllowed': boolean;
    /**
     * Enable both parties to finalize the transaction in person rather than using delivery. A QR Code must be scanned by the seller once the buyer claims the product.
     * @type {boolean}
     * @memberof OfferUpdate
     */
    'handDeliveryAllowed': boolean;
    /**
     * If you wish to enable automated shipping label generation through a specific provider, specify it there.
     * @type {Array<string>}
     * @memberof OfferUpdate
     */
    'shippingCarriers': Array<OfferUpdateShippingCarriersEnum>;
    /**
     * 
     * @type {string}
     * @memberof OfferUpdate
     */
    'eanCode'?: string | null;
    /**
     * Set this flag to false to forbid a potential buyer to acquire this item separately.          This is only useful in a BulkOffer context.
     * @type {boolean}
     * @memberof OfferUpdate
     */
    'canBeSoldSeparately': boolean;
    /**
     * 
     * @type {Array<MetadataUpdate>}
     * @memberof OfferUpdate
     */
    'metadata': Array<MetadataUpdate>;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferUpdateShippingCarriersEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay'
}

/**
 * 
 * @export
 * @interface OfferWrite
 */
export interface OfferWrite {
    /**
     * If specified, there would be not need for you to fill-in details. Must be accessible over WAN.
     * @type {string}
     * @memberof OfferWrite
     */
    'publicUrl'?: string | null;
    /**
     * Mean that the generated url cannot be accessed without a generated token for a Persona. Disallow external registration.
     * @type {boolean}
     * @memberof OfferWrite
     */
    'enforcePersonaAuth': boolean;
    /**
     * Override YOUR platform fees for that particular Offer.
     * @type {number}
     * @memberof OfferWrite
     */
    'overrideRateCommissionSafeCheckout': number;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof OfferWrite
     */
    'redirectUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferWrite
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferWrite
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferWrite
     */
    'unitPrice'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OfferWrite
     */
    'currencyCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferWrite
     */
    'itemCount': number;
    /**
     * 
     * @type {string}
     * @memberof OfferWrite
     */
    'condition': OfferWriteConditionEnum;
    /**
     * 
     * @type {number}
     * @memberof OfferWrite
     */
    'weightInGram'?: number | null;
    /**
     * That toggle allows the seller to propose shipping for its item. If set in conjunction of shippingCarrier, the label will be automatically generated. Also, it will restrict the carrier to the limited subset defined.
     * @type {boolean}
     * @memberof OfferWrite
     */
    'shippingAllowed': boolean;
    /**
     * Enable both parties to finalize the transaction in person rather than using delivery. A QR Code must be scanned by the seller once the buyer claims the product.
     * @type {boolean}
     * @memberof OfferWrite
     */
    'handDeliveryAllowed': boolean;
    /**
     * If you wish to enable automated shipping label generation through a specific provider, specify it there.
     * @type {Array<string>}
     * @memberof OfferWrite
     */
    'shippingCarriers': Array<OfferWriteShippingCarriersEnum>;
    /**
     * 
     * @type {string}
     * @memberof OfferWrite
     */
    'eanCode'?: string | null;
    /**
     * Set this flag to false to forbid a potential buyer to acquire this item separately.          This is only useful in a BulkOffer context.
     * @type {boolean}
     * @memberof OfferWrite
     */
    'canBeSoldSeparately': boolean;
    /**
     * 
     * @type {Array<MetadataWrite>}
     * @memberof OfferWrite
     */
    'metadata': Array<MetadataWrite>;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferWriteConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferWriteShippingCarriersEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay'
}

/**
 * 
 * @export
 * @interface OrganizationRead
 */
export interface OrganizationRead {
    /**
     * 
     * @type {number}
     * @memberof OrganizationRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationRead
     */
    'domainVerified': boolean;
}
/**
 * 
 * @export
 * @interface OrganizationSupportRead
 */
export interface OrganizationSupportRead {
    /**
     * 
     * @type {number}
     * @memberof OrganizationSupportRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSupportRead
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationUpdate
 */
export interface OrganizationUpdate {
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'vatNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'commercialRegistryNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'webhookUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'customBaseUrl'?: string | null;
    /**
     * 
     * @type {OrganizationUpdateBillingAddress}
     * @memberof OrganizationUpdate
     */
    'billingAddress'?: OrganizationUpdateBillingAddress | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'primaryColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'secondaryColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'accentColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'errorColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'infoColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'successColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'warningColor'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationUpdate
     */
    'directNotificationToggle': boolean;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'anonymityLevel': OrganizationUpdateAnonymityLevelEnum;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationUpdate
     */
    'flatRateEnabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof OrganizationUpdate
     */
    'rateCommissionSafeCheckout': number;
}

/**
    * @export
    * @enum {string}
    */
export enum OrganizationUpdateAnonymityLevelEnum {
    Complete = 'COMPLETE',
    PartialFirstName = 'PARTIAL_FIRST_NAME',
    Transparent = 'TRANSPARENT'
}

/**
 * 
 * @export
 * @interface OrganizationUpdateBillingAddress
 */
export interface OrganizationUpdateBillingAddress {
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdateBillingAddress
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdateBillingAddress
     */
    'countryCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdateBillingAddress
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdateBillingAddress
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdateBillingAddress
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdateBillingAddress
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdateBillingAddress
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdateBillingAddress
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdateBillingAddress
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * 
 * @export
 * @interface OrganizationWrite
 */
export interface OrganizationWrite {
    /**
     * 
     * @type {number}
     * @memberof OrganizationWrite
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWrite
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWrite
     */
    'vatNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWrite
     */
    'commercialRegistryNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWrite
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {OrganizationWriteBillingAddress}
     * @memberof OrganizationWrite
     */
    'billingAddress'?: OrganizationWriteBillingAddress | null;
}
/**
 * 
 * @export
 * @interface OrganizationWriteBillingAddress
 */
export interface OrganizationWriteBillingAddress {
    /**
     * 
     * @type {string}
     * @memberof OrganizationWriteBillingAddress
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWriteBillingAddress
     */
    'countryCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWriteBillingAddress
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWriteBillingAddress
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWriteBillingAddress
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWriteBillingAddress
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWriteBillingAddress
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWriteBillingAddress
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWriteBillingAddress
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * 
 * @export
 * @interface Parcel
 */
export interface Parcel {
    /**
     * 
     * @type {number}
     * @memberof Parcel
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'carrier': ParcelCarrierEnum;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'identifier': string;
    /**
     * 
     * @type {number}
     * @memberof Parcel
     */
    'price'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'status'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'dispute'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'transaction'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'updatedAt'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ParcelCarrierEnum {
    SwissPost = 'SwissPost',
    MondialRelay = 'MondialRelay',
    Colissimo = 'Colissimo',
    Dhl = 'Dhl',
    Chronopost = 'Chronopost',
    ColisPrive = 'ColisPrive',
    Dpd = 'Dpd',
    Ups = 'Ups',
    FedEx = 'FedEx',
    RelaisColis = 'RelaisColis'
}

/**
 * 
 * @export
 * @interface ParcelIndependentWrite
 */
export interface ParcelIndependentWrite {
    /**
     * 
     * @type {string}
     * @memberof ParcelIndependentWrite
     */
    'carrier': ParcelIndependentWriteCarrierEnum;
    /**
     * 
     * @type {string}
     * @memberof ParcelIndependentWrite
     */
    'identifier': string;
    /**
     * 
     * @type {number}
     * @memberof ParcelIndependentWrite
     */
    'price'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ParcelIndependentWrite
     */
    'currency'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ParcelIndependentWriteCarrierEnum {
    SwissPost = 'SwissPost',
    MondialRelay = 'MondialRelay',
    Colissimo = 'Colissimo',
    Dhl = 'Dhl',
    Chronopost = 'Chronopost',
    ColisPrive = 'ColisPrive',
    Dpd = 'Dpd',
    Ups = 'Ups',
    FedEx = 'FedEx',
    RelaisColis = 'RelaisColis'
}

/**
 * 
 * @export
 * @interface ParcelRead
 */
export interface ParcelRead {
    /**
     * 
     * @type {string}
     * @memberof ParcelRead
     */
    'carrier': ParcelReadCarrierEnum;
    /**
     * 
     * @type {string}
     * @memberof ParcelRead
     */
    'identifier': string;
    /**
     * 
     * @type {number}
     * @memberof ParcelRead
     */
    'price'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ParcelRead
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParcelRead
     */
    'status'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParcelRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParcelRead
     */
    'updatedAt'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ParcelReadCarrierEnum {
    SwissPost = 'SwissPost',
    MondialRelay = 'MondialRelay',
    Colissimo = 'Colissimo',
    Dhl = 'Dhl',
    Chronopost = 'Chronopost',
    ColisPrive = 'ColisPrive',
    Dpd = 'Dpd',
    Ups = 'Ups',
    FedEx = 'FedEx',
    RelaisColis = 'RelaisColis'
}

/**
 * 
 * @export
 * @interface ParcelWrite
 */
export interface ParcelWrite {
    /**
     * 
     * @type {string}
     * @memberof ParcelWrite
     */
    'carrier': ParcelWriteCarrierEnum;
    /**
     * 
     * @type {string}
     * @memberof ParcelWrite
     */
    'identifier': string;
    /**
     * 
     * @type {number}
     * @memberof ParcelWrite
     */
    'price'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ParcelWrite
     */
    'currency'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ParcelWriteCarrierEnum {
    SwissPost = 'SwissPost',
    MondialRelay = 'MondialRelay',
    Colissimo = 'Colissimo',
    Dhl = 'Dhl',
    Chronopost = 'Chronopost',
    ColisPrive = 'ColisPrive',
    Dpd = 'Dpd',
    Ups = 'Ups',
    FedEx = 'FedEx',
    RelaisColis = 'RelaisColis'
}

/**
 * 
 * @export
 * @interface Persona
 */
export interface Persona {
    /**
     * 
     * @type {number}
     * @memberof Persona
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'captcha'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'organization'?: string | null;
    /**
     * The URL you wish that Persona to go to without additional MFA. The URL MUST concern that Persona.
     * @type {string}
     * @memberof Persona
     */
    'targetUrl'?: string | null;
    /**
     * Url that is able to bypass MFA for a single user. Please note that this should not be shared between the complainant and the seller or anyone external to them.
     * @type {string}
     * @memberof Persona
     */
    'authUrl'?: string | null;
    /**
     * This authenticated-URL cannot be renewed, you will have to re-create one each time. Typically valid for a single hour.
     * @type {string}
     * @memberof Persona
     */
    'expireAt'?: string | null;
    /**
     * The hashed password
     * @type {string}
     * @memberof Persona
     */
    'password'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'plainPassword'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'gender'?: PersonaGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof Persona
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {PersonaAddress}
     * @memberof Persona
     */
    'address'?: PersonaAddress | null;
    /**
     * We sort Persona into three distinct risks\' category. This is inferred from the riskScore.
     * @type {string}
     * @memberof Persona
     */
    'riskLevel'?: PersonaRiskLevelEnum;
    /**
     * That score is regularly updated, each action taken can potentially update that value. A value close to zero mean zero risk and close to a hundred mean risky.
     * @type {number}
     * @memberof Persona
     */
    'riskScore'?: number | null;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof Persona
     */
    'externalPurchaseCount'?: number;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof Persona
     */
    'externalSellCount'?: number;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<Metadata>}
     * @memberof Persona
     */
    'metadata': Array<Metadata>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Persona
     */
    'offers': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Persona
     */
    'purchases': Array<string>;
    /**
     * 
     * @type {Array<PersonaToken>}
     * @memberof Persona
     */
    'tokens': Array<PersonaToken>;
    /**
     * 
     * @type {Array<View>}
     * @memberof Persona
     */
    'views': Array<View>;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'updatedAt'?: string | null;
    /**
     * Issued Offers count owned by a given Persona
     * @type {number}
     * @memberof Persona
     */
    'offerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Persona
     */
    'purchaseCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Persona
     */
    'roles'?: Array<string>;
    /**
     * Either email or the mobile phone number
     * @type {string}
     * @memberof Persona
     */
    'userIdentifier'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}
/**
    * @export
    * @enum {string}
    */
export enum PersonaRiskLevelEnum {
    Weak = 'WEAK',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}

/**
 * Always the Shipping address. Thus enabling automated package returns.
 * @export
 * @interface PersonaAddress
 */
export interface PersonaAddress {
    /**
     * 
     * @type {number}
     * @memberof PersonaAddress
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddress
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddress
     */
    'countryCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddress
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddress
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddress
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddress
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddress
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddress
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddress
     */
    'gateOrPortalOrInboxCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddress
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddress
     */
    'updatedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaAuthReturn
 */
export interface PersonaAuthReturn {
    /**
     * Url that is able to bypass MFA for a single user. Please note that this should not be shared between the complainant and the seller or anyone external to them.
     * @type {string}
     * @memberof PersonaAuthReturn
     */
    'authUrl'?: string | null;
    /**
     * This authenticated-URL cannot be renewed, you will have to re-create one each time. Typically valid for a single hour.
     * @type {string}
     * @memberof PersonaAuthReturn
     */
    'expireAt'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaCollectionRead
 */
export interface PersonaCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof PersonaCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'email'?: string | null;
    /**
     * We sort Persona into three distinct risks\' category. This is inferred from the riskScore.
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'riskLevel'?: PersonaCollectionReadRiskLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'updatedAt'?: string | null;
    /**
     * Issued Offers count owned by a given Persona
     * @type {number}
     * @memberof PersonaCollectionRead
     */
    'offerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PersonaCollectionRead
     */
    'purchaseCount'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaCollectionReadRiskLevelEnum {
    Weak = 'WEAK',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface PersonaExternalAuth
 */
export interface PersonaExternalAuth {
    /**
     * 
     * @type {string}
     * @memberof PersonaExternalAuth
     */
    'captcha'?: string | null;
    /**
     * The URL you wish that Persona to go to without additional MFA. The URL MUST concern that Persona.
     * @type {string}
     * @memberof PersonaExternalAuth
     */
    'targetUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaExternalAuth
     */
    'plainPassword'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaExternalAuth
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaExternalAuth
     */
    'mobilePhoneNumber'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaIndependentWrite
 */
export interface PersonaIndependentWrite {
    /**
     * 
     * @type {string}
     * @memberof PersonaIndependentWrite
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaIndependentWrite
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaIndependentWrite
     */
    'gender'?: PersonaIndependentWriteGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof PersonaIndependentWrite
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof PersonaIndependentWrite
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaIndependentWrite
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaIndependentWrite
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {PersonaIndependentWriteAddress}
     * @memberof PersonaIndependentWrite
     */
    'address'?: PersonaIndependentWriteAddress | null;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof PersonaIndependentWrite
     */
    'externalPurchaseCount'?: number;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof PersonaIndependentWrite
     */
    'externalSellCount'?: number;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<MetadataIndependentWrite>}
     * @memberof PersonaIndependentWrite
     */
    'metadata': Array<MetadataIndependentWrite>;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaIndependentWriteGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * Always the Shipping address. Thus enabling automated package returns.
 * @export
 * @interface PersonaIndependentWriteAddress
 */
export interface PersonaIndependentWriteAddress {
    /**
     * 
     * @type {string}
     * @memberof PersonaIndependentWriteAddress
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaIndependentWriteAddress
     */
    'countryCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaIndependentWriteAddress
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaIndependentWriteAddress
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaIndependentWriteAddress
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaIndependentWriteAddress
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaIndependentWriteAddress
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaIndependentWriteAddress
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaIndependentWriteAddress
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaPostAuthRead
 */
export interface PersonaPostAuthRead {
    /**
     * Url that is able to bypass MFA for a single user. Please note that this should not be shared between the complainant and the seller or anyone external to them.
     * @type {string}
     * @memberof PersonaPostAuthRead
     */
    'authUrl'?: string | null;
    /**
     * This authenticated-URL cannot be renewed, you will have to re-create one each time. Typically valid for a single hour.
     * @type {string}
     * @memberof PersonaPostAuthRead
     */
    'expireAt'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaRead
 */
export interface PersonaRead {
    /**
     * 
     * @type {number}
     * @memberof PersonaRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'gender'?: PersonaReadGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof PersonaRead
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {PersonaReadAddress}
     * @memberof PersonaRead
     */
    'address'?: PersonaReadAddress | null;
    /**
     * We sort Persona into three distinct risks\' category. This is inferred from the riskScore.
     * @type {string}
     * @memberof PersonaRead
     */
    'riskLevel'?: PersonaReadRiskLevelEnum;
    /**
     * That score is regularly updated, each action taken can potentially update that value. A value close to zero mean zero risk and close to a hundred mean risky.
     * @type {number}
     * @memberof PersonaRead
     */
    'riskScore'?: number | null;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof PersonaRead
     */
    'externalPurchaseCount'?: number;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof PersonaRead
     */
    'externalSellCount'?: number;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<MetadataRead>}
     * @memberof PersonaRead
     */
    'metadata': Array<MetadataRead>;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'updatedAt'?: string | null;
    /**
     * Issued Offers count owned by a given Persona
     * @type {number}
     * @memberof PersonaRead
     */
    'offerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PersonaRead
     */
    'purchaseCount'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaReadGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}
/**
    * @export
    * @enum {string}
    */
export enum PersonaReadRiskLevelEnum {
    Weak = 'WEAK',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}

/**
 * Always the Shipping address. Thus enabling automated package returns.
 * @export
 * @interface PersonaReadAddress
 */
export interface PersonaReadAddress {
    /**
     * 
     * @type {string}
     * @memberof PersonaReadAddress
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaReadAddress
     */
    'countryCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaReadAddress
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaReadAddress
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaReadAddress
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaReadAddress
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaReadAddress
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaReadAddress
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaReadAddress
     */
    'gateOrPortalOrInboxCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaReadAddress
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaReadAddress
     */
    'updatedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaRegister
 */
export interface PersonaRegister {
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'captcha'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'plainPassword'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'gender'?: PersonaRegisterGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof PersonaRegister
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaRegister
     */
    'mobilePhoneNumber'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaRegisterGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * 
 * @export
 * @interface PersonaToken
 */
export interface PersonaToken {
    /**
     * 
     * @type {number}
     * @memberof PersonaToken
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PersonaToken
     */
    'persona': string;
    /**
     * Optional limitation on a specific object.
     * @type {string}
     * @memberof PersonaToken
     */
    'objectId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaToken
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaToken
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaToken
     */
    'expireAt': string;
}
/**
 * 
 * @export
 * @interface PersonaTokenWrite
 */
export interface PersonaTokenWrite {
    /**
     * The URL you wish that Persona to go to without additional MFA. The URL MUST concern that Persona.
     * @type {string}
     * @memberof PersonaTokenWrite
     */
    'targetUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaUpdate
 */
export interface PersonaUpdate {
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'gender'?: PersonaUpdateGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof PersonaUpdate
     */
    'language'?: string | null;
    /**
     * 
     * @type {PersonaUpdateAddress}
     * @memberof PersonaUpdate
     */
    'address'?: PersonaUpdateAddress | null;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof PersonaUpdate
     */
    'externalPurchaseCount'?: number;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof PersonaUpdate
     */
    'externalSellCount'?: number;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<MetadataUpdate>}
     * @memberof PersonaUpdate
     */
    'metadata': Array<MetadataUpdate>;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaUpdateGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * Always the Shipping address. Thus enabling automated package returns.
 * @export
 * @interface PersonaUpdateAddress
 */
export interface PersonaUpdateAddress {
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdateAddress
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdateAddress
     */
    'countryCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdateAddress
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdateAddress
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdateAddress
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdateAddress
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdateAddress
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdateAddress
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdateAddress
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaWrite
 */
export interface PersonaWrite {
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'gender'?: PersonaWriteGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof PersonaWrite
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {PersonaWriteAddress}
     * @memberof PersonaWrite
     */
    'address'?: PersonaWriteAddress | null;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<MetadataWrite>}
     * @memberof PersonaWrite
     */
    'metadata': Array<MetadataWrite>;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaWriteGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * Always the Shipping address. Thus enabling automated package returns.
 * @export
 * @interface PersonaWriteAddress
 */
export interface PersonaWriteAddress {
    /**
     * 
     * @type {string}
     * @memberof PersonaWriteAddress
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaWriteAddress
     */
    'countryCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaWriteAddress
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaWriteAddress
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaWriteAddress
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaWriteAddress
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaWriteAddress
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaWriteAddress
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaWriteAddress
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * 
 * @export
 * @interface TransactionCollectionRead
 */
export interface TransactionCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof TransactionCollectionRead
     */
    'ulid': string;
    /**
     * 
     * @type {OfferCollectionRead}
     * @memberof TransactionCollectionRead
     */
    'offer'?: OfferCollectionRead;
}
/**
 * 
 * @export
 * @interface TransactionIndependentWrite
 */
export interface TransactionIndependentWrite {
    /**
     * 
     * @type {OfferIndependentWrite}
     * @memberof TransactionIndependentWrite
     */
    'offer'?: OfferIndependentWrite;
    /**
     * 
     * @type {PersonaIndependentWrite}
     * @memberof TransactionIndependentWrite
     */
    'buyer'?: PersonaIndependentWrite;
    /**
     * 
     * @type {number}
     * @memberof TransactionIndependentWrite
     */
    'fees'?: number | null;
    /**
     * 
     * @type {Array<MetadataIndependentWrite>}
     * @memberof TransactionIndependentWrite
     */
    'metadata': Array<MetadataIndependentWrite>;
    /**
     * 
     * @type {Array<ParcelIndependentWrite>}
     * @memberof TransactionIndependentWrite
     */
    'parcels': Array<ParcelIndependentWrite>;
}
/**
 * 
 * @export
 * @interface TransactionRead
 */
export interface TransactionRead {
    /**
     * 
     * @type {string}
     * @memberof TransactionRead
     */
    'ulid': string;
    /**
     * 
     * @type {OfferRead}
     * @memberof TransactionRead
     */
    'offer'?: OfferRead;
    /**
     * 
     * @type {string}
     * @memberof TransactionRead
     */
    'buyer'?: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionRead
     */
    'fees'?: number | null;
    /**
     * 
     * @type {Array<MetadataRead>}
     * @memberof TransactionRead
     */
    'metadata': Array<MetadataRead>;
    /**
     * 
     * @type {Array<ParcelRead>}
     * @memberof TransactionRead
     */
    'parcels': Array<ParcelRead>;
}
/**
 * 
 * @export
 * @interface UnprocessableEntity
 */
export interface UnprocessableEntity {
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntity
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntity
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntity
     */
    'detail'?: string;
    /**
     * 
     * @type {Array<UnprocessableEntityViolationsInner>}
     * @memberof UnprocessableEntity
     */
    'violations'?: Array<UnprocessableEntityViolationsInner>;
}
/**
 * 
 * @export
 * @interface UnprocessableEntityViolationsInner
 */
export interface UnprocessableEntityViolationsInner {
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntityViolationsInner
     */
    'propertyPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntityViolationsInner
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntityViolationsInner
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'captcha'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'birthday': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'roles': Array<string>;
    /**
     * The hashed password
     * @type {string}
     * @memberof User
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'plainPassword'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'intlPhoneNumber'?: string | null;
    /**
     * The originating country
     * @type {string}
     * @memberof User
     */
    'originCountry'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'preferredLanguage'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastSuccessfulLogIn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'emailVerificationCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'emailVerificationInput'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phoneVerificationCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phoneVerificationInput'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'avatar'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'notifications'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'medias'?: Array<string>;
    /**
     * 
     * @type {Array<View>}
     * @memberof User
     */
    'views': Array<View>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'consentMailNotification': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'consentMailAds': boolean;
    /**
     * 
     * @type {UserApi}
     * @memberof User
     */
    'api'?: UserApi | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'organization'?: string | null;
    /**
     * A visual identifier that represents this user.
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'salt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'userIdentifier'?: string;
}
/**
 * 
 * @export
 * @interface UserApi
 */
export interface UserApi {
    /**
     * 
     * @type {string}
     * @memberof UserApi
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof UserApi
     */
    'owner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserApi
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserApi
     */
    'secret'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserApi
     */
    'name'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof UserApi
     */
    'redirectUris'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof UserApi
     */
    'grants'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof UserApi
     */
    'scopes'?: Array<object>;
    /**
     * 
     * @type {boolean}
     * @memberof UserApi
     */
    'active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserApi
     */
    'allowPlainTextPkce'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserApi
     */
    'confidential'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserApi
     */
    'plainTextPkceAllowed'?: boolean;
}
/**
 * 
 * @export
 * @interface UserEmailValidationWrite
 */
export interface UserEmailValidationWrite {
    /**
     * 
     * @type {string}
     * @memberof UserEmailValidationWrite
     */
    'emailVerificationInput': string | null;
}
/**
 * 
 * @export
 * @interface UserPostRegisterRead
 */
export interface UserPostRegisterRead {
    /**
     * 
     * @type {string}
     * @memberof UserPostRegisterRead
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface UserSupportRead
 */
export interface UserSupportRead {
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'intlPhoneNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'lastSuccessfulLogIn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'avatar'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {UserSupportReadOrganization}
     * @memberof UserSupportRead
     */
    'organization'?: UserSupportReadOrganization | null;
}
/**
 * 
 * @export
 * @interface UserSupportReadOrganization
 */
export interface UserSupportReadOrganization {
    /**
     * 
     * @type {number}
     * @memberof UserSupportReadOrganization
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserSupportReadOrganization
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UserWrite
 */
export interface UserWrite {
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'captcha'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'publicName': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'roleInCompany': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'birthday'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'plainPassword': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'intlPhoneNumber'?: string | null;
    /**
     * The originating country
     * @type {string}
     * @memberof UserWrite
     */
    'originCountry': string;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'preferredLanguage': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserWrite
     */
    'consentMailNotification'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserWrite
     */
    'consentMailAds'?: boolean;
    /**
     * 
     * @type {UserWriteOrganization}
     * @memberof UserWrite
     */
    'organization'?: UserWriteOrganization | null;
}
/**
 * 
 * @export
 * @interface UserWriteOrganization
 */
export interface UserWriteOrganization {
    /**
     * 
     * @type {number}
     * @memberof UserWriteOrganization
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserWriteOrganization
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserWriteOrganization
     */
    'vatNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWriteOrganization
     */
    'commercialRegistryNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserWriteOrganization
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {OrganizationWriteBillingAddress}
     * @memberof UserWriteOrganization
     */
    'billingAddress'?: OrganizationWriteBillingAddress | null;
}
/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * 
     * @type {number}
     * @memberof View
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'ipAddress': string;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'offer'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'dispute'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'persona'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'user'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof View
     */
    'hitCount': number;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * 
     * @type {number}
     * @memberof Webhook
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'event'?: WebhookEventEnum;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'iri'?: string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'occurredAt'?: string;
    /**
     * 
     * @type {WebhookObject}
     * @memberof Webhook
     */
    'object'?: WebhookObject;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookEventEnum {
    DisputeOpened = 'dispute.opened',
    DisputeSubmitted = 'dispute.submitted',
    DisputeCreated = 'dispute.created',
    DisputeAbandoned = 'dispute.abandoned',
    DisputeSettlement = 'dispute.settlement',
    DisputeClosed = 'dispute.closed',
    DisputeExpired = 'dispute.expired',
    DisputeManualArbitrationRequired = 'dispute.manual_arbitration_required',
    DisputeUpdated = 'dispute.updated',
    OfferCreated = 'offer.created',
    OfferExpired = 'offer.expired',
    OfferUpdated = 'offer.updated',
    OfferCrawlFailure = 'offer.crawl_failure',
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionReconciled = 'offer.transaction.reconciled',
    OfferTransactionAbandoned = 'offer.transaction.abandoned',
    OfferClosed = 'offer.closed',
    OfferTransactionRefund = 'offer.transaction.refund',
    PersonaAdded = 'persona.added'
}

/**
 * 
 * @export
 * @interface WebhookHistoryCollectionRead
 */
export interface WebhookHistoryCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryCollectionRead
     */
    'event': WebhookHistoryCollectionReadEventEnum;
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryCollectionRead
     */
    'responseCode': number;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryCollectionRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryCollectionRead
     */
    'attemptedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryCollectionRead
     */
    'retryCount': number;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookHistoryCollectionReadEventEnum {
    DisputeOpened = 'dispute.opened',
    DisputeSubmitted = 'dispute.submitted',
    DisputeCreated = 'dispute.created',
    DisputeAbandoned = 'dispute.abandoned',
    DisputeSettlement = 'dispute.settlement',
    DisputeClosed = 'dispute.closed',
    DisputeExpired = 'dispute.expired',
    DisputeManualArbitrationRequired = 'dispute.manual_arbitration_required',
    DisputeUpdated = 'dispute.updated',
    OfferCreated = 'offer.created',
    OfferExpired = 'offer.expired',
    OfferUpdated = 'offer.updated',
    OfferCrawlFailure = 'offer.crawl_failure',
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionReconciled = 'offer.transaction.reconciled',
    OfferTransactionAbandoned = 'offer.transaction.abandoned',
    OfferClosed = 'offer.closed',
    OfferTransactionRefund = 'offer.transaction.refund',
    PersonaAdded = 'persona.added'
}

/**
 * 
 * @export
 * @interface WebhookHistoryRead
 */
export interface WebhookHistoryRead {
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'event': WebhookHistoryReadEventEnum;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryRead
     */
    'responseCode': number;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'responseBody': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'attemptedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryRead
     */
    'retryCount': number;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookHistoryReadEventEnum {
    DisputeOpened = 'dispute.opened',
    DisputeSubmitted = 'dispute.submitted',
    DisputeCreated = 'dispute.created',
    DisputeAbandoned = 'dispute.abandoned',
    DisputeSettlement = 'dispute.settlement',
    DisputeClosed = 'dispute.closed',
    DisputeExpired = 'dispute.expired',
    DisputeManualArbitrationRequired = 'dispute.manual_arbitration_required',
    DisputeUpdated = 'dispute.updated',
    OfferCreated = 'offer.created',
    OfferExpired = 'offer.expired',
    OfferUpdated = 'offer.updated',
    OfferCrawlFailure = 'offer.crawl_failure',
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionReconciled = 'offer.transaction.reconciled',
    OfferTransactionAbandoned = 'offer.transaction.abandoned',
    OfferClosed = 'offer.closed',
    OfferTransactionRefund = 'offer.transaction.refund',
    PersonaAdded = 'persona.added'
}

/**
 * 
 * @export
 * @interface WebhookObject
 */
export interface WebhookObject {
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'ulid': string;
    /**
     * 
     * @type {TransactionRead}
     * @memberof WebhookObject
     */
    'transaction'?: TransactionRead;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'status': WebhookObjectStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'itemCount': number;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'issueType': WebhookObjectIssueTypeEnum;
    /**
     * To be set only in conjunction of issueType = NOT_AS_DESCRIBED.
     * @type {string}
     * @memberof WebhookObject
     */
    'issueInDescriptionType'?: WebhookObjectIssueInDescriptionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'issueDetails'?: string;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'complainantTruthfulnessScore': number;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'sellerTruthfulnessScore': number;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'complainantStake': WebhookObjectComplainantStakeEnum;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'inferredStake'?: WebhookObjectInferredStakeEnum;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'recommendedSolution'?: WebhookObjectRecommendedSolutionEnum;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'recommendedPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'chosenSolution'?: WebhookObjectChosenSolutionEnum;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'chosenPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'counterSolution'?: WebhookObjectCounterSolutionEnum;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'counterPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookObject
     */
    'complainantApproval'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookObject
     */
    'sellerApproval': boolean | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'platformSolution'?: WebhookObjectPlatformSolutionEnum;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'platformPartialRefundAmount'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookObject
     */
    'platformApproval'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'arbitrationBy'?: string | null;
    /**
     * 
     * @type {Array<ParcelRead>}
     * @memberof WebhookObject
     */
    'parcels': Array<ParcelRead>;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'updatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'iri'?: string;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'messageCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'gender'?: WebhookObjectGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof WebhookObject
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {PersonaReadAddress}
     * @memberof WebhookObject
     */
    'address'?: PersonaReadAddress | null;
    /**
     * We sort Persona into three distinct risks\' category. This is inferred from the riskScore.
     * @type {string}
     * @memberof WebhookObject
     */
    'riskLevel'?: WebhookObjectRiskLevelEnum;
    /**
     * That score is regularly updated, each action taken can potentially update that value. A value close to zero mean zero risk and close to a hundred mean risky.
     * @type {number}
     * @memberof WebhookObject
     */
    'riskScore'?: number | null;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof WebhookObject
     */
    'externalPurchaseCount'?: number;
    /**
     * Knowing the statistics on your user is used to better know its profile when you do not use the Safe-Checkout feature. Although it is not required, we recommend that you keep us informed.
     * @type {number}
     * @memberof WebhookObject
     */
    'externalSellCount'?: number;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<MetadataRead>}
     * @memberof WebhookObject
     */
    'metadata': Array<MetadataRead>;
    /**
     * Issued Offers count owned by a given Persona
     * @type {number}
     * @memberof WebhookObject
     */
    'offerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'purchaseCount'?: number;
    /**
     * If specified, there would be not need for you to fill-in details. Must be accessible over WAN.
     * @type {string}
     * @memberof WebhookObject
     */
    'publicUrl'?: string | null;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {string}
     * @memberof WebhookObject
     */
    'nature': WebhookObjectNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'unitPrice'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'currencyCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'condition': WebhookObjectConditionEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectStatusEnum {
    Created = 'CREATED',
    Submitted = 'SUBMITTED',
    Opened = 'OPENED',
    Abandoned = 'ABANDONED',
    Pending = 'PENDING',
    Objected = 'OBJECTED',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Returned = 'RETURNED',
    Dismissed = 'DISMISSED',
    Resolved = 'RESOLVED'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectIssueTypeEnum {
    NotAsDescribed = 'NOT_AS_DESCRIBED',
    DoesNotWork = 'DOES_NOT_WORK',
    IsIncomplete = 'IS_INCOMPLETE',
    DeliveryIssue = 'DELIVERY_ISSUE',
    AllegedFraud = 'ALLEGED_FRAUD'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectIssueInDescriptionTypeEnum {
    WrongColour = 'WRONG_COLOUR',
    DamagedOrUsed = 'DAMAGED_OR_USED',
    IncorrectFormatOrSize = 'INCORRECT_FORMAT_OR_SIZE',
    DifferentMaterial = 'DIFFERENT_MATERIAL',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectComplainantStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectInferredStakeEnum {
    Low = 'LOW',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectRecommendedSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectChosenSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectCounterSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectPlatformSolutionEnum {
    PartialRefundWithPartialReturn = 'PARTIAL_REFUND_WITH_PARTIAL_RETURN',
    PartialRefundWithoutReturn = 'PARTIAL_REFUND_WITHOUT_RETURN',
    CompleteRefundWithReturn = 'COMPLETE_REFUND_WITH_RETURN',
    CompleteRefundWithoutReturn = 'COMPLETE_REFUND_WITHOUT_RETURN',
    AbandonClaim = 'ABANDON_CLAIM',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectRiskLevelEnum {
    Weak = 'WEAK',
    Medium = 'MEDIUM',
    High = 'HIGH',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}

/**
 * 
 * @export
 * @interface WebhookSubscriptionRead
 */
export interface WebhookSubscriptionRead {
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionRead
     */
    'event': WebhookSubscriptionReadEventEnum;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionRead
     */
    'callbackUrl': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionRead
     */
    'createdAt'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookSubscriptionReadEventEnum {
    DisputeOpened = 'dispute.opened',
    DisputeSubmitted = 'dispute.submitted',
    DisputeCreated = 'dispute.created',
    DisputeAbandoned = 'dispute.abandoned',
    DisputeSettlement = 'dispute.settlement',
    DisputeClosed = 'dispute.closed',
    DisputeExpired = 'dispute.expired',
    DisputeManualArbitrationRequired = 'dispute.manual_arbitration_required',
    DisputeUpdated = 'dispute.updated',
    OfferCreated = 'offer.created',
    OfferExpired = 'offer.expired',
    OfferUpdated = 'offer.updated',
    OfferCrawlFailure = 'offer.crawl_failure',
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionReconciled = 'offer.transaction.reconciled',
    OfferTransactionAbandoned = 'offer.transaction.abandoned',
    OfferClosed = 'offer.closed',
    OfferTransactionRefund = 'offer.transaction.refund',
    PersonaAdded = 'persona.added'
}

/**
 * 
 * @export
 * @interface WebhookSubscriptionWrite
 */
export interface WebhookSubscriptionWrite {
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionWrite
     */
    'event': WebhookSubscriptionWriteEventEnum;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionWrite
     */
    'callbackUrl': string;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookSubscriptionWriteEventEnum {
    DisputeOpened = 'dispute.opened',
    DisputeSubmitted = 'dispute.submitted',
    DisputeCreated = 'dispute.created',
    DisputeAbandoned = 'dispute.abandoned',
    DisputeSettlement = 'dispute.settlement',
    DisputeClosed = 'dispute.closed',
    DisputeExpired = 'dispute.expired',
    DisputeManualArbitrationRequired = 'dispute.manual_arbitration_required',
    DisputeUpdated = 'dispute.updated',
    OfferCreated = 'offer.created',
    OfferExpired = 'offer.expired',
    OfferUpdated = 'offer.updated',
    OfferCrawlFailure = 'offer.crawl_failure',
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionReconciled = 'offer.transaction.reconciled',
    OfferTransactionAbandoned = 'offer.transaction.abandoned',
    OfferClosed = 'offer.closed',
    OfferTransactionRefund = 'offer.transaction.refund',
    PersonaAdded = 'persona.added'
}


/**
 * AIApi - axios parameter creator
 * @export
 */
export const AIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a AiHint resource.
         * @summary Dedicated endpoint for our artificial intelligence bot
         * @param {AiHint} aiHint The new AiHint resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAiHintsPost: async (aiHint: AiHint, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aiHint' is not null or undefined
            assertParamExists('apiAiHintsPost', 'aiHint', aiHint)
            const localVarPath = `/ai-hints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aiHint, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AIApi - functional programming interface
 * @export
 */
export const AIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AIApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a AiHint resource.
         * @summary Dedicated endpoint for our artificial intelligence bot
         * @param {AiHint} aiHint The new AiHint resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAiHintsPost(aiHint: AiHint, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AiHint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAiHintsPost(aiHint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AIApi - factory interface
 * @export
 */
export const AIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AIApiFp(configuration)
    return {
        /**
         * Creates a AiHint resource.
         * @summary Dedicated endpoint for our artificial intelligence bot
         * @param {AiHint} aiHint The new AiHint resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAiHintsPost(aiHint: AiHint, options?: any): AxiosPromise<AiHint> {
            return localVarFp.apiAiHintsPost(aiHint, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AIApi - object-oriented interface
 * @export
 * @class AIApi
 * @extends {BaseAPI}
 */
export class AIApi extends BaseAPI {
    /**
     * Creates a AiHint resource.
     * @summary Dedicated endpoint for our artificial intelligence bot
     * @param {AiHint} aiHint The new AiHint resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIApi
     */
    public apiAiHintsPost(aiHint: AiHint, options?: AxiosRequestConfig) {
        return AIApiFp(this.configuration).apiAiHintsPost(aiHint, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BrandingApi - axios parameter creator
 * @export
 */
export const BrandingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Updates the Organization resource.
         * @summary Update your Organization details, branding or parameters
         * @param {string} id Organization identifier
         * @param {OrganizationUpdate} organizationUpdate The updated Organization resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdPatch: async (id: string, organizationUpdate: OrganizationUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdPatch', 'id', id)
            // verify required parameter 'organizationUpdate' is not null or undefined
            assertParamExists('apiOrganizationsIdPatch', 'organizationUpdate', organizationUpdate)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Icon
         * @param {string} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdiconDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdiconDelete', 'id', id)
            const localVarPath = `/organizations/{id}/icon`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization Icon
         * @param {string} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdiconPost: async (id: string, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdiconPost', 'id', id)
            const localVarPath = `/organizations/{id}/icon`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Logo
         * @param {string} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdlogoDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdlogoDelete', 'id', id)
            const localVarPath = `/organizations/{id}/logo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization logo
         * @param {string} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdlogoPost: async (id: string, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdlogoPost', 'id', id)
            const localVarPath = `/organizations/{id}/logo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrandingApi - functional programming interface
 * @export
 */
export const BrandingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrandingApiAxiosParamCreator(configuration)
    return {
        /**
         * Updates the Organization resource.
         * @summary Update your Organization details, branding or parameters
         * @param {string} id Organization identifier
         * @param {OrganizationUpdate} organizationUpdate The updated Organization resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdPatch(id: string, organizationUpdate: OrganizationUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdPatch(id, organizationUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Icon
         * @param {string} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdiconDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdiconDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization Icon
         * @param {string} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdiconPost(id: string, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdiconPost(id, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Logo
         * @param {string} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdlogoDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdlogoDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization logo
         * @param {string} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdlogoPost(id: string, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdlogoPost(id, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BrandingApi - factory interface
 * @export
 */
export const BrandingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrandingApiFp(configuration)
    return {
        /**
         * Updates the Organization resource.
         * @summary Update your Organization details, branding or parameters
         * @param {string} id Organization identifier
         * @param {OrganizationUpdate} organizationUpdate The updated Organization resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdPatch(id: string, organizationUpdate: OrganizationUpdate, options?: any): AxiosPromise<OrganizationRead> {
            return localVarFp.apiOrganizationsIdPatch(id, organizationUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Icon
         * @param {string} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdiconDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdiconDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization Icon
         * @param {string} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdiconPost(id: string, file?: File, options?: any): AxiosPromise<MediaRead> {
            return localVarFp.apiOrganizationsIdiconPost(id, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Logo
         * @param {string} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdlogoDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdlogoDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization logo
         * @param {string} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdlogoPost(id: string, file?: File, options?: any): AxiosPromise<MediaRead> {
            return localVarFp.apiOrganizationsIdlogoPost(id, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrandingApi - object-oriented interface
 * @export
 * @class BrandingApi
 * @extends {BaseAPI}
 */
export class BrandingApi extends BaseAPI {
    /**
     * Updates the Organization resource.
     * @summary Update your Organization details, branding or parameters
     * @param {string} id Organization identifier
     * @param {OrganizationUpdate} organizationUpdate The updated Organization resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdPatch(id: string, organizationUpdate: OrganizationUpdate, options?: AxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdPatch(id, organizationUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Media resource.
     * @summary Unset your Organization Icon
     * @param {string} id Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdiconDelete(id: string, options?: AxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdiconDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Media resource.
     * @summary Upload your Organization Icon
     * @param {string} id Organization identifier
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdiconPost(id: string, file?: File, options?: AxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdiconPost(id, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Media resource.
     * @summary Unset your Organization Logo
     * @param {string} id Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdlogoDelete(id: string, options?: AxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdlogoDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Media resource.
     * @summary Upload your Organization logo
     * @param {string} id Organization identifier
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdlogoPost(id: string, file?: File, options?: AxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdlogoPost(id, file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationApi - axios parameter creator
 * @export
 */
export const NotificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieve pending notifications for Persona
         * @param {string} id Persona identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdnotificationsGetCollection: async (id: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdnotificationsGetCollection', 'id', id)
            const localVarPath = `/personas/{id}/notifications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for Persona
         * @param {string} personaId Persona identifier
         * @param {string} id Notification identifier
         * @param {Notification} notification The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasPersonaIdnotificationsIdPatch: async (personaId: string, id: string, notification: Notification, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('apiPersonasPersonaIdnotificationsIdPatch', 'personaId', personaId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasPersonaIdnotificationsIdPatch', 'id', id)
            // verify required parameter 'notification' is not null or undefined
            assertParamExists('apiPersonasPersonaIdnotificationsIdPatch', 'notification', notification)
            const localVarPath = `/personas/{personaId}/notifications/{id}`
                .replace(`{${"personaId"}}`, encodeURIComponent(String(personaId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notification, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieves the collection of Notification resources.
         * @param {string} id User identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdnotificationsGetCollection: async (id: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdnotificationsGetCollection', 'id', id)
            const localVarPath = `/users/{id}/notifications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for User
         * @param {string} userId User identifier
         * @param {string} id Notification identifier
         * @param {NotificationUpdate} notificationUpdate The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdnotificationsIdPatch: async (userId: string, id: string, notificationUpdate: NotificationUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdnotificationsIdPatch', 'userId', userId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersUserIdnotificationsIdPatch', 'id', id)
            // verify required parameter 'notificationUpdate' is not null or undefined
            assertParamExists('apiUsersUserIdnotificationsIdPatch', 'notificationUpdate', notificationUpdate)
            const localVarPath = `/users/{userId}/notifications/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationApi - functional programming interface
 * @export
 */
export const NotificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieve pending notifications for Persona
         * @param {string} id Persona identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdnotificationsGetCollection(id: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Notification>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdnotificationsGetCollection(id, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for Persona
         * @param {string} personaId Persona identifier
         * @param {string} id Notification identifier
         * @param {Notification} notification The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasPersonaIdnotificationsIdPatch(personaId: string, id: string, notification: Notification, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasPersonaIdnotificationsIdPatch(personaId, id, notification, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieves the collection of Notification resources.
         * @param {string} id User identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdnotificationsGetCollection(id: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdnotificationsGetCollection(id, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for User
         * @param {string} userId User identifier
         * @param {string} id Notification identifier
         * @param {NotificationUpdate} notificationUpdate The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdnotificationsIdPatch(userId: string, id: string, notificationUpdate: NotificationUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdnotificationsIdPatch(userId, id, notificationUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationApi - factory interface
 * @export
 */
export const NotificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieve pending notifications for Persona
         * @param {string} id Persona identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdnotificationsGetCollection(id: string, page?: number, options?: any): AxiosPromise<Array<Notification>> {
            return localVarFp.apiPersonasIdnotificationsGetCollection(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for Persona
         * @param {string} personaId Persona identifier
         * @param {string} id Notification identifier
         * @param {Notification} notification The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasPersonaIdnotificationsIdPatch(personaId: string, id: string, notification: Notification, options?: any): AxiosPromise<Notification> {
            return localVarFp.apiPersonasPersonaIdnotificationsIdPatch(personaId, id, notification, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieves the collection of Notification resources.
         * @param {string} id User identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdnotificationsGetCollection(id: string, page?: number, options?: any): AxiosPromise<Array<NotificationRead>> {
            return localVarFp.apiUsersIdnotificationsGetCollection(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for User
         * @param {string} userId User identifier
         * @param {string} id Notification identifier
         * @param {NotificationUpdate} notificationUpdate The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdnotificationsIdPatch(userId: string, id: string, notificationUpdate: NotificationUpdate, options?: any): AxiosPromise<NotificationRead> {
            return localVarFp.apiUsersUserIdnotificationsIdPatch(userId, id, notificationUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
export class NotificationApi extends BaseAPI {
    /**
     * Retrieves the collection of Notification resources.
     * @summary Retrieve pending notifications for Persona
     * @param {string} id Persona identifier
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public apiPersonasIdnotificationsGetCollection(id: string, page?: number, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).apiPersonasIdnotificationsGetCollection(id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the Notification resource.
     * @summary Mark as read/unread a notification for Persona
     * @param {string} personaId Persona identifier
     * @param {string} id Notification identifier
     * @param {Notification} notification The updated Notification resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public apiPersonasPersonaIdnotificationsIdPatch(personaId: string, id: string, notification: Notification, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).apiPersonasPersonaIdnotificationsIdPatch(personaId, id, notification, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of Notification resources.
     * @summary Retrieves the collection of Notification resources.
     * @param {string} id User identifier
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public apiUsersIdnotificationsGetCollection(id: string, page?: number, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).apiUsersIdnotificationsGetCollection(id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the Notification resource.
     * @summary Mark as read/unread a notification for User
     * @param {string} userId User identifier
     * @param {string} id Notification identifier
     * @param {NotificationUpdate} notificationUpdate The updated Notification resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public apiUsersUserIdnotificationsIdPatch(userId: string, id: string, notificationUpdate: NotificationUpdate, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).apiUsersUserIdnotificationsIdPatch(userId, id, notificationUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonaApi - axios parameter creator
 * @export
 */
export const PersonaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Persona resources.
         * @summary Retrieves the collection of Persona resources.
         * @param {number} [page] The collection page number
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {string} [mobilePhoneNumber] 
         * @param {Array<string>} [mobilePhoneNumber2] 
         * @param {'MALE' | 'FEMALE' | 'OTHER' | 'RATHER_NOT_SAY'} [gender] Filter on a limited subset of gender
         * @param {'asc' | 'desc'} [orderCreatedAt] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {string} [dateOfBirthBefore] 
         * @param {string} [dateOfBirthStrictlyBefore] 
         * @param {string} [dateOfBirthAfter] 
         * @param {string} [dateOfBirthStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasGetCollection: async (page?: number, firstName?: string, lastName?: string, email?: string, mobilePhoneNumber?: string, mobilePhoneNumber2?: Array<string>, gender?: 'MALE' | 'FEMALE' | 'OTHER' | 'RATHER_NOT_SAY', orderCreatedAt?: 'asc' | 'desc', createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, dateOfBirthBefore?: string, dateOfBirthStrictlyBefore?: string, dateOfBirthAfter?: string, dateOfBirthStrictlyAfter?: string, metadata?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/personas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['firstName'] = firstName;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['lastName'] = lastName;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (mobilePhoneNumber !== undefined) {
                localVarQueryParameter['mobilePhoneNumber'] = mobilePhoneNumber;
            }

            if (mobilePhoneNumber2) {
                localVarQueryParameter['mobilePhoneNumber[]'] = mobilePhoneNumber2;
            }

            if (gender !== undefined) {
                localVarQueryParameter['gender'] = gender;
            }

            if (orderCreatedAt !== undefined) {
                localVarQueryParameter['order[createdAt]'] = orderCreatedAt;
            }

            if (createdAtBefore !== undefined) {
                localVarQueryParameter['createdAt[before]'] = createdAtBefore;
            }

            if (createdAtStrictlyBefore !== undefined) {
                localVarQueryParameter['createdAt[strictly_before]'] = createdAtStrictlyBefore;
            }

            if (createdAtAfter !== undefined) {
                localVarQueryParameter['createdAt[after]'] = createdAtAfter;
            }

            if (createdAtStrictlyAfter !== undefined) {
                localVarQueryParameter['createdAt[strictly_after]'] = createdAtStrictlyAfter;
            }

            if (dateOfBirthBefore !== undefined) {
                localVarQueryParameter['dateOfBirth[before]'] = dateOfBirthBefore;
            }

            if (dateOfBirthStrictlyBefore !== undefined) {
                localVarQueryParameter['dateOfBirth[strictly_before]'] = dateOfBirthStrictlyBefore;
            }

            if (dateOfBirthAfter !== undefined) {
                localVarQueryParameter['dateOfBirth[after]'] = dateOfBirthAfter;
            }

            if (dateOfBirthStrictlyAfter !== undefined) {
                localVarQueryParameter['dateOfBirth[strictly_after]'] = dateOfBirthStrictlyAfter;
            }

            if (metadata) {
                localVarQueryParameter['metadata[]'] = metadata.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You **MAY** unregister (or free the email/phone number) your Persona entry using that endpoint. *Please note that* this operation will fail if that Persona have any ongoing operations.
         * @summary Unregister a Persona (Your customer)
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdDelete', 'id', id)
            const localVarPath = `/personas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_WRITE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Persona resource.
         * @summary Retrieves a Persona resource.
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdGet', 'id', id)
            const localVarPath = `/personas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update your Persona (eg. your customer/user entry) through that API call. _Beware that updating_ **email** and/or the **mobile phone number** must be done using non reserved values. Otherwise this operation will be rejected.
         * @summary Updates the Persona resource.
         * @param {string} id Persona identifier
         * @param {PersonaUpdate} personaUpdate The updated Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdPatch: async (id: string, personaUpdate: PersonaUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdPatch', 'id', id)
            // verify required parameter 'personaUpdate' is not null or undefined
            assertParamExists('apiPersonasIdPatch', 'personaUpdate', personaUpdate)
            const localVarPath = `/personas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Without this, your users may be required to pass a MFA challenge even if they are already logged-in from your website. Pass the URL you wish your user access, either a Dispute or Safe-checkout resource.
         * @summary Issue authenticated URL for single end-user
         * @param {string} id Persona identifier
         * @param {PersonaTokenWrite} personaTokenWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdtokenPost: async (id: string, personaTokenWrite: PersonaTokenWrite, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdtokenPost', 'id', id)
            // verify required parameter 'personaTokenWrite' is not null or undefined
            assertParamExists('apiPersonasIdtokenPost', 'personaTokenWrite', personaTokenWrite)
            const localVarPath = `/personas/{id}/token`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_AUTH"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaTokenWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You should not register your whole database of users, only those who are concerned by a Safe-checkout or Dispute operation. One Persona entry for your organization can be assigned as a seller or buyer.  **Notes:**   - (i) There is a unique constraint for the mobile phone numbers and email.   - (ii) You will have to issue a DELETE operation on a Persona that withhold a specific phone number or email.   - (iii) You are NOT REQUIRED to provide email OR a mobile phone number but it is highly recommended, if none provided the email will be generated as \'{ulid}@your-domain.tld\'. In that case, please specify at least one metadata in order to find your entry with ease.
         * @summary Register a Persona (Your customer)
         * @param {PersonaWrite} personaWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasPost: async (personaWrite: PersonaWrite, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaWrite' is not null or undefined
            assertParamExists('apiPersonasPost', 'personaWrite', personaWrite)
            const localVarPath = `/personas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonaApi - functional programming interface
 * @export
 */
export const PersonaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonaApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Persona resources.
         * @summary Retrieves the collection of Persona resources.
         * @param {number} [page] The collection page number
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {string} [mobilePhoneNumber] 
         * @param {Array<string>} [mobilePhoneNumber2] 
         * @param {'MALE' | 'FEMALE' | 'OTHER' | 'RATHER_NOT_SAY'} [gender] Filter on a limited subset of gender
         * @param {'asc' | 'desc'} [orderCreatedAt] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {string} [dateOfBirthBefore] 
         * @param {string} [dateOfBirthStrictlyBefore] 
         * @param {string} [dateOfBirthAfter] 
         * @param {string} [dateOfBirthStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasGetCollection(page?: number, firstName?: string, lastName?: string, email?: string, mobilePhoneNumber?: string, mobilePhoneNumber2?: Array<string>, gender?: 'MALE' | 'FEMALE' | 'OTHER' | 'RATHER_NOT_SAY', orderCreatedAt?: 'asc' | 'desc', createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, dateOfBirthBefore?: string, dateOfBirthStrictlyBefore?: string, dateOfBirthAfter?: string, dateOfBirthStrictlyAfter?: string, metadata?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PersonaCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasGetCollection(page, firstName, lastName, email, mobilePhoneNumber, mobilePhoneNumber2, gender, orderCreatedAt, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, dateOfBirthBefore, dateOfBirthStrictlyBefore, dateOfBirthAfter, dateOfBirthStrictlyAfter, metadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You **MAY** unregister (or free the email/phone number) your Persona entry using that endpoint. *Please note that* this operation will fail if that Persona have any ongoing operations.
         * @summary Unregister a Persona (Your customer)
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Persona resource.
         * @summary Retrieves a Persona resource.
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update your Persona (eg. your customer/user entry) through that API call. _Beware that updating_ **email** and/or the **mobile phone number** must be done using non reserved values. Otherwise this operation will be rejected.
         * @summary Updates the Persona resource.
         * @param {string} id Persona identifier
         * @param {PersonaUpdate} personaUpdate The updated Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdPatch(id: string, personaUpdate: PersonaUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdPatch(id, personaUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Without this, your users may be required to pass a MFA challenge even if they are already logged-in from your website. Pass the URL you wish your user access, either a Dispute or Safe-checkout resource.
         * @summary Issue authenticated URL for single end-user
         * @param {string} id Persona identifier
         * @param {PersonaTokenWrite} personaTokenWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdtokenPost(id: string, personaTokenWrite: PersonaTokenWrite, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaPostAuthRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdtokenPost(id, personaTokenWrite, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You should not register your whole database of users, only those who are concerned by a Safe-checkout or Dispute operation. One Persona entry for your organization can be assigned as a seller or buyer.  **Notes:**   - (i) There is a unique constraint for the mobile phone numbers and email.   - (ii) You will have to issue a DELETE operation on a Persona that withhold a specific phone number or email.   - (iii) You are NOT REQUIRED to provide email OR a mobile phone number but it is highly recommended, if none provided the email will be generated as \'{ulid}@your-domain.tld\'. In that case, please specify at least one metadata in order to find your entry with ease.
         * @summary Register a Persona (Your customer)
         * @param {PersonaWrite} personaWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasPost(personaWrite: PersonaWrite, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasPost(personaWrite, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonaApi - factory interface
 * @export
 */
export const PersonaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonaApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Persona resources.
         * @summary Retrieves the collection of Persona resources.
         * @param {number} [page] The collection page number
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {string} [mobilePhoneNumber] 
         * @param {Array<string>} [mobilePhoneNumber2] 
         * @param {'MALE' | 'FEMALE' | 'OTHER' | 'RATHER_NOT_SAY'} [gender] Filter on a limited subset of gender
         * @param {'asc' | 'desc'} [orderCreatedAt] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {string} [dateOfBirthBefore] 
         * @param {string} [dateOfBirthStrictlyBefore] 
         * @param {string} [dateOfBirthAfter] 
         * @param {string} [dateOfBirthStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasGetCollection(page?: number, firstName?: string, lastName?: string, email?: string, mobilePhoneNumber?: string, mobilePhoneNumber2?: Array<string>, gender?: 'MALE' | 'FEMALE' | 'OTHER' | 'RATHER_NOT_SAY', orderCreatedAt?: 'asc' | 'desc', createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, dateOfBirthBefore?: string, dateOfBirthStrictlyBefore?: string, dateOfBirthAfter?: string, dateOfBirthStrictlyAfter?: string, metadata?: Array<string>, options?: any): AxiosPromise<Array<PersonaCollectionRead>> {
            return localVarFp.apiPersonasGetCollection(page, firstName, lastName, email, mobilePhoneNumber, mobilePhoneNumber2, gender, orderCreatedAt, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, dateOfBirthBefore, dateOfBirthStrictlyBefore, dateOfBirthAfter, dateOfBirthStrictlyAfter, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * You **MAY** unregister (or free the email/phone number) your Persona entry using that endpoint. *Please note that* this operation will fail if that Persona have any ongoing operations.
         * @summary Unregister a Persona (Your customer)
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiPersonasIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Persona resource.
         * @summary Retrieves a Persona resource.
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdGet(id: string, options?: any): AxiosPromise<PersonaRead> {
            return localVarFp.apiPersonasIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update your Persona (eg. your customer/user entry) through that API call. _Beware that updating_ **email** and/or the **mobile phone number** must be done using non reserved values. Otherwise this operation will be rejected.
         * @summary Updates the Persona resource.
         * @param {string} id Persona identifier
         * @param {PersonaUpdate} personaUpdate The updated Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdPatch(id: string, personaUpdate: PersonaUpdate, options?: any): AxiosPromise<PersonaRead> {
            return localVarFp.apiPersonasIdPatch(id, personaUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Without this, your users may be required to pass a MFA challenge even if they are already logged-in from your website. Pass the URL you wish your user access, either a Dispute or Safe-checkout resource.
         * @summary Issue authenticated URL for single end-user
         * @param {string} id Persona identifier
         * @param {PersonaTokenWrite} personaTokenWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdtokenPost(id: string, personaTokenWrite: PersonaTokenWrite, options?: any): AxiosPromise<PersonaPostAuthRead> {
            return localVarFp.apiPersonasIdtokenPost(id, personaTokenWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * You should not register your whole database of users, only those who are concerned by a Safe-checkout or Dispute operation. One Persona entry for your organization can be assigned as a seller or buyer.  **Notes:**   - (i) There is a unique constraint for the mobile phone numbers and email.   - (ii) You will have to issue a DELETE operation on a Persona that withhold a specific phone number or email.   - (iii) You are NOT REQUIRED to provide email OR a mobile phone number but it is highly recommended, if none provided the email will be generated as \'{ulid}@your-domain.tld\'. In that case, please specify at least one metadata in order to find your entry with ease.
         * @summary Register a Persona (Your customer)
         * @param {PersonaWrite} personaWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasPost(personaWrite: PersonaWrite, options?: any): AxiosPromise<PersonaRead> {
            return localVarFp.apiPersonasPost(personaWrite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonaApi - object-oriented interface
 * @export
 * @class PersonaApi
 * @extends {BaseAPI}
 */
export class PersonaApi extends BaseAPI {
    /**
     * Retrieves the collection of Persona resources.
     * @summary Retrieves the collection of Persona resources.
     * @param {number} [page] The collection page number
     * @param {string} [firstName] 
     * @param {string} [lastName] 
     * @param {string} [email] 
     * @param {string} [mobilePhoneNumber] 
     * @param {Array<string>} [mobilePhoneNumber2] 
     * @param {'MALE' | 'FEMALE' | 'OTHER' | 'RATHER_NOT_SAY'} [gender] Filter on a limited subset of gender
     * @param {'asc' | 'desc'} [orderCreatedAt] 
     * @param {string} [createdAtBefore] 
     * @param {string} [createdAtStrictlyBefore] 
     * @param {string} [createdAtAfter] 
     * @param {string} [createdAtStrictlyAfter] 
     * @param {string} [dateOfBirthBefore] 
     * @param {string} [dateOfBirthStrictlyBefore] 
     * @param {string} [dateOfBirthAfter] 
     * @param {string} [dateOfBirthStrictlyAfter] 
     * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasGetCollection(page?: number, firstName?: string, lastName?: string, email?: string, mobilePhoneNumber?: string, mobilePhoneNumber2?: Array<string>, gender?: 'MALE' | 'FEMALE' | 'OTHER' | 'RATHER_NOT_SAY', orderCreatedAt?: 'asc' | 'desc', createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, dateOfBirthBefore?: string, dateOfBirthStrictlyBefore?: string, dateOfBirthAfter?: string, dateOfBirthStrictlyAfter?: string, metadata?: Array<string>, options?: AxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasGetCollection(page, firstName, lastName, email, mobilePhoneNumber, mobilePhoneNumber2, gender, orderCreatedAt, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, dateOfBirthBefore, dateOfBirthStrictlyBefore, dateOfBirthAfter, dateOfBirthStrictlyAfter, metadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You **MAY** unregister (or free the email/phone number) your Persona entry using that endpoint. *Please note that* this operation will fail if that Persona have any ongoing operations.
     * @summary Unregister a Persona (Your customer)
     * @param {string} id Persona identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasIdDelete(id: string, options?: AxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Persona resource.
     * @summary Retrieves a Persona resource.
     * @param {string} id Persona identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasIdGet(id: string, options?: AxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update your Persona (eg. your customer/user entry) through that API call. _Beware that updating_ **email** and/or the **mobile phone number** must be done using non reserved values. Otherwise this operation will be rejected.
     * @summary Updates the Persona resource.
     * @param {string} id Persona identifier
     * @param {PersonaUpdate} personaUpdate The updated Persona resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasIdPatch(id: string, personaUpdate: PersonaUpdate, options?: AxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasIdPatch(id, personaUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Without this, your users may be required to pass a MFA challenge even if they are already logged-in from your website. Pass the URL you wish your user access, either a Dispute or Safe-checkout resource.
     * @summary Issue authenticated URL for single end-user
     * @param {string} id Persona identifier
     * @param {PersonaTokenWrite} personaTokenWrite The new Persona resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasIdtokenPost(id: string, personaTokenWrite: PersonaTokenWrite, options?: AxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasIdtokenPost(id, personaTokenWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You should not register your whole database of users, only those who are concerned by a Safe-checkout or Dispute operation. One Persona entry for your organization can be assigned as a seller or buyer.  **Notes:**   - (i) There is a unique constraint for the mobile phone numbers and email.   - (ii) You will have to issue a DELETE operation on a Persona that withhold a specific phone number or email.   - (iii) You are NOT REQUIRED to provide email OR a mobile phone number but it is highly recommended, if none provided the email will be generated as \'{ulid}@your-domain.tld\'. In that case, please specify at least one metadata in order to find your entry with ease.
     * @summary Register a Persona (Your customer)
     * @param {PersonaWrite} personaWrite The new Persona resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasPost(personaWrite: PersonaWrite, options?: AxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasPost(personaWrite, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ResolutionCenterApi - axios parameter creator
 * @export
 */
export const ResolutionCenterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Dispute resources.
         * @summary Retrieves the collection of Dispute resources.
         * @param {number} [page] The collection page number
         * @param {'asc' | 'desc'} [orderCreatedAt] 
         * @param {'asc' | 'desc'} [orderStatus] 
         * @param {'asc' | 'desc'} [orderUpdatedAt] 
         * @param {string} [transactionOfferTitle] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {'CREATED' | 'SUBMITTED' | 'OPENED' | 'ABANDONED' | 'PENDING' | 'OBJECTED' | 'SHIPPED' | 'IN_TRANSIT' | 'RETURNED' | 'DISMISSED' | 'RESOLVED'} [status] Filter on a limited subset of status
         * @param {'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED'} [transactionStatus] Filter on a limited subset of transaction.status
         * @param {boolean} [existsRecommendedSolution] 
         * @param {boolean} [existsChosenSolution] 
         * @param {boolean} [existsCounterSolution] 
         * @param {boolean} [existsPlatformSolution] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [transactionMetadata] Flattened OrderedMap for transaction.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [transactionOfferMetadata] Flattened OrderedMap for transaction.offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesGetCollection: async (page?: number, orderCreatedAt?: 'asc' | 'desc', orderStatus?: 'asc' | 'desc', orderUpdatedAt?: 'asc' | 'desc', transactionOfferTitle?: string, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, status?: 'CREATED' | 'SUBMITTED' | 'OPENED' | 'ABANDONED' | 'PENDING' | 'OBJECTED' | 'SHIPPED' | 'IN_TRANSIT' | 'RETURNED' | 'DISMISSED' | 'RESOLVED', transactionStatus?: 'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED', existsRecommendedSolution?: boolean, existsChosenSolution?: boolean, existsCounterSolution?: boolean, existsPlatformSolution?: boolean, metadata?: Array<string>, transactionMetadata?: Array<string>, transactionOfferMetadata?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/disputes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderCreatedAt !== undefined) {
                localVarQueryParameter['order[createdAt]'] = orderCreatedAt;
            }

            if (orderStatus !== undefined) {
                localVarQueryParameter['order[status]'] = orderStatus;
            }

            if (orderUpdatedAt !== undefined) {
                localVarQueryParameter['order[updatedAt]'] = orderUpdatedAt;
            }

            if (transactionOfferTitle !== undefined) {
                localVarQueryParameter['transaction.offer.title'] = transactionOfferTitle;
            }

            if (createdAtBefore !== undefined) {
                localVarQueryParameter['createdAt[before]'] = createdAtBefore;
            }

            if (createdAtStrictlyBefore !== undefined) {
                localVarQueryParameter['createdAt[strictly_before]'] = createdAtStrictlyBefore;
            }

            if (createdAtAfter !== undefined) {
                localVarQueryParameter['createdAt[after]'] = createdAtAfter;
            }

            if (createdAtStrictlyAfter !== undefined) {
                localVarQueryParameter['createdAt[strictly_after]'] = createdAtStrictlyAfter;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (transactionStatus !== undefined) {
                localVarQueryParameter['transaction.status'] = transactionStatus;
            }

            if (existsRecommendedSolution !== undefined) {
                localVarQueryParameter['exists[recommendedSolution]'] = existsRecommendedSolution;
            }

            if (existsChosenSolution !== undefined) {
                localVarQueryParameter['exists[chosenSolution]'] = existsChosenSolution;
            }

            if (existsCounterSolution !== undefined) {
                localVarQueryParameter['exists[counterSolution]'] = existsCounterSolution;
            }

            if (existsPlatformSolution !== undefined) {
                localVarQueryParameter['exists[platformSolution]'] = existsPlatformSolution;
            }

            if (metadata) {
                localVarQueryParameter['metadata[]'] = metadata.join(COLLECTION_FORMATS.csv);
            }

            if (transactionMetadata) {
                localVarQueryParameter['transaction.metadata[]'] = transactionMetadata.join(COLLECTION_FORMATS.csv);
            }

            if (transactionOfferMetadata) {
                localVarQueryParameter['transaction.offer.metadata[]'] = transactionOfferMetadata.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a draft dispute to be filled by an alleged aggrieved customer. Do not use that endpoint if the transaction took place using our safe-checkout tunnel. This endpoint return a unique URL that can be accessed by both the complainant and seller (if individual).  **Note:** You can generate at your own discretion tokens for both parties, thus avoiding the secondary authentication.
         * @summary Draft a standalone Dispute
         * @param {DisputeIndependentWrite} disputeIndependentWrite The new Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesPost: async (disputeIndependentWrite: DisputeIndependentWrite, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'disputeIndependentWrite' is not null or undefined
            assertParamExists('apiDisputesPost', 'disputeIndependentWrite', disputeIndependentWrite)
            const localVarPath = `/disputes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disputeIndependentWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Only the buyer/complainant** can dismiss the case immediately. Otherwise, the support can but in a limited ranges of Dispute status.
         * @summary Abandon claims on Dispute
         * @param {string} ulid Dispute identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidDelete: async (ulid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidDelete', 'ulid', ulid)
            const localVarPath = `/disputes/{ulid}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_WRITE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Dispute resource.
         * @summary Retrieves a Dispute resource.
         * @param {string} ulid Dispute identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidGet: async (ulid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidGet', 'ulid', ulid)
            const localVarPath = `/disputes/{ulid}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the Dispute resource.
         * @summary Update the Dispute
         * @param {string} ulid Dispute identifier
         * @param {DisputeUpdate} disputeUpdate The updated Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidPatch: async (ulid: string, disputeUpdate: DisputeUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidPatch', 'ulid', ulid)
            // verify required parameter 'disputeUpdate' is not null or undefined
            assertParamExists('apiDisputesUlidPatch', 'disputeUpdate', disputeUpdate)
            const localVarPath = `/disputes/{ulid}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_ARBITRATION"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disputeUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Only authenticated** complainant and seller **CAN** issue an evaluation **WHEN** the dispute reached a final state.
         * @summary Submit an Evaluation for the Dispute
         * @param {string} ulid Dispute identifier
         * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevaluationsPost: async (ulid: string, evaluationWrite: EvaluationWrite, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidevaluationsPost', 'ulid', ulid)
            // verify required parameter 'evaluationWrite' is not null or undefined
            assertParamExists('apiDisputesUlidevaluationsPost', 'evaluationWrite', evaluationWrite)
            const localVarPath = `/disputes/{ulid}/evaluations`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(evaluationWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of Evidence resources.
         * @summary Retrieve all Evidences in Dispute
         * @param {string} ulid Dispute identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesGetCollection: async (ulid: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidevidencesGetCollection', 'ulid', ulid)
            const localVarPath = `/disputes/{ulid}/evidences`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Evidence resource.
         * @summary Withdraw an Evidence from a Dispute
         * @param {string} ulid Dispute identifier
         * @param {string} id Evidence identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesIdDelete: async (ulid: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidevidencesIdDelete', 'ulid', ulid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiDisputesUlidevidencesIdDelete', 'id', id)
            const localVarPath = `/disputes/{ulid}/evidences/{id}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Media resource.
         * @summary Upload attachment in regard of described Evidence
         * @param {string} ulid Dispute identifier
         * @param {string} id Evidence identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesIdmediaPost: async (ulid: string, id: string, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidevidencesIdmediaPost', 'ulid', ulid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiDisputesUlidevidencesIdmediaPost', 'id', id)
            const localVarPath = `/disputes/{ulid}/evidences/{id}/media`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This action does not held the actual upload, you will have to do the upload in a dedicated request.
         * @summary Submit an Evidence to the Dispute case
         * @param {string} ulid Dispute identifier
         * @param {EvidenceWrite} evidenceWrite The new Evidence resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesPost: async (ulid: string, evidenceWrite: EvidenceWrite, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidevidencesPost', 'ulid', ulid)
            // verify required parameter 'evidenceWrite' is not null or undefined
            assertParamExists('apiDisputesUlidevidencesPost', 'evidenceWrite', evidenceWrite)
            const localVarPath = `/disputes/{ulid}/evidences`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(evidenceWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of Parcel resources.
         * @summary Retrieves the collection of Parcel resources.
         * @param {string} ulid Dispute identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidparcelsGetCollection: async (ulid: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidparcelsGetCollection', 'ulid', ulid)
            const localVarPath = `/disputes/{ulid}/parcels`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Parcel resource.
         * @summary Removes the Parcel resource.
         * @param {string} ulid Dispute identifier
         * @param {string} id Parcel identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidparcelsIdDelete: async (ulid: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidparcelsIdDelete', 'ulid', ulid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiDisputesUlidparcelsIdDelete', 'id', id)
            const localVarPath = `/disputes/{ulid}/parcels/{id}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Parcel resource.
         * @summary Creates a Parcel resource.
         * @param {string} ulid Dispute identifier
         * @param {ParcelWrite} parcelWrite The new Parcel resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidparcelsPost: async (ulid: string, parcelWrite: ParcelWrite, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiDisputesUlidparcelsPost', 'ulid', ulid)
            // verify required parameter 'parcelWrite' is not null or undefined
            assertParamExists('apiDisputesUlidparcelsPost', 'parcelWrite', parcelWrite)
            const localVarPath = `/disputes/{ulid}/parcels`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(parcelWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Media resource.
         * @summary Upload a picture for a given Offer
         * @param {string} ulid Offer identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasPost: async (ulid: string, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidmediasPost', 'ulid', ulid)
            const localVarPath = `/offers/{ulid}/medias`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResolutionCenterApi - functional programming interface
 * @export
 */
export const ResolutionCenterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResolutionCenterApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Dispute resources.
         * @summary Retrieves the collection of Dispute resources.
         * @param {number} [page] The collection page number
         * @param {'asc' | 'desc'} [orderCreatedAt] 
         * @param {'asc' | 'desc'} [orderStatus] 
         * @param {'asc' | 'desc'} [orderUpdatedAt] 
         * @param {string} [transactionOfferTitle] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {'CREATED' | 'SUBMITTED' | 'OPENED' | 'ABANDONED' | 'PENDING' | 'OBJECTED' | 'SHIPPED' | 'IN_TRANSIT' | 'RETURNED' | 'DISMISSED' | 'RESOLVED'} [status] Filter on a limited subset of status
         * @param {'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED'} [transactionStatus] Filter on a limited subset of transaction.status
         * @param {boolean} [existsRecommendedSolution] 
         * @param {boolean} [existsChosenSolution] 
         * @param {boolean} [existsCounterSolution] 
         * @param {boolean} [existsPlatformSolution] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [transactionMetadata] Flattened OrderedMap for transaction.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [transactionOfferMetadata] Flattened OrderedMap for transaction.offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesGetCollection(page?: number, orderCreatedAt?: 'asc' | 'desc', orderStatus?: 'asc' | 'desc', orderUpdatedAt?: 'asc' | 'desc', transactionOfferTitle?: string, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, status?: 'CREATED' | 'SUBMITTED' | 'OPENED' | 'ABANDONED' | 'PENDING' | 'OBJECTED' | 'SHIPPED' | 'IN_TRANSIT' | 'RETURNED' | 'DISMISSED' | 'RESOLVED', transactionStatus?: 'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED', existsRecommendedSolution?: boolean, existsChosenSolution?: boolean, existsCounterSolution?: boolean, existsPlatformSolution?: boolean, metadata?: Array<string>, transactionMetadata?: Array<string>, transactionOfferMetadata?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DisputeCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesGetCollection(page, orderCreatedAt, orderStatus, orderUpdatedAt, transactionOfferTitle, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, status, transactionStatus, existsRecommendedSolution, existsChosenSolution, existsCounterSolution, existsPlatformSolution, metadata, transactionMetadata, transactionOfferMetadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a draft dispute to be filled by an alleged aggrieved customer. Do not use that endpoint if the transaction took place using our safe-checkout tunnel. This endpoint return a unique URL that can be accessed by both the complainant and seller (if individual).  **Note:** You can generate at your own discretion tokens for both parties, thus avoiding the secondary authentication.
         * @summary Draft a standalone Dispute
         * @param {DisputeIndependentWrite} disputeIndependentWrite The new Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesPost(disputeIndependentWrite: DisputeIndependentWrite, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisputePostCreationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesPost(disputeIndependentWrite, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Only the buyer/complainant** can dismiss the case immediately. Otherwise, the support can but in a limited ranges of Dispute status.
         * @summary Abandon claims on Dispute
         * @param {string} ulid Dispute identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidDelete(ulid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidDelete(ulid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Dispute resource.
         * @summary Retrieves a Dispute resource.
         * @param {string} ulid Dispute identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidGet(ulid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisputeRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidGet(ulid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the Dispute resource.
         * @summary Update the Dispute
         * @param {string} ulid Dispute identifier
         * @param {DisputeUpdate} disputeUpdate The updated Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidPatch(ulid: string, disputeUpdate: DisputeUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisputeRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidPatch(ulid, disputeUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Only authenticated** complainant and seller **CAN** issue an evaluation **WHEN** the dispute reached a final state.
         * @summary Submit an Evaluation for the Dispute
         * @param {string} ulid Dispute identifier
         * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidevaluationsPost(ulid: string, evaluationWrite: EvaluationWrite, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EvaluationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidevaluationsPost(ulid, evaluationWrite, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the collection of Evidence resources.
         * @summary Retrieve all Evidences in Dispute
         * @param {string} ulid Dispute identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidevidencesGetCollection(ulid: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EvidenceRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidevidencesGetCollection(ulid, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes the Evidence resource.
         * @summary Withdraw an Evidence from a Dispute
         * @param {string} ulid Dispute identifier
         * @param {string} id Evidence identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidevidencesIdDelete(ulid: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidevidencesIdDelete(ulid, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Media resource.
         * @summary Upload attachment in regard of described Evidence
         * @param {string} ulid Dispute identifier
         * @param {string} id Evidence identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidevidencesIdmediaPost(ulid: string, id: string, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidevidencesIdmediaPost(ulid, id, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This action does not held the actual upload, you will have to do the upload in a dedicated request.
         * @summary Submit an Evidence to the Dispute case
         * @param {string} ulid Dispute identifier
         * @param {EvidenceWrite} evidenceWrite The new Evidence resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidevidencesPost(ulid: string, evidenceWrite: EvidenceWrite, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EvidenceRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidevidencesPost(ulid, evidenceWrite, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the collection of Parcel resources.
         * @summary Retrieves the collection of Parcel resources.
         * @param {string} ulid Dispute identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidparcelsGetCollection(ulid: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidparcelsGetCollection(ulid, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes the Parcel resource.
         * @summary Removes the Parcel resource.
         * @param {string} ulid Dispute identifier
         * @param {string} id Parcel identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidparcelsIdDelete(ulid: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidparcelsIdDelete(ulid, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Parcel resource.
         * @summary Creates a Parcel resource.
         * @param {string} ulid Dispute identifier
         * @param {ParcelWrite} parcelWrite The new Parcel resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDisputesUlidparcelsPost(ulid: string, parcelWrite: ParcelWrite, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParcelRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDisputesUlidparcelsPost(ulid, parcelWrite, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Media resource.
         * @summary Upload a picture for a given Offer
         * @param {string} ulid Offer identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidmediasPost(ulid: string, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidmediasPost(ulid, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ResolutionCenterApi - factory interface
 * @export
 */
export const ResolutionCenterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResolutionCenterApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Dispute resources.
         * @summary Retrieves the collection of Dispute resources.
         * @param {number} [page] The collection page number
         * @param {'asc' | 'desc'} [orderCreatedAt] 
         * @param {'asc' | 'desc'} [orderStatus] 
         * @param {'asc' | 'desc'} [orderUpdatedAt] 
         * @param {string} [transactionOfferTitle] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {'CREATED' | 'SUBMITTED' | 'OPENED' | 'ABANDONED' | 'PENDING' | 'OBJECTED' | 'SHIPPED' | 'IN_TRANSIT' | 'RETURNED' | 'DISMISSED' | 'RESOLVED'} [status] Filter on a limited subset of status
         * @param {'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED'} [transactionStatus] Filter on a limited subset of transaction.status
         * @param {boolean} [existsRecommendedSolution] 
         * @param {boolean} [existsChosenSolution] 
         * @param {boolean} [existsCounterSolution] 
         * @param {boolean} [existsPlatformSolution] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [transactionMetadata] Flattened OrderedMap for transaction.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [transactionOfferMetadata] Flattened OrderedMap for transaction.offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesGetCollection(page?: number, orderCreatedAt?: 'asc' | 'desc', orderStatus?: 'asc' | 'desc', orderUpdatedAt?: 'asc' | 'desc', transactionOfferTitle?: string, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, status?: 'CREATED' | 'SUBMITTED' | 'OPENED' | 'ABANDONED' | 'PENDING' | 'OBJECTED' | 'SHIPPED' | 'IN_TRANSIT' | 'RETURNED' | 'DISMISSED' | 'RESOLVED', transactionStatus?: 'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED', existsRecommendedSolution?: boolean, existsChosenSolution?: boolean, existsCounterSolution?: boolean, existsPlatformSolution?: boolean, metadata?: Array<string>, transactionMetadata?: Array<string>, transactionOfferMetadata?: Array<string>, options?: any): AxiosPromise<Array<DisputeCollectionRead>> {
            return localVarFp.apiDisputesGetCollection(page, orderCreatedAt, orderStatus, orderUpdatedAt, transactionOfferTitle, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, status, transactionStatus, existsRecommendedSolution, existsChosenSolution, existsCounterSolution, existsPlatformSolution, metadata, transactionMetadata, transactionOfferMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a draft dispute to be filled by an alleged aggrieved customer. Do not use that endpoint if the transaction took place using our safe-checkout tunnel. This endpoint return a unique URL that can be accessed by both the complainant and seller (if individual).  **Note:** You can generate at your own discretion tokens for both parties, thus avoiding the secondary authentication.
         * @summary Draft a standalone Dispute
         * @param {DisputeIndependentWrite} disputeIndependentWrite The new Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesPost(disputeIndependentWrite: DisputeIndependentWrite, options?: any): AxiosPromise<DisputePostCreationRead> {
            return localVarFp.apiDisputesPost(disputeIndependentWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * **Only the buyer/complainant** can dismiss the case immediately. Otherwise, the support can but in a limited ranges of Dispute status.
         * @summary Abandon claims on Dispute
         * @param {string} ulid Dispute identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidDelete(ulid: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiDisputesUlidDelete(ulid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Dispute resource.
         * @summary Retrieves a Dispute resource.
         * @param {string} ulid Dispute identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidGet(ulid: string, options?: any): AxiosPromise<DisputeRead> {
            return localVarFp.apiDisputesUlidGet(ulid, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the Dispute resource.
         * @summary Update the Dispute
         * @param {string} ulid Dispute identifier
         * @param {DisputeUpdate} disputeUpdate The updated Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidPatch(ulid: string, disputeUpdate: DisputeUpdate, options?: any): AxiosPromise<DisputeRead> {
            return localVarFp.apiDisputesUlidPatch(ulid, disputeUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * **Only authenticated** complainant and seller **CAN** issue an evaluation **WHEN** the dispute reached a final state.
         * @summary Submit an Evaluation for the Dispute
         * @param {string} ulid Dispute identifier
         * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevaluationsPost(ulid: string, evaluationWrite: EvaluationWrite, options?: any): AxiosPromise<EvaluationRead> {
            return localVarFp.apiDisputesUlidevaluationsPost(ulid, evaluationWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of Evidence resources.
         * @summary Retrieve all Evidences in Dispute
         * @param {string} ulid Dispute identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesGetCollection(ulid: string, page?: number, options?: any): AxiosPromise<Array<EvidenceRead>> {
            return localVarFp.apiDisputesUlidevidencesGetCollection(ulid, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Evidence resource.
         * @summary Withdraw an Evidence from a Dispute
         * @param {string} ulid Dispute identifier
         * @param {string} id Evidence identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesIdDelete(ulid: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiDisputesUlidevidencesIdDelete(ulid, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Media resource.
         * @summary Upload attachment in regard of described Evidence
         * @param {string} ulid Dispute identifier
         * @param {string} id Evidence identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesIdmediaPost(ulid: string, id: string, file?: File, options?: any): AxiosPromise<MediaRead> {
            return localVarFp.apiDisputesUlidevidencesIdmediaPost(ulid, id, file, options).then((request) => request(axios, basePath));
        },
        /**
         * This action does not held the actual upload, you will have to do the upload in a dedicated request.
         * @summary Submit an Evidence to the Dispute case
         * @param {string} ulid Dispute identifier
         * @param {EvidenceWrite} evidenceWrite The new Evidence resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidevidencesPost(ulid: string, evidenceWrite: EvidenceWrite, options?: any): AxiosPromise<EvidenceRead> {
            return localVarFp.apiDisputesUlidevidencesPost(ulid, evidenceWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of Parcel resources.
         * @summary Retrieves the collection of Parcel resources.
         * @param {string} ulid Dispute identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidparcelsGetCollection(ulid: string, page?: number, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.apiDisputesUlidparcelsGetCollection(ulid, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Parcel resource.
         * @summary Removes the Parcel resource.
         * @param {string} ulid Dispute identifier
         * @param {string} id Parcel identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidparcelsIdDelete(ulid: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiDisputesUlidparcelsIdDelete(ulid, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Parcel resource.
         * @summary Creates a Parcel resource.
         * @param {string} ulid Dispute identifier
         * @param {ParcelWrite} parcelWrite The new Parcel resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDisputesUlidparcelsPost(ulid: string, parcelWrite: ParcelWrite, options?: any): AxiosPromise<ParcelRead> {
            return localVarFp.apiDisputesUlidparcelsPost(ulid, parcelWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Media resource.
         * @summary Upload a picture for a given Offer
         * @param {string} ulid Offer identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasPost(ulid: string, file?: File, options?: any): AxiosPromise<MediaRead> {
            return localVarFp.apiOffersUlidmediasPost(ulid, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResolutionCenterApi - object-oriented interface
 * @export
 * @class ResolutionCenterApi
 * @extends {BaseAPI}
 */
export class ResolutionCenterApi extends BaseAPI {
    /**
     * Retrieves the collection of Dispute resources.
     * @summary Retrieves the collection of Dispute resources.
     * @param {number} [page] The collection page number
     * @param {'asc' | 'desc'} [orderCreatedAt] 
     * @param {'asc' | 'desc'} [orderStatus] 
     * @param {'asc' | 'desc'} [orderUpdatedAt] 
     * @param {string} [transactionOfferTitle] 
     * @param {string} [createdAtBefore] 
     * @param {string} [createdAtStrictlyBefore] 
     * @param {string} [createdAtAfter] 
     * @param {string} [createdAtStrictlyAfter] 
     * @param {'CREATED' | 'SUBMITTED' | 'OPENED' | 'ABANDONED' | 'PENDING' | 'OBJECTED' | 'SHIPPED' | 'IN_TRANSIT' | 'RETURNED' | 'DISMISSED' | 'RESOLVED'} [status] Filter on a limited subset of status
     * @param {'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED'} [transactionStatus] Filter on a limited subset of transaction.status
     * @param {boolean} [existsRecommendedSolution] 
     * @param {boolean} [existsChosenSolution] 
     * @param {boolean} [existsCounterSolution] 
     * @param {boolean} [existsPlatformSolution] 
     * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {Array<string>} [transactionMetadata] Flattened OrderedMap for transaction.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {Array<string>} [transactionOfferMetadata] Flattened OrderedMap for transaction.offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesGetCollection(page?: number, orderCreatedAt?: 'asc' | 'desc', orderStatus?: 'asc' | 'desc', orderUpdatedAt?: 'asc' | 'desc', transactionOfferTitle?: string, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, status?: 'CREATED' | 'SUBMITTED' | 'OPENED' | 'ABANDONED' | 'PENDING' | 'OBJECTED' | 'SHIPPED' | 'IN_TRANSIT' | 'RETURNED' | 'DISMISSED' | 'RESOLVED', transactionStatus?: 'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED', existsRecommendedSolution?: boolean, existsChosenSolution?: boolean, existsCounterSolution?: boolean, existsPlatformSolution?: boolean, metadata?: Array<string>, transactionMetadata?: Array<string>, transactionOfferMetadata?: Array<string>, options?: AxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesGetCollection(page, orderCreatedAt, orderStatus, orderUpdatedAt, transactionOfferTitle, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, status, transactionStatus, existsRecommendedSolution, existsChosenSolution, existsCounterSolution, existsPlatformSolution, metadata, transactionMetadata, transactionOfferMetadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a draft dispute to be filled by an alleged aggrieved customer. Do not use that endpoint if the transaction took place using our safe-checkout tunnel. This endpoint return a unique URL that can be accessed by both the complainant and seller (if individual).  **Note:** You can generate at your own discretion tokens for both parties, thus avoiding the secondary authentication.
     * @summary Draft a standalone Dispute
     * @param {DisputeIndependentWrite} disputeIndependentWrite The new Dispute resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesPost(disputeIndependentWrite: DisputeIndependentWrite, options?: AxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesPost(disputeIndependentWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Only the buyer/complainant** can dismiss the case immediately. Otherwise, the support can but in a limited ranges of Dispute status.
     * @summary Abandon claims on Dispute
     * @param {string} ulid Dispute identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidDelete(ulid: string, options?: AxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidDelete(ulid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Dispute resource.
     * @summary Retrieves a Dispute resource.
     * @param {string} ulid Dispute identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidGet(ulid: string, options?: AxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidGet(ulid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the Dispute resource.
     * @summary Update the Dispute
     * @param {string} ulid Dispute identifier
     * @param {DisputeUpdate} disputeUpdate The updated Dispute resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidPatch(ulid: string, disputeUpdate: DisputeUpdate, options?: AxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidPatch(ulid, disputeUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Only authenticated** complainant and seller **CAN** issue an evaluation **WHEN** the dispute reached a final state.
     * @summary Submit an Evaluation for the Dispute
     * @param {string} ulid Dispute identifier
     * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidevaluationsPost(ulid: string, evaluationWrite: EvaluationWrite, options?: AxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidevaluationsPost(ulid, evaluationWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of Evidence resources.
     * @summary Retrieve all Evidences in Dispute
     * @param {string} ulid Dispute identifier
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidevidencesGetCollection(ulid: string, page?: number, options?: AxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidevidencesGetCollection(ulid, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Evidence resource.
     * @summary Withdraw an Evidence from a Dispute
     * @param {string} ulid Dispute identifier
     * @param {string} id Evidence identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidevidencesIdDelete(ulid: string, id: string, options?: AxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidevidencesIdDelete(ulid, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Media resource.
     * @summary Upload attachment in regard of described Evidence
     * @param {string} ulid Dispute identifier
     * @param {string} id Evidence identifier
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidevidencesIdmediaPost(ulid: string, id: string, file?: File, options?: AxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidevidencesIdmediaPost(ulid, id, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This action does not held the actual upload, you will have to do the upload in a dedicated request.
     * @summary Submit an Evidence to the Dispute case
     * @param {string} ulid Dispute identifier
     * @param {EvidenceWrite} evidenceWrite The new Evidence resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidevidencesPost(ulid: string, evidenceWrite: EvidenceWrite, options?: AxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidevidencesPost(ulid, evidenceWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of Parcel resources.
     * @summary Retrieves the collection of Parcel resources.
     * @param {string} ulid Dispute identifier
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidparcelsGetCollection(ulid: string, page?: number, options?: AxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidparcelsGetCollection(ulid, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Parcel resource.
     * @summary Removes the Parcel resource.
     * @param {string} ulid Dispute identifier
     * @param {string} id Parcel identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidparcelsIdDelete(ulid: string, id: string, options?: AxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidparcelsIdDelete(ulid, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Parcel resource.
     * @summary Creates a Parcel resource.
     * @param {string} ulid Dispute identifier
     * @param {ParcelWrite} parcelWrite The new Parcel resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiDisputesUlidparcelsPost(ulid: string, parcelWrite: ParcelWrite, options?: AxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiDisputesUlidparcelsPost(ulid, parcelWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Media resource.
     * @summary Upload a picture for a given Offer
     * @param {string} ulid Offer identifier
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionCenterApi
     */
    public apiOffersUlidmediasPost(ulid: string, file?: File, options?: AxiosRequestConfig) {
        return ResolutionCenterApiFp(this.configuration).apiOffersUlidmediasPost(ulid, file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SafeCheckoutApi - axios parameter creator
 * @export
 */
export const SafeCheckoutApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Offer resources.
         * @summary Read issued Offers
         * @param {number} [page] The collection page number
         * @param {string} [title] 
         * @param {string} [publicUrl] 
         * @param {Array<string>} [publicUrl2] 
         * @param {number} [unitPrice] 
         * @param {Array<number>} [unitPrice2] 
         * @param {number} [itemCount] 
         * @param {Array<number>} [itemCount2] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {'service' | 'physical_item' | 'dematerialized_item' | 'rent_item'} [nature] Filter on a limited subset of nature
         * @param {'NEW' | 'USED' | 'DAMAGED' | 'DETERIORATED' | 'UNRECOVERABLE'} [condition] Filter on a limited subset of condition
         * @param {boolean} [shippingAllowed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersGetCollection: async (page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: number, unitPrice2?: Array<number>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, nature?: 'service' | 'physical_item' | 'dematerialized_item' | 'rent_item', condition?: 'NEW' | 'USED' | 'DAMAGED' | 'DETERIORATED' | 'UNRECOVERABLE', shippingAllowed?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/offers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (publicUrl !== undefined) {
                localVarQueryParameter['publicUrl'] = publicUrl;
            }

            if (publicUrl2) {
                localVarQueryParameter['publicUrl[]'] = publicUrl2;
            }

            if (unitPrice !== undefined) {
                localVarQueryParameter['unitPrice'] = unitPrice;
            }

            if (unitPrice2) {
                localVarQueryParameter['unitPrice[]'] = unitPrice2;
            }

            if (itemCount !== undefined) {
                localVarQueryParameter['itemCount'] = itemCount;
            }

            if (itemCount2) {
                localVarQueryParameter['itemCount[]'] = itemCount2;
            }

            if (createdAtBefore !== undefined) {
                localVarQueryParameter['createdAt[before]'] = createdAtBefore;
            }

            if (createdAtStrictlyBefore !== undefined) {
                localVarQueryParameter['createdAt[strictly_before]'] = createdAtStrictlyBefore;
            }

            if (createdAtAfter !== undefined) {
                localVarQueryParameter['createdAt[after]'] = createdAtAfter;
            }

            if (createdAtStrictlyAfter !== undefined) {
                localVarQueryParameter['createdAt[strictly_after]'] = createdAtStrictlyAfter;
            }

            if (metadata) {
                localVarQueryParameter['metadata[]'] = metadata.join(COLLECTION_FORMATS.csv);
            }

            if (offerMetadata) {
                localVarQueryParameter['offer.metadata[]'] = offerMetadata.join(COLLECTION_FORMATS.csv);
            }

            if (nature !== undefined) {
                localVarQueryParameter['nature'] = nature;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }

            if (shippingAllowed !== undefined) {
                localVarQueryParameter['shippingAllowed'] = shippingAllowed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publish an offer so that you can safely retrieve a safe-checkout unique link from us
         * @summary Create an Offer and retrieve url
         * @param {OfferIndependentWrite} offerIndependentWrite The new Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersPost: async (offerIndependentWrite: OfferIndependentWrite, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'offerIndependentWrite' is not null or undefined
            assertParamExists('apiOffersPost', 'offerIndependentWrite', offerIndependentWrite)
            const localVarPath = `/offers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(offerIndependentWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Offer resource.
         * @summary Read an Offer
         * @param {string} ulid Offer identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidGet: async (ulid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidGet', 'ulid', ulid)
            const localVarPath = `/offers/{ulid}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Media resource.
         * @summary Removes the Media resource.
         * @param {string} ulid Offer identifier
         * @param {string} id Media identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasIdDelete: async (ulid: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidmediasIdDelete', 'ulid', ulid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOffersUlidmediasIdDelete', 'id', id)
            const localVarPath = `/offers/{ulid}/medias/{id}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Media resource.
         * @summary Upload a picture for a given Offer
         * @param {string} ulid Offer identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasPost: async (ulid: string, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidmediasPost', 'ulid', ulid)
            const localVarPath = `/offers/{ulid}/medias`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of Transaction resources.
         * @summary Retrieve Payment Intents for Offer
         * @param {string} ulid Offer identifier
         * @param {number} [page] The collection page number
         * @param {'asc' | 'desc'} [orderStatus] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED'} [status] Filter on a limited subset of status
         * @param {boolean} [existsDispute] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidtransactionsGetCollection: async (ulid: string, page?: number, orderStatus?: 'asc' | 'desc', metadata?: Array<string>, status?: 'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED', existsDispute?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidtransactionsGetCollection', 'ulid', ulid)
            const localVarPath = `/offers/{ulid}/transactions`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderStatus !== undefined) {
                localVarQueryParameter['order[status]'] = orderStatus;
            }

            if (metadata) {
                localVarQueryParameter['metadata[]'] = metadata.join(COLLECTION_FORMATS.csv);
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (existsDispute !== undefined) {
                localVarQueryParameter['exists[dispute]'] = existsDispute;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Only authenticated** buyer and seller **CAN** issue an evaluation **WHEN** the transaction reached a final state.
         * @summary Submit an Evaluation for the Offer
         * @param {string} ulid Dispute identifier
         * @param {string} id Transaction identifier
         * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidtransactionsIdevaluationsPost: async (ulid: string, id: string, evaluationWrite: EvaluationWrite, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidtransactionsIdevaluationsPost', 'ulid', ulid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOffersUlidtransactionsIdevaluationsPost', 'id', id)
            // verify required parameter 'evaluationWrite' is not null or undefined
            assertParamExists('apiOffersUlidtransactionsIdevaluationsPost', 'evaluationWrite', evaluationWrite)
            const localVarPath = `/offers/{ulid}/transactions/{id}/evaluations`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(evaluationWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cannot be used outside of a Persona (buyer)
         * @summary Create a Payment Intent for Offer
         * @param {string} ulid Offer identifier
         * @param {object} body The new Transaction resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidtransactionsPost: async (ulid: string, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidtransactionsPost', 'ulid', ulid)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('apiOffersUlidtransactionsPost', 'body', body)
            const localVarPath = `/offers/{ulid}/transactions`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * That goes without says, if that **Offer** have a _Transaction_ **that is ongoing**, you **MAY NOT** revoke the **Offer**.
         * @summary Revoke an Offer for given Persona
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdoffersDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdoffersDelete', 'id', id)
            const localVarPath = `/personas/{id}/offers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of Offer resources.
         * @summary List or Search Offers for given Persona
         * @param {string} id Persona identifier
         * @param {number} [page] The collection page number
         * @param {string} [title] 
         * @param {string} [publicUrl] 
         * @param {Array<string>} [publicUrl2] 
         * @param {number} [unitPrice] 
         * @param {Array<number>} [unitPrice2] 
         * @param {number} [itemCount] 
         * @param {Array<number>} [itemCount2] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {'service' | 'physical_item' | 'dematerialized_item' | 'rent_item'} [nature] Filter on a limited subset of nature
         * @param {'NEW' | 'USED' | 'DAMAGED' | 'DETERIORATED' | 'UNRECOVERABLE'} [condition] Filter on a limited subset of condition
         * @param {boolean} [shippingAllowed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdoffersGetCollection: async (id: string, page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: number, unitPrice2?: Array<number>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, nature?: 'service' | 'physical_item' | 'dematerialized_item' | 'rent_item', condition?: 'NEW' | 'USED' | 'DAMAGED' | 'DETERIORATED' | 'UNRECOVERABLE', shippingAllowed?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdoffersGetCollection', 'id', id)
            const localVarPath = `/personas/{id}/offers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (publicUrl !== undefined) {
                localVarQueryParameter['publicUrl'] = publicUrl;
            }

            if (publicUrl2) {
                localVarQueryParameter['publicUrl[]'] = publicUrl2;
            }

            if (unitPrice !== undefined) {
                localVarQueryParameter['unitPrice'] = unitPrice;
            }

            if (unitPrice2) {
                localVarQueryParameter['unitPrice[]'] = unitPrice2;
            }

            if (itemCount !== undefined) {
                localVarQueryParameter['itemCount'] = itemCount;
            }

            if (itemCount2) {
                localVarQueryParameter['itemCount[]'] = itemCount2;
            }

            if (createdAtBefore !== undefined) {
                localVarQueryParameter['createdAt[before]'] = createdAtBefore;
            }

            if (createdAtStrictlyBefore !== undefined) {
                localVarQueryParameter['createdAt[strictly_before]'] = createdAtStrictlyBefore;
            }

            if (createdAtAfter !== undefined) {
                localVarQueryParameter['createdAt[after]'] = createdAtAfter;
            }

            if (createdAtStrictlyAfter !== undefined) {
                localVarQueryParameter['createdAt[strictly_after]'] = createdAtStrictlyAfter;
            }

            if (metadata) {
                localVarQueryParameter['metadata[]'] = metadata.join(COLLECTION_FORMATS.csv);
            }

            if (offerMetadata) {
                localVarQueryParameter['offer.metadata[]'] = offerMetadata.join(COLLECTION_FORMATS.csv);
            }

            if (nature !== undefined) {
                localVarQueryParameter['nature'] = nature;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }

            if (shippingAllowed !== undefined) {
                localVarQueryParameter['shippingAllowed'] = shippingAllowed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the Offer resource.
         * @summary Update an Offer for given Persona
         * @param {string} id Persona identifier
         * @param {OfferUpdate} offerUpdate The updated Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdoffersPatch: async (id: string, offerUpdate: OfferUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdoffersPatch', 'id', id)
            // verify required parameter 'offerUpdate' is not null or undefined
            assertParamExists('apiPersonasIdoffersPatch', 'offerUpdate', offerUpdate)
            const localVarPath = `/personas/{id}/offers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(offerUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Offer resource.
         * @summary Create an Offer for given Persona
         * @param {string} id Persona identifier
         * @param {OfferWrite} offerWrite The new Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdoffersPost: async (id: string, offerWrite: OfferWrite, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdoffersPost', 'id', id)
            // verify required parameter 'offerWrite' is not null or undefined
            assertParamExists('apiPersonasIdoffersPost', 'offerWrite', offerWrite)
            const localVarPath = `/personas/{id}/offers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(offerWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of Transaction resources.
         * @summary Retrieves the collection of Transaction resources.
         * @param {number} [page] The collection page number
         * @param {'asc' | 'desc'} [orderStatus] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED'} [status] Filter on a limited subset of status
         * @param {boolean} [existsDispute] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsGetCollection: async (page?: number, orderStatus?: 'asc' | 'desc', metadata?: Array<string>, status?: 'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED', existsDispute?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderStatus !== undefined) {
                localVarQueryParameter['order[status]'] = orderStatus;
            }

            if (metadata) {
                localVarQueryParameter['metadata[]'] = metadata.join(COLLECTION_FORMATS.csv);
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (existsDispute !== undefined) {
                localVarQueryParameter['exists[dispute]'] = existsDispute;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Only the buyer/complainant** can dismiss the case immediately. Otherwise, the support can but in a limited ranges of Dispute status.
         * @summary Abandon claims on Dispute
         * @param {string} ulid Transaction identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUliddisputeDelete: async (ulid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiTransactionsUliddisputeDelete', 'ulid', ulid)
            const localVarPath = `/transactions/{ulid}/dispute`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_ARBITRATION"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Dispute resource.
         * @summary Read Dispute from existing Transaction
         * @param {string} ulid Transaction identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUliddisputeGet: async (ulid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiTransactionsUliddisputeGet', 'ulid', ulid)
            const localVarPath = `/transactions/{ulid}/dispute`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only authenticated Persona can interact with a Dispute object. Usually through our web application.
         * @summary Interact with a Dispute
         * @param {string} ulid Transaction identifier
         * @param {DisputeUpdate} disputeUpdate The updated Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUliddisputePatch: async (ulid: string, disputeUpdate: DisputeUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiTransactionsUliddisputePatch', 'ulid', ulid)
            // verify required parameter 'disputeUpdate' is not null or undefined
            assertParamExists('apiTransactionsUliddisputePatch', 'disputeUpdate', disputeUpdate)
            const localVarPath = `/transactions/{ulid}/dispute`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disputeUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Dispute resource.
         * @summary Open a Dispute related to existing Transaction
         * @param {string} ulid Transaction identifier
         * @param {DisputeWrite} disputeWrite The new Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUliddisputePost: async (ulid: string, disputeWrite: DisputeWrite, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiTransactionsUliddisputePost', 'ulid', ulid)
            // verify required parameter 'disputeWrite' is not null or undefined
            assertParamExists('apiTransactionsUliddisputePost', 'disputeWrite', disputeWrite)
            const localVarPath = `/transactions/{ulid}/dispute`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["DISPUTE_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disputeWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of Parcel resources.
         * @summary Read shipments from Transaction
         * @param {string} ulid Transaction identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidparcelsGetCollection: async (ulid: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiTransactionsUlidparcelsGetCollection', 'ulid', ulid)
            const localVarPath = `/transactions/{ulid}/parcels`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * No one except the support can do that manoeuvre.
         * @summary Withdraw shipment from Transaction
         * @param {string} ulid Transaction identifier
         * @param {string} id Parcel identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidparcelsIdDelete: async (ulid: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiTransactionsUlidparcelsIdDelete', 'ulid', ulid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiTransactionsUlidparcelsIdDelete', 'id', id)
            const localVarPath = `/transactions/{ulid}/parcels/{id}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Parcel resource.
         * @summary Manually declare package shipped for Transaction
         * @param {string} ulid Transaction identifier
         * @param {ParcelWrite} parcelWrite The new Parcel resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidparcelsPost: async (ulid: string, parcelWrite: ParcelWrite, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiTransactionsUlidparcelsPost', 'ulid', ulid)
            // verify required parameter 'parcelWrite' is not null or undefined
            assertParamExists('apiTransactionsUlidparcelsPost', 'parcelWrite', parcelWrite)
            const localVarPath = `/transactions/{ulid}/parcels`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(parcelWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SafeCheckoutApi - functional programming interface
 * @export
 */
export const SafeCheckoutApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SafeCheckoutApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Offer resources.
         * @summary Read issued Offers
         * @param {number} [page] The collection page number
         * @param {string} [title] 
         * @param {string} [publicUrl] 
         * @param {Array<string>} [publicUrl2] 
         * @param {number} [unitPrice] 
         * @param {Array<number>} [unitPrice2] 
         * @param {number} [itemCount] 
         * @param {Array<number>} [itemCount2] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {'service' | 'physical_item' | 'dematerialized_item' | 'rent_item'} [nature] Filter on a limited subset of nature
         * @param {'NEW' | 'USED' | 'DAMAGED' | 'DETERIORATED' | 'UNRECOVERABLE'} [condition] Filter on a limited subset of condition
         * @param {boolean} [shippingAllowed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersGetCollection(page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: number, unitPrice2?: Array<number>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, nature?: 'service' | 'physical_item' | 'dematerialized_item' | 'rent_item', condition?: 'NEW' | 'USED' | 'DAMAGED' | 'DETERIORATED' | 'UNRECOVERABLE', shippingAllowed?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OfferCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersGetCollection(page, title, publicUrl, publicUrl2, unitPrice, unitPrice2, itemCount, itemCount2, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, metadata, offerMetadata, nature, condition, shippingAllowed, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Publish an offer so that you can safely retrieve a safe-checkout unique link from us
         * @summary Create an Offer and retrieve url
         * @param {OfferIndependentWrite} offerIndependentWrite The new Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersPost(offerIndependentWrite: OfferIndependentWrite, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferPostCreationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersPost(offerIndependentWrite, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Offer resource.
         * @summary Read an Offer
         * @param {string} ulid Offer identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidGet(ulid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidGet(ulid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes the Media resource.
         * @summary Removes the Media resource.
         * @param {string} ulid Offer identifier
         * @param {string} id Media identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidmediasIdDelete(ulid: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidmediasIdDelete(ulid, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Media resource.
         * @summary Upload a picture for a given Offer
         * @param {string} ulid Offer identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidmediasPost(ulid: string, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidmediasPost(ulid, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the collection of Transaction resources.
         * @summary Retrieve Payment Intents for Offer
         * @param {string} ulid Offer identifier
         * @param {number} [page] The collection page number
         * @param {'asc' | 'desc'} [orderStatus] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED'} [status] Filter on a limited subset of status
         * @param {boolean} [existsDispute] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidtransactionsGetCollection(ulid: string, page?: number, orderStatus?: 'asc' | 'desc', metadata?: Array<string>, status?: 'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED', existsDispute?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidtransactionsGetCollection(ulid, page, orderStatus, metadata, status, existsDispute, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Only authenticated** buyer and seller **CAN** issue an evaluation **WHEN** the transaction reached a final state.
         * @summary Submit an Evaluation for the Offer
         * @param {string} ulid Dispute identifier
         * @param {string} id Transaction identifier
         * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidtransactionsIdevaluationsPost(ulid: string, id: string, evaluationWrite: EvaluationWrite, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EvaluationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidtransactionsIdevaluationsPost(ulid, id, evaluationWrite, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cannot be used outside of a Persona (buyer)
         * @summary Create a Payment Intent for Offer
         * @param {string} ulid Offer identifier
         * @param {object} body The new Transaction resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidtransactionsPost(ulid: string, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidtransactionsPost(ulid, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * That goes without says, if that **Offer** have a _Transaction_ **that is ongoing**, you **MAY NOT** revoke the **Offer**.
         * @summary Revoke an Offer for given Persona
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdoffersDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdoffersDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the collection of Offer resources.
         * @summary List or Search Offers for given Persona
         * @param {string} id Persona identifier
         * @param {number} [page] The collection page number
         * @param {string} [title] 
         * @param {string} [publicUrl] 
         * @param {Array<string>} [publicUrl2] 
         * @param {number} [unitPrice] 
         * @param {Array<number>} [unitPrice2] 
         * @param {number} [itemCount] 
         * @param {Array<number>} [itemCount2] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {'service' | 'physical_item' | 'dematerialized_item' | 'rent_item'} [nature] Filter on a limited subset of nature
         * @param {'NEW' | 'USED' | 'DAMAGED' | 'DETERIORATED' | 'UNRECOVERABLE'} [condition] Filter on a limited subset of condition
         * @param {boolean} [shippingAllowed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdoffersGetCollection(id: string, page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: number, unitPrice2?: Array<number>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, nature?: 'service' | 'physical_item' | 'dematerialized_item' | 'rent_item', condition?: 'NEW' | 'USED' | 'DAMAGED' | 'DETERIORATED' | 'UNRECOVERABLE', shippingAllowed?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OfferCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdoffersGetCollection(id, page, title, publicUrl, publicUrl2, unitPrice, unitPrice2, itemCount, itemCount2, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, metadata, offerMetadata, nature, condition, shippingAllowed, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the Offer resource.
         * @summary Update an Offer for given Persona
         * @param {string} id Persona identifier
         * @param {OfferUpdate} offerUpdate The updated Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdoffersPatch(id: string, offerUpdate: OfferUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdoffersPatch(id, offerUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Offer resource.
         * @summary Create an Offer for given Persona
         * @param {string} id Persona identifier
         * @param {OfferWrite} offerWrite The new Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdoffersPost(id: string, offerWrite: OfferWrite, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferPostCreationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdoffersPost(id, offerWrite, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the collection of Transaction resources.
         * @summary Retrieves the collection of Transaction resources.
         * @param {number} [page] The collection page number
         * @param {'asc' | 'desc'} [orderStatus] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED'} [status] Filter on a limited subset of status
         * @param {boolean} [existsDispute] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsGetCollection(page?: number, orderStatus?: 'asc' | 'desc', metadata?: Array<string>, status?: 'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED', existsDispute?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsGetCollection(page, orderStatus, metadata, status, existsDispute, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Only the buyer/complainant** can dismiss the case immediately. Otherwise, the support can but in a limited ranges of Dispute status.
         * @summary Abandon claims on Dispute
         * @param {string} ulid Transaction identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsUliddisputeDelete(ulid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsUliddisputeDelete(ulid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Dispute resource.
         * @summary Read Dispute from existing Transaction
         * @param {string} ulid Transaction identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsUliddisputeGet(ulid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisputeRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsUliddisputeGet(ulid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Only authenticated Persona can interact with a Dispute object. Usually through our web application.
         * @summary Interact with a Dispute
         * @param {string} ulid Transaction identifier
         * @param {DisputeUpdate} disputeUpdate The updated Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsUliddisputePatch(ulid: string, disputeUpdate: DisputeUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisputeRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsUliddisputePatch(ulid, disputeUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Dispute resource.
         * @summary Open a Dispute related to existing Transaction
         * @param {string} ulid Transaction identifier
         * @param {DisputeWrite} disputeWrite The new Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsUliddisputePost(ulid: string, disputeWrite: DisputeWrite, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisputePostCreationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsUliddisputePost(ulid, disputeWrite, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the collection of Parcel resources.
         * @summary Read shipments from Transaction
         * @param {string} ulid Transaction identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsUlidparcelsGetCollection(ulid: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsUlidparcelsGetCollection(ulid, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * No one except the support can do that manoeuvre.
         * @summary Withdraw shipment from Transaction
         * @param {string} ulid Transaction identifier
         * @param {string} id Parcel identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsUlidparcelsIdDelete(ulid: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsUlidparcelsIdDelete(ulid, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Parcel resource.
         * @summary Manually declare package shipped for Transaction
         * @param {string} ulid Transaction identifier
         * @param {ParcelWrite} parcelWrite The new Parcel resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsUlidparcelsPost(ulid: string, parcelWrite: ParcelWrite, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParcelRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsUlidparcelsPost(ulid, parcelWrite, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SafeCheckoutApi - factory interface
 * @export
 */
export const SafeCheckoutApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SafeCheckoutApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Offer resources.
         * @summary Read issued Offers
         * @param {number} [page] The collection page number
         * @param {string} [title] 
         * @param {string} [publicUrl] 
         * @param {Array<string>} [publicUrl2] 
         * @param {number} [unitPrice] 
         * @param {Array<number>} [unitPrice2] 
         * @param {number} [itemCount] 
         * @param {Array<number>} [itemCount2] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {'service' | 'physical_item' | 'dematerialized_item' | 'rent_item'} [nature] Filter on a limited subset of nature
         * @param {'NEW' | 'USED' | 'DAMAGED' | 'DETERIORATED' | 'UNRECOVERABLE'} [condition] Filter on a limited subset of condition
         * @param {boolean} [shippingAllowed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersGetCollection(page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: number, unitPrice2?: Array<number>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, nature?: 'service' | 'physical_item' | 'dematerialized_item' | 'rent_item', condition?: 'NEW' | 'USED' | 'DAMAGED' | 'DETERIORATED' | 'UNRECOVERABLE', shippingAllowed?: boolean, options?: any): AxiosPromise<Array<OfferCollectionRead>> {
            return localVarFp.apiOffersGetCollection(page, title, publicUrl, publicUrl2, unitPrice, unitPrice2, itemCount, itemCount2, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, metadata, offerMetadata, nature, condition, shippingAllowed, options).then((request) => request(axios, basePath));
        },
        /**
         * Publish an offer so that you can safely retrieve a safe-checkout unique link from us
         * @summary Create an Offer and retrieve url
         * @param {OfferIndependentWrite} offerIndependentWrite The new Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersPost(offerIndependentWrite: OfferIndependentWrite, options?: any): AxiosPromise<OfferPostCreationRead> {
            return localVarFp.apiOffersPost(offerIndependentWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Offer resource.
         * @summary Read an Offer
         * @param {string} ulid Offer identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidGet(ulid: string, options?: any): AxiosPromise<OfferRead> {
            return localVarFp.apiOffersUlidGet(ulid, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Media resource.
         * @summary Removes the Media resource.
         * @param {string} ulid Offer identifier
         * @param {string} id Media identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasIdDelete(ulid: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiOffersUlidmediasIdDelete(ulid, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Media resource.
         * @summary Upload a picture for a given Offer
         * @param {string} ulid Offer identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasPost(ulid: string, file?: File, options?: any): AxiosPromise<MediaRead> {
            return localVarFp.apiOffersUlidmediasPost(ulid, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of Transaction resources.
         * @summary Retrieve Payment Intents for Offer
         * @param {string} ulid Offer identifier
         * @param {number} [page] The collection page number
         * @param {'asc' | 'desc'} [orderStatus] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED'} [status] Filter on a limited subset of status
         * @param {boolean} [existsDispute] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidtransactionsGetCollection(ulid: string, page?: number, orderStatus?: 'asc' | 'desc', metadata?: Array<string>, status?: 'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED', existsDispute?: boolean, options?: any): AxiosPromise<Array<TransactionCollectionRead>> {
            return localVarFp.apiOffersUlidtransactionsGetCollection(ulid, page, orderStatus, metadata, status, existsDispute, options).then((request) => request(axios, basePath));
        },
        /**
         * **Only authenticated** buyer and seller **CAN** issue an evaluation **WHEN** the transaction reached a final state.
         * @summary Submit an Evaluation for the Offer
         * @param {string} ulid Dispute identifier
         * @param {string} id Transaction identifier
         * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidtransactionsIdevaluationsPost(ulid: string, id: string, evaluationWrite: EvaluationWrite, options?: any): AxiosPromise<EvaluationRead> {
            return localVarFp.apiOffersUlidtransactionsIdevaluationsPost(ulid, id, evaluationWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Cannot be used outside of a Persona (buyer)
         * @summary Create a Payment Intent for Offer
         * @param {string} ulid Offer identifier
         * @param {object} body The new Transaction resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidtransactionsPost(ulid: string, body: object, options?: any): AxiosPromise<TransactionRead> {
            return localVarFp.apiOffersUlidtransactionsPost(ulid, body, options).then((request) => request(axios, basePath));
        },
        /**
         * That goes without says, if that **Offer** have a _Transaction_ **that is ongoing**, you **MAY NOT** revoke the **Offer**.
         * @summary Revoke an Offer for given Persona
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdoffersDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiPersonasIdoffersDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of Offer resources.
         * @summary List or Search Offers for given Persona
         * @param {string} id Persona identifier
         * @param {number} [page] The collection page number
         * @param {string} [title] 
         * @param {string} [publicUrl] 
         * @param {Array<string>} [publicUrl2] 
         * @param {number} [unitPrice] 
         * @param {Array<number>} [unitPrice2] 
         * @param {number} [itemCount] 
         * @param {Array<number>} [itemCount2] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {'service' | 'physical_item' | 'dematerialized_item' | 'rent_item'} [nature] Filter on a limited subset of nature
         * @param {'NEW' | 'USED' | 'DAMAGED' | 'DETERIORATED' | 'UNRECOVERABLE'} [condition] Filter on a limited subset of condition
         * @param {boolean} [shippingAllowed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdoffersGetCollection(id: string, page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: number, unitPrice2?: Array<number>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, nature?: 'service' | 'physical_item' | 'dematerialized_item' | 'rent_item', condition?: 'NEW' | 'USED' | 'DAMAGED' | 'DETERIORATED' | 'UNRECOVERABLE', shippingAllowed?: boolean, options?: any): AxiosPromise<Array<OfferCollectionRead>> {
            return localVarFp.apiPersonasIdoffersGetCollection(id, page, title, publicUrl, publicUrl2, unitPrice, unitPrice2, itemCount, itemCount2, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, metadata, offerMetadata, nature, condition, shippingAllowed, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the Offer resource.
         * @summary Update an Offer for given Persona
         * @param {string} id Persona identifier
         * @param {OfferUpdate} offerUpdate The updated Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdoffersPatch(id: string, offerUpdate: OfferUpdate, options?: any): AxiosPromise<OfferRead> {
            return localVarFp.apiPersonasIdoffersPatch(id, offerUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Offer resource.
         * @summary Create an Offer for given Persona
         * @param {string} id Persona identifier
         * @param {OfferWrite} offerWrite The new Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdoffersPost(id: string, offerWrite: OfferWrite, options?: any): AxiosPromise<OfferPostCreationRead> {
            return localVarFp.apiPersonasIdoffersPost(id, offerWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of Transaction resources.
         * @summary Retrieves the collection of Transaction resources.
         * @param {number} [page] The collection page number
         * @param {'asc' | 'desc'} [orderStatus] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED'} [status] Filter on a limited subset of status
         * @param {boolean} [existsDispute] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsGetCollection(page?: number, orderStatus?: 'asc' | 'desc', metadata?: Array<string>, status?: 'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED', existsDispute?: boolean, options?: any): AxiosPromise<Array<TransactionCollectionRead>> {
            return localVarFp.apiTransactionsGetCollection(page, orderStatus, metadata, status, existsDispute, options).then((request) => request(axios, basePath));
        },
        /**
         * **Only the buyer/complainant** can dismiss the case immediately. Otherwise, the support can but in a limited ranges of Dispute status.
         * @summary Abandon claims on Dispute
         * @param {string} ulid Transaction identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUliddisputeDelete(ulid: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiTransactionsUliddisputeDelete(ulid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Dispute resource.
         * @summary Read Dispute from existing Transaction
         * @param {string} ulid Transaction identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUliddisputeGet(ulid: string, options?: any): AxiosPromise<DisputeRead> {
            return localVarFp.apiTransactionsUliddisputeGet(ulid, options).then((request) => request(axios, basePath));
        },
        /**
         * Only authenticated Persona can interact with a Dispute object. Usually through our web application.
         * @summary Interact with a Dispute
         * @param {string} ulid Transaction identifier
         * @param {DisputeUpdate} disputeUpdate The updated Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUliddisputePatch(ulid: string, disputeUpdate: DisputeUpdate, options?: any): AxiosPromise<DisputeRead> {
            return localVarFp.apiTransactionsUliddisputePatch(ulid, disputeUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Dispute resource.
         * @summary Open a Dispute related to existing Transaction
         * @param {string} ulid Transaction identifier
         * @param {DisputeWrite} disputeWrite The new Dispute resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUliddisputePost(ulid: string, disputeWrite: DisputeWrite, options?: any): AxiosPromise<DisputePostCreationRead> {
            return localVarFp.apiTransactionsUliddisputePost(ulid, disputeWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of Parcel resources.
         * @summary Read shipments from Transaction
         * @param {string} ulid Transaction identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidparcelsGetCollection(ulid: string, page?: number, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.apiTransactionsUlidparcelsGetCollection(ulid, page, options).then((request) => request(axios, basePath));
        },
        /**
         * No one except the support can do that manoeuvre.
         * @summary Withdraw shipment from Transaction
         * @param {string} ulid Transaction identifier
         * @param {string} id Parcel identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidparcelsIdDelete(ulid: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiTransactionsUlidparcelsIdDelete(ulid, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Parcel resource.
         * @summary Manually declare package shipped for Transaction
         * @param {string} ulid Transaction identifier
         * @param {ParcelWrite} parcelWrite The new Parcel resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidparcelsPost(ulid: string, parcelWrite: ParcelWrite, options?: any): AxiosPromise<ParcelRead> {
            return localVarFp.apiTransactionsUlidparcelsPost(ulid, parcelWrite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SafeCheckoutApi - object-oriented interface
 * @export
 * @class SafeCheckoutApi
 * @extends {BaseAPI}
 */
export class SafeCheckoutApi extends BaseAPI {
    /**
     * Retrieves the collection of Offer resources.
     * @summary Read issued Offers
     * @param {number} [page] The collection page number
     * @param {string} [title] 
     * @param {string} [publicUrl] 
     * @param {Array<string>} [publicUrl2] 
     * @param {number} [unitPrice] 
     * @param {Array<number>} [unitPrice2] 
     * @param {number} [itemCount] 
     * @param {Array<number>} [itemCount2] 
     * @param {string} [createdAtBefore] 
     * @param {string} [createdAtStrictlyBefore] 
     * @param {string} [createdAtAfter] 
     * @param {string} [createdAtStrictlyAfter] 
     * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {'service' | 'physical_item' | 'dematerialized_item' | 'rent_item'} [nature] Filter on a limited subset of nature
     * @param {'NEW' | 'USED' | 'DAMAGED' | 'DETERIORATED' | 'UNRECOVERABLE'} [condition] Filter on a limited subset of condition
     * @param {boolean} [shippingAllowed] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersGetCollection(page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: number, unitPrice2?: Array<number>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, nature?: 'service' | 'physical_item' | 'dematerialized_item' | 'rent_item', condition?: 'NEW' | 'USED' | 'DAMAGED' | 'DETERIORATED' | 'UNRECOVERABLE', shippingAllowed?: boolean, options?: AxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersGetCollection(page, title, publicUrl, publicUrl2, unitPrice, unitPrice2, itemCount, itemCount2, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, metadata, offerMetadata, nature, condition, shippingAllowed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publish an offer so that you can safely retrieve a safe-checkout unique link from us
     * @summary Create an Offer and retrieve url
     * @param {OfferIndependentWrite} offerIndependentWrite The new Offer resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersPost(offerIndependentWrite: OfferIndependentWrite, options?: AxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersPost(offerIndependentWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Offer resource.
     * @summary Read an Offer
     * @param {string} ulid Offer identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersUlidGet(ulid: string, options?: AxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersUlidGet(ulid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Media resource.
     * @summary Removes the Media resource.
     * @param {string} ulid Offer identifier
     * @param {string} id Media identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersUlidmediasIdDelete(ulid: string, id: string, options?: AxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersUlidmediasIdDelete(ulid, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Media resource.
     * @summary Upload a picture for a given Offer
     * @param {string} ulid Offer identifier
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersUlidmediasPost(ulid: string, file?: File, options?: AxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersUlidmediasPost(ulid, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of Transaction resources.
     * @summary Retrieve Payment Intents for Offer
     * @param {string} ulid Offer identifier
     * @param {number} [page] The collection page number
     * @param {'asc' | 'desc'} [orderStatus] 
     * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED'} [status] Filter on a limited subset of status
     * @param {boolean} [existsDispute] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersUlidtransactionsGetCollection(ulid: string, page?: number, orderStatus?: 'asc' | 'desc', metadata?: Array<string>, status?: 'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED', existsDispute?: boolean, options?: AxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersUlidtransactionsGetCollection(ulid, page, orderStatus, metadata, status, existsDispute, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Only authenticated** buyer and seller **CAN** issue an evaluation **WHEN** the transaction reached a final state.
     * @summary Submit an Evaluation for the Offer
     * @param {string} ulid Dispute identifier
     * @param {string} id Transaction identifier
     * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersUlidtransactionsIdevaluationsPost(ulid: string, id: string, evaluationWrite: EvaluationWrite, options?: AxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersUlidtransactionsIdevaluationsPost(ulid, id, evaluationWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cannot be used outside of a Persona (buyer)
     * @summary Create a Payment Intent for Offer
     * @param {string} ulid Offer identifier
     * @param {object} body The new Transaction resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersUlidtransactionsPost(ulid: string, body: object, options?: AxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersUlidtransactionsPost(ulid, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * That goes without says, if that **Offer** have a _Transaction_ **that is ongoing**, you **MAY NOT** revoke the **Offer**.
     * @summary Revoke an Offer for given Persona
     * @param {string} id Persona identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiPersonasIdoffersDelete(id: string, options?: AxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiPersonasIdoffersDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of Offer resources.
     * @summary List or Search Offers for given Persona
     * @param {string} id Persona identifier
     * @param {number} [page] The collection page number
     * @param {string} [title] 
     * @param {string} [publicUrl] 
     * @param {Array<string>} [publicUrl2] 
     * @param {number} [unitPrice] 
     * @param {Array<number>} [unitPrice2] 
     * @param {number} [itemCount] 
     * @param {Array<number>} [itemCount2] 
     * @param {string} [createdAtBefore] 
     * @param {string} [createdAtStrictlyBefore] 
     * @param {string} [createdAtAfter] 
     * @param {string} [createdAtStrictlyAfter] 
     * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {'service' | 'physical_item' | 'dematerialized_item' | 'rent_item'} [nature] Filter on a limited subset of nature
     * @param {'NEW' | 'USED' | 'DAMAGED' | 'DETERIORATED' | 'UNRECOVERABLE'} [condition] Filter on a limited subset of condition
     * @param {boolean} [shippingAllowed] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiPersonasIdoffersGetCollection(id: string, page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: number, unitPrice2?: Array<number>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, nature?: 'service' | 'physical_item' | 'dematerialized_item' | 'rent_item', condition?: 'NEW' | 'USED' | 'DAMAGED' | 'DETERIORATED' | 'UNRECOVERABLE', shippingAllowed?: boolean, options?: AxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiPersonasIdoffersGetCollection(id, page, title, publicUrl, publicUrl2, unitPrice, unitPrice2, itemCount, itemCount2, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, metadata, offerMetadata, nature, condition, shippingAllowed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the Offer resource.
     * @summary Update an Offer for given Persona
     * @param {string} id Persona identifier
     * @param {OfferUpdate} offerUpdate The updated Offer resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiPersonasIdoffersPatch(id: string, offerUpdate: OfferUpdate, options?: AxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiPersonasIdoffersPatch(id, offerUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Offer resource.
     * @summary Create an Offer for given Persona
     * @param {string} id Persona identifier
     * @param {OfferWrite} offerWrite The new Offer resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiPersonasIdoffersPost(id: string, offerWrite: OfferWrite, options?: AxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiPersonasIdoffersPost(id, offerWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of Transaction resources.
     * @summary Retrieves the collection of Transaction resources.
     * @param {number} [page] The collection page number
     * @param {'asc' | 'desc'} [orderStatus] 
     * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED'} [status] Filter on a limited subset of status
     * @param {boolean} [existsDispute] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiTransactionsGetCollection(page?: number, orderStatus?: 'asc' | 'desc', metadata?: Array<string>, status?: 'CREATED' | 'AUTHORIZED' | 'REFUSED' | 'ACCEPTED' | 'SHIPPED' | 'IN_TRANSIT' | 'DELIVERED' | 'COMPLETED' | 'DISPUTED', existsDispute?: boolean, options?: AxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiTransactionsGetCollection(page, orderStatus, metadata, status, existsDispute, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Only the buyer/complainant** can dismiss the case immediately. Otherwise, the support can but in a limited ranges of Dispute status.
     * @summary Abandon claims on Dispute
     * @param {string} ulid Transaction identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiTransactionsUliddisputeDelete(ulid: string, options?: AxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiTransactionsUliddisputeDelete(ulid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Dispute resource.
     * @summary Read Dispute from existing Transaction
     * @param {string} ulid Transaction identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiTransactionsUliddisputeGet(ulid: string, options?: AxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiTransactionsUliddisputeGet(ulid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only authenticated Persona can interact with a Dispute object. Usually through our web application.
     * @summary Interact with a Dispute
     * @param {string} ulid Transaction identifier
     * @param {DisputeUpdate} disputeUpdate The updated Dispute resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiTransactionsUliddisputePatch(ulid: string, disputeUpdate: DisputeUpdate, options?: AxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiTransactionsUliddisputePatch(ulid, disputeUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Dispute resource.
     * @summary Open a Dispute related to existing Transaction
     * @param {string} ulid Transaction identifier
     * @param {DisputeWrite} disputeWrite The new Dispute resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiTransactionsUliddisputePost(ulid: string, disputeWrite: DisputeWrite, options?: AxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiTransactionsUliddisputePost(ulid, disputeWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of Parcel resources.
     * @summary Read shipments from Transaction
     * @param {string} ulid Transaction identifier
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiTransactionsUlidparcelsGetCollection(ulid: string, page?: number, options?: AxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiTransactionsUlidparcelsGetCollection(ulid, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * No one except the support can do that manoeuvre.
     * @summary Withdraw shipment from Transaction
     * @param {string} ulid Transaction identifier
     * @param {string} id Parcel identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiTransactionsUlidparcelsIdDelete(ulid: string, id: string, options?: AxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiTransactionsUlidparcelsIdDelete(ulid, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Parcel resource.
     * @summary Manually declare package shipped for Transaction
     * @param {string} ulid Transaction identifier
     * @param {ParcelWrite} parcelWrite The new Parcel resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiTransactionsUlidparcelsPost(ulid: string, parcelWrite: ParcelWrite, options?: AxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiTransactionsUlidparcelsPost(ulid, parcelWrite, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Main route for Persona (Organization customers) to authenticate themselves. Public access, captcha protected and MFA mandatory.
         * @summary Persona Authentication
         * @param {PersonaExternalAuth} personaExternalAuth The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasauthenticationPost: async (personaExternalAuth: PersonaExternalAuth, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaExternalAuth' is not null or undefined
            assertParamExists('apiPersonasauthenticationPost', 'personaExternalAuth', personaExternalAuth)
            const localVarPath = `/personas/authentication`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaExternalAuth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Persona resource.
         * @summary Persona external registration
         * @param {PersonaRegister} personaRegister The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasregisterPost: async (personaRegister: PersonaRegister, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaRegister' is not null or undefined
            assertParamExists('apiPersonasregisterPost', 'personaRegister', personaRegister)
            const localVarPath = `/personas/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaRegister, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Internal-use only, protected by a captcha. Organization first-enrollment
         * @summary Organization onboarding
         * @param {UserWrite} userWrite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRegisterPost: async (userWrite: UserWrite, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userWrite' is not null or undefined
            assertParamExists('apiRegisterPost', 'userWrite', userWrite)
            const localVarPath = `/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of User resources.
         * @summary Retrieves the collection of User resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGetCollection: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdGet', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Validate email ownership
         * @param {string} id User identifier
         * @param {UserEmailValidationWrite} userEmailValidationWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdemailValidationPatch: async (id: string, userEmailValidationWrite: UserEmailValidationWrite, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdemailValidationPatch', 'id', id)
            // verify required parameter 'userEmailValidationWrite' is not null or undefined
            assertParamExists('apiUsersIdemailValidationPatch', 'userEmailValidationWrite', userEmailValidationWrite)
            const localVarPath = `/users/{id}/email-validation`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userEmailValidationWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Main route for Persona (Organization customers) to authenticate themselves. Public access, captcha protected and MFA mandatory.
         * @summary Persona Authentication
         * @param {PersonaExternalAuth} personaExternalAuth The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasauthenticationPost(personaExternalAuth: PersonaExternalAuth, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaAuthReturn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasauthenticationPost(personaExternalAuth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Persona resource.
         * @summary Persona external registration
         * @param {PersonaRegister} personaRegister The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasregisterPost(personaRegister: PersonaRegister, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasregisterPost(personaRegister, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Internal-use only, protected by a captcha. Organization first-enrollment
         * @summary Organization onboarding
         * @param {UserWrite} userWrite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRegisterPost(userWrite: UserWrite, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPostRegisterRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRegisterPost(userWrite, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the collection of User resources.
         * @summary Retrieves the collection of User resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersGetCollection(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSupportRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersGetCollection(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the User resource.
         * @summary Validate email ownership
         * @param {string} id User identifier
         * @param {UserEmailValidationWrite} userEmailValidationWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdemailValidationPatch(id: string, userEmailValidationWrite: UserEmailValidationWrite, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPostRegisterRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdemailValidationPatch(id, userEmailValidationWrite, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Main route for Persona (Organization customers) to authenticate themselves. Public access, captcha protected and MFA mandatory.
         * @summary Persona Authentication
         * @param {PersonaExternalAuth} personaExternalAuth The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasauthenticationPost(personaExternalAuth: PersonaExternalAuth, options?: any): AxiosPromise<PersonaAuthReturn> {
            return localVarFp.apiPersonasauthenticationPost(personaExternalAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Persona resource.
         * @summary Persona external registration
         * @param {PersonaRegister} personaRegister The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasregisterPost(personaRegister: PersonaRegister, options?: any): AxiosPromise<PersonaRead> {
            return localVarFp.apiPersonasregisterPost(personaRegister, options).then((request) => request(axios, basePath));
        },
        /**
         * Internal-use only, protected by a captcha. Organization first-enrollment
         * @summary Organization onboarding
         * @param {UserWrite} userWrite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRegisterPost(userWrite: UserWrite, options?: any): AxiosPromise<UserPostRegisterRead> {
            return localVarFp.apiRegisterPost(userWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of User resources.
         * @summary Retrieves the collection of User resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGetCollection(page?: number, options?: any): AxiosPromise<Array<UserSupportRead>> {
            return localVarFp.apiUsersGetCollection(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdGet(id: string, options?: any): AxiosPromise<User> {
            return localVarFp.apiUsersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Validate email ownership
         * @param {string} id User identifier
         * @param {UserEmailValidationWrite} userEmailValidationWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdemailValidationPatch(id: string, userEmailValidationWrite: UserEmailValidationWrite, options?: any): AxiosPromise<UserPostRegisterRead> {
            return localVarFp.apiUsersIdemailValidationPatch(id, userEmailValidationWrite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Main route for Persona (Organization customers) to authenticate themselves. Public access, captcha protected and MFA mandatory.
     * @summary Persona Authentication
     * @param {PersonaExternalAuth} personaExternalAuth The new Persona resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiPersonasauthenticationPost(personaExternalAuth: PersonaExternalAuth, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).apiPersonasauthenticationPost(personaExternalAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Persona resource.
     * @summary Persona external registration
     * @param {PersonaRegister} personaRegister The new Persona resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiPersonasregisterPost(personaRegister: PersonaRegister, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).apiPersonasregisterPost(personaRegister, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Internal-use only, protected by a captcha. Organization first-enrollment
     * @summary Organization onboarding
     * @param {UserWrite} userWrite The new User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiRegisterPost(userWrite: UserWrite, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).apiRegisterPost(userWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of User resources.
     * @summary Retrieves the collection of User resources.
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersGetCollection(page?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersGetCollection(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a User resource.
     * @summary Retrieves a User resource.
     * @param {string} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdGet(id: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Validate email ownership
     * @param {string} id User identifier
     * @param {UserEmailValidationWrite} userEmailValidationWrite The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdemailValidationPatch(id: string, userEmailValidationWrite: UserEmailValidationWrite, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdemailValidationPatch(id, userEmailValidationWrite, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of WebhookHistory resources.
         * @summary Retrieves the collection of WebhookHistory resources.
         * @param {number} [page] The collection page number
         * @param {string} [event] 
         * @param {Array<string>} [event2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesGetCollection: async (page?: number, event?: string, event2?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhook-histories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["ORGANIZATION_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }

            if (event2) {
                localVarQueryParameter['event[]'] = event2;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a WebhookHistory resource.
         * @summary Retrieves a WebhookHistory resource.
         * @param {string} id WebhookHistory identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWebhookHistoriesIdGet', 'id', id)
            const localVarPath = `/webhook-histories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["ORGANIZATION_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces the WebhookHistory resource.
         * @summary Replay a Webhook that ended up in failure
         * @param {string} id WebhookHistory identifier
         * @param {object} body The updated WebhookHistory resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesIdPut: async (id: string, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWebhookHistoriesIdPut', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('apiWebhookHistoriesIdPut', 'body', body)
            const localVarPath = `/webhook-histories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of WebhookSubscription resources.
         * @summary Retrieves the collection of WebhookSubscription resources.
         * @param {number} [page] The collection page number
         * @param {'dispute.opened' | 'dispute.submitted' | 'dispute.created' | 'dispute.abandoned' | 'dispute.settlement' | 'dispute.closed' | 'dispute.expired' | 'dispute.manual_arbitration_required' | 'dispute.updated' | 'offer.created' | 'offer.expired' | 'offer.updated' | 'offer.crawl_failure' | 'offer.transaction.authorized' | 'offer.transaction.reconciled' | 'offer.transaction.abandoned' | 'offer.closed' | 'offer.transaction.refund' | 'persona.added'} [event] Filter on a limited subset of event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsGetCollection: async (page?: number, event?: 'dispute.opened' | 'dispute.submitted' | 'dispute.created' | 'dispute.abandoned' | 'dispute.settlement' | 'dispute.closed' | 'dispute.expired' | 'dispute.manual_arbitration_required' | 'dispute.updated' | 'offer.created' | 'offer.expired' | 'offer.updated' | 'offer.crawl_failure' | 'offer.transaction.authorized' | 'offer.transaction.reconciled' | 'offer.transaction.abandoned' | 'offer.closed' | 'offer.transaction.refund' | 'persona.added', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhook-subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["ORGANIZATION_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the WebhookSubscription resource.
         * @summary Removes the WebhookSubscription resource.
         * @param {string} id WebhookSubscription identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWebhookSubscriptionsIdDelete', 'id', id)
            const localVarPath = `/webhook-subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a WebhookSubscription resource.
         * @summary Subscribe to Event(s)
         * @param {WebhookSubscriptionWrite} webhookSubscriptionWrite The new WebhookSubscription resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsPost: async (webhookSubscriptionWrite: WebhookSubscriptionWrite, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookSubscriptionWrite' is not null or undefined
            assertParamExists('apiWebhookSubscriptionsPost', 'webhookSubscriptionWrite', webhookSubscriptionWrite)
            const localVarPath = `/webhook-subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookSubscriptionWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of WebhookHistory resources.
         * @summary Retrieves the collection of WebhookHistory resources.
         * @param {number} [page] The collection page number
         * @param {string} [event] 
         * @param {Array<string>} [event2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookHistoriesGetCollection(page?: number, event?: string, event2?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookHistoryCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookHistoriesGetCollection(page, event, event2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a WebhookHistory resource.
         * @summary Retrieves a WebhookHistory resource.
         * @param {string} id WebhookHistory identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookHistoriesIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookHistoryRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookHistoriesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replaces the WebhookHistory resource.
         * @summary Replay a Webhook that ended up in failure
         * @param {string} id WebhookHistory identifier
         * @param {object} body The updated WebhookHistory resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookHistoriesIdPut(id: string, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookHistoryRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookHistoriesIdPut(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the collection of WebhookSubscription resources.
         * @summary Retrieves the collection of WebhookSubscription resources.
         * @param {number} [page] The collection page number
         * @param {'dispute.opened' | 'dispute.submitted' | 'dispute.created' | 'dispute.abandoned' | 'dispute.settlement' | 'dispute.closed' | 'dispute.expired' | 'dispute.manual_arbitration_required' | 'dispute.updated' | 'offer.created' | 'offer.expired' | 'offer.updated' | 'offer.crawl_failure' | 'offer.transaction.authorized' | 'offer.transaction.reconciled' | 'offer.transaction.abandoned' | 'offer.closed' | 'offer.transaction.refund' | 'persona.added'} [event] Filter on a limited subset of event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookSubscriptionsGetCollection(page?: number, event?: 'dispute.opened' | 'dispute.submitted' | 'dispute.created' | 'dispute.abandoned' | 'dispute.settlement' | 'dispute.closed' | 'dispute.expired' | 'dispute.manual_arbitration_required' | 'dispute.updated' | 'offer.created' | 'offer.expired' | 'offer.updated' | 'offer.crawl_failure' | 'offer.transaction.authorized' | 'offer.transaction.reconciled' | 'offer.transaction.abandoned' | 'offer.closed' | 'offer.transaction.refund' | 'persona.added', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookSubscriptionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookSubscriptionsGetCollection(page, event, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes the WebhookSubscription resource.
         * @summary Removes the WebhookSubscription resource.
         * @param {string} id WebhookSubscription identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookSubscriptionsIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookSubscriptionsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a WebhookSubscription resource.
         * @summary Subscribe to Event(s)
         * @param {WebhookSubscriptionWrite} webhookSubscriptionWrite The new WebhookSubscription resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookSubscriptionsPost(webhookSubscriptionWrite: WebhookSubscriptionWrite, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSubscriptionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookSubscriptionsPost(webhookSubscriptionWrite, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * Retrieves the collection of WebhookHistory resources.
         * @summary Retrieves the collection of WebhookHistory resources.
         * @param {number} [page] The collection page number
         * @param {string} [event] 
         * @param {Array<string>} [event2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesGetCollection(page?: number, event?: string, event2?: Array<string>, options?: any): AxiosPromise<Array<WebhookHistoryCollectionRead>> {
            return localVarFp.apiWebhookHistoriesGetCollection(page, event, event2, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a WebhookHistory resource.
         * @summary Retrieves a WebhookHistory resource.
         * @param {string} id WebhookHistory identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesIdGet(id: string, options?: any): AxiosPromise<WebhookHistoryRead> {
            return localVarFp.apiWebhookHistoriesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the WebhookHistory resource.
         * @summary Replay a Webhook that ended up in failure
         * @param {string} id WebhookHistory identifier
         * @param {object} body The updated WebhookHistory resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesIdPut(id: string, body: object, options?: any): AxiosPromise<WebhookHistoryRead> {
            return localVarFp.apiWebhookHistoriesIdPut(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of WebhookSubscription resources.
         * @summary Retrieves the collection of WebhookSubscription resources.
         * @param {number} [page] The collection page number
         * @param {'dispute.opened' | 'dispute.submitted' | 'dispute.created' | 'dispute.abandoned' | 'dispute.settlement' | 'dispute.closed' | 'dispute.expired' | 'dispute.manual_arbitration_required' | 'dispute.updated' | 'offer.created' | 'offer.expired' | 'offer.updated' | 'offer.crawl_failure' | 'offer.transaction.authorized' | 'offer.transaction.reconciled' | 'offer.transaction.abandoned' | 'offer.closed' | 'offer.transaction.refund' | 'persona.added'} [event] Filter on a limited subset of event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsGetCollection(page?: number, event?: 'dispute.opened' | 'dispute.submitted' | 'dispute.created' | 'dispute.abandoned' | 'dispute.settlement' | 'dispute.closed' | 'dispute.expired' | 'dispute.manual_arbitration_required' | 'dispute.updated' | 'offer.created' | 'offer.expired' | 'offer.updated' | 'offer.crawl_failure' | 'offer.transaction.authorized' | 'offer.transaction.reconciled' | 'offer.transaction.abandoned' | 'offer.closed' | 'offer.transaction.refund' | 'persona.added', options?: any): AxiosPromise<Array<WebhookSubscriptionRead>> {
            return localVarFp.apiWebhookSubscriptionsGetCollection(page, event, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the WebhookSubscription resource.
         * @summary Removes the WebhookSubscription resource.
         * @param {string} id WebhookSubscription identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiWebhookSubscriptionsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a WebhookSubscription resource.
         * @summary Subscribe to Event(s)
         * @param {WebhookSubscriptionWrite} webhookSubscriptionWrite The new WebhookSubscription resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsPost(webhookSubscriptionWrite: WebhookSubscriptionWrite, options?: any): AxiosPromise<WebhookSubscriptionRead> {
            return localVarFp.apiWebhookSubscriptionsPost(webhookSubscriptionWrite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * Retrieves the collection of WebhookHistory resources.
     * @summary Retrieves the collection of WebhookHistory resources.
     * @param {number} [page] The collection page number
     * @param {string} [event] 
     * @param {Array<string>} [event2] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookHistoriesGetCollection(page?: number, event?: string, event2?: Array<string>, options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookHistoriesGetCollection(page, event, event2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a WebhookHistory resource.
     * @summary Retrieves a WebhookHistory resource.
     * @param {string} id WebhookHistory identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookHistoriesIdGet(id: string, options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookHistoriesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces the WebhookHistory resource.
     * @summary Replay a Webhook that ended up in failure
     * @param {string} id WebhookHistory identifier
     * @param {object} body The updated WebhookHistory resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookHistoriesIdPut(id: string, body: object, options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookHistoriesIdPut(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of WebhookSubscription resources.
     * @summary Retrieves the collection of WebhookSubscription resources.
     * @param {number} [page] The collection page number
     * @param {'dispute.opened' | 'dispute.submitted' | 'dispute.created' | 'dispute.abandoned' | 'dispute.settlement' | 'dispute.closed' | 'dispute.expired' | 'dispute.manual_arbitration_required' | 'dispute.updated' | 'offer.created' | 'offer.expired' | 'offer.updated' | 'offer.crawl_failure' | 'offer.transaction.authorized' | 'offer.transaction.reconciled' | 'offer.transaction.abandoned' | 'offer.closed' | 'offer.transaction.refund' | 'persona.added'} [event] Filter on a limited subset of event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookSubscriptionsGetCollection(page?: number, event?: 'dispute.opened' | 'dispute.submitted' | 'dispute.created' | 'dispute.abandoned' | 'dispute.settlement' | 'dispute.closed' | 'dispute.expired' | 'dispute.manual_arbitration_required' | 'dispute.updated' | 'offer.created' | 'offer.expired' | 'offer.updated' | 'offer.crawl_failure' | 'offer.transaction.authorized' | 'offer.transaction.reconciled' | 'offer.transaction.abandoned' | 'offer.closed' | 'offer.transaction.refund' | 'persona.added', options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookSubscriptionsGetCollection(page, event, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the WebhookSubscription resource.
     * @summary Removes the WebhookSubscription resource.
     * @param {string} id WebhookSubscription identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookSubscriptionsIdDelete(id: string, options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookSubscriptionsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a WebhookSubscription resource.
     * @summary Subscribe to Event(s)
     * @param {WebhookSubscriptionWrite} webhookSubscriptionWrite The new WebhookSubscription resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookSubscriptionsPost(webhookSubscriptionWrite: WebhookSubscriptionWrite, options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookSubscriptionsPost(webhookSubscriptionWrite, options).then((request) => request(this.axios, this.basePath));
    }
}


