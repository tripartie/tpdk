# coding: utf-8

"""
    Tripartie

    Our API suite for the **Resolution Center** and the **Safe Checkout** features. Simple, yet elegant web interfaces for your convenience. One request away from your first automated resolution or safe-checkout.

    The version of the OpenAPI document: 2.0.92
    Contact: noc@tripartie.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError

from typing_extensions import Annotated
from pydantic import Field, StrictBool, StrictBytes, StrictFloat, StrictInt, StrictStr, conlist

from typing import Any, Dict, List, Optional, Union

from tpdk.models.dispute_post_creation_read import DisputePostCreationRead
from tpdk.models.dispute_read import DisputeRead
from tpdk.models.dispute_update import DisputeUpdate
from tpdk.models.dispute_write import DisputeWrite
from tpdk.models.evaluation_read import EvaluationRead
from tpdk.models.evaluation_write import EvaluationWrite
from tpdk.models.media_read import MediaRead
from tpdk.models.offer_collection_read import OfferCollectionRead
from tpdk.models.offer_independent_write import OfferIndependentWrite
from tpdk.models.offer_post_creation_read import OfferPostCreationRead
from tpdk.models.offer_read import OfferRead
from tpdk.models.offer_update import OfferUpdate
from tpdk.models.offer_write import OfferWrite
from tpdk.models.parcel_read import ParcelRead
from tpdk.models.parcel_write import ParcelWrite
from tpdk.models.transaction_collection_read import TransactionCollectionRead
from tpdk.models.transaction_read import TransactionRead

from tpdk.api_client import ApiClient
from tpdk.api_response import ApiResponse
from tpdk.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class SafeCheckoutApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def api_offers_get_collection(self, page : Annotated[Optional[StrictInt], Field(description="The collection page number")] = None, title : Optional[StrictStr] = None, public_url : Optional[StrictStr] = None, public_url2 : Optional[conlist(StrictStr)] = None, unit_price : Optional[Union[StrictFloat, StrictInt]] = None, unit_price2 : Optional[conlist(Union[StrictFloat, StrictInt])] = None, item_count : Optional[StrictInt] = None, item_count2 : Optional[conlist(StrictInt)] = None, created_at_before : Optional[StrictStr] = None, created_at_strictly_before : Optional[StrictStr] = None, created_at_after : Optional[StrictStr] = None, created_at_strictly_after : Optional[StrictStr] = None, metadata : Annotated[Optional[conlist(conlist(StrictStr))], Field(description="Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.")] = None, offer_metadata : Annotated[Optional[conlist(conlist(StrictStr))], Field(description="Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.")] = None, nature : Annotated[Optional[StrictStr], Field(description="Filter on a limited subset of nature")] = None, condition : Annotated[Optional[StrictStr], Field(description="Filter on a limited subset of condition")] = None, shipping_allowed : Optional[StrictBool] = None, **kwargs) -> List[OfferCollectionRead]:  # noqa: E501
        """Read issued Offers  # noqa: E501

        Retrieves the collection of Offer resources.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_offers_get_collection(page, title, public_url, public_url2, unit_price, unit_price2, item_count, item_count2, created_at_before, created_at_strictly_before, created_at_after, created_at_strictly_after, metadata, offer_metadata, nature, condition, shipping_allowed, async_req=True)
        >>> result = thread.get()

        :param page: The collection page number
        :type page: int
        :param title: 
        :type title: str
        :param public_url: 
        :type public_url: str
        :param public_url2: 
        :type public_url2: List[str]
        :param unit_price: 
        :type unit_price: float
        :param unit_price2: 
        :type unit_price2: List[float]
        :param item_count: 
        :type item_count: int
        :param item_count2: 
        :type item_count2: List[int]
        :param created_at_before: 
        :type created_at_before: str
        :param created_at_strictly_before: 
        :type created_at_strictly_before: str
        :param created_at_after: 
        :type created_at_after: str
        :param created_at_strictly_after: 
        :type created_at_strictly_after: str
        :param metadata: Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.
        :type metadata: List[str]
        :param offer_metadata: Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.
        :type offer_metadata: List[str]
        :param nature: Filter on a limited subset of nature
        :type nature: str
        :param condition: Filter on a limited subset of condition
        :type condition: str
        :param shipping_allowed: 
        :type shipping_allowed: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[OfferCollectionRead]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_offers_get_collection_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_offers_get_collection_with_http_info(page, title, public_url, public_url2, unit_price, unit_price2, item_count, item_count2, created_at_before, created_at_strictly_before, created_at_after, created_at_strictly_after, metadata, offer_metadata, nature, condition, shipping_allowed, **kwargs)  # noqa: E501

    @validate_arguments
    def api_offers_get_collection_with_http_info(self, page : Annotated[Optional[StrictInt], Field(description="The collection page number")] = None, title : Optional[StrictStr] = None, public_url : Optional[StrictStr] = None, public_url2 : Optional[conlist(StrictStr)] = None, unit_price : Optional[Union[StrictFloat, StrictInt]] = None, unit_price2 : Optional[conlist(Union[StrictFloat, StrictInt])] = None, item_count : Optional[StrictInt] = None, item_count2 : Optional[conlist(StrictInt)] = None, created_at_before : Optional[StrictStr] = None, created_at_strictly_before : Optional[StrictStr] = None, created_at_after : Optional[StrictStr] = None, created_at_strictly_after : Optional[StrictStr] = None, metadata : Annotated[Optional[conlist(conlist(StrictStr))], Field(description="Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.")] = None, offer_metadata : Annotated[Optional[conlist(conlist(StrictStr))], Field(description="Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.")] = None, nature : Annotated[Optional[StrictStr], Field(description="Filter on a limited subset of nature")] = None, condition : Annotated[Optional[StrictStr], Field(description="Filter on a limited subset of condition")] = None, shipping_allowed : Optional[StrictBool] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Read issued Offers  # noqa: E501

        Retrieves the collection of Offer resources.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_offers_get_collection_with_http_info(page, title, public_url, public_url2, unit_price, unit_price2, item_count, item_count2, created_at_before, created_at_strictly_before, created_at_after, created_at_strictly_after, metadata, offer_metadata, nature, condition, shipping_allowed, async_req=True)
        >>> result = thread.get()

        :param page: The collection page number
        :type page: int
        :param title: 
        :type title: str
        :param public_url: 
        :type public_url: str
        :param public_url2: 
        :type public_url2: List[str]
        :param unit_price: 
        :type unit_price: float
        :param unit_price2: 
        :type unit_price2: List[float]
        :param item_count: 
        :type item_count: int
        :param item_count2: 
        :type item_count2: List[int]
        :param created_at_before: 
        :type created_at_before: str
        :param created_at_strictly_before: 
        :type created_at_strictly_before: str
        :param created_at_after: 
        :type created_at_after: str
        :param created_at_strictly_after: 
        :type created_at_strictly_after: str
        :param metadata: Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.
        :type metadata: List[str]
        :param offer_metadata: Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.
        :type offer_metadata: List[str]
        :param nature: Filter on a limited subset of nature
        :type nature: str
        :param condition: Filter on a limited subset of condition
        :type condition: str
        :param shipping_allowed: 
        :type shipping_allowed: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[OfferCollectionRead], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'page',
            'title',
            'public_url',
            'public_url2',
            'unit_price',
            'unit_price2',
            'item_count',
            'item_count2',
            'created_at_before',
            'created_at_strictly_before',
            'created_at_after',
            'created_at_strictly_after',
            'metadata',
            'offer_metadata',
            'nature',
            'condition',
            'shipping_allowed'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_offers_get_collection" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('title') is not None:  # noqa: E501
            _query_params.append(('title', _params['title']))

        if _params.get('public_url') is not None:  # noqa: E501
            _query_params.append(('publicUrl', _params['public_url']))

        if _params.get('public_url2') is not None:  # noqa: E501
            _query_params.append(('publicUrl[]', _params['public_url2']))
            _collection_formats['publicUrl[]'] = 'multi'

        if _params.get('unit_price') is not None:  # noqa: E501
            _query_params.append(('unitPrice', _params['unit_price']))

        if _params.get('unit_price2') is not None:  # noqa: E501
            _query_params.append(('unitPrice[]', _params['unit_price2']))
            _collection_formats['unitPrice[]'] = 'multi'

        if _params.get('item_count') is not None:  # noqa: E501
            _query_params.append(('itemCount', _params['item_count']))

        if _params.get('item_count2') is not None:  # noqa: E501
            _query_params.append(('itemCount[]', _params['item_count2']))
            _collection_formats['itemCount[]'] = 'multi'

        if _params.get('created_at_before') is not None:  # noqa: E501
            _query_params.append(('createdAt[before]', _params['created_at_before']))

        if _params.get('created_at_strictly_before') is not None:  # noqa: E501
            _query_params.append(('createdAt[strictly_before]', _params['created_at_strictly_before']))

        if _params.get('created_at_after') is not None:  # noqa: E501
            _query_params.append(('createdAt[after]', _params['created_at_after']))

        if _params.get('created_at_strictly_after') is not None:  # noqa: E501
            _query_params.append(('createdAt[strictly_after]', _params['created_at_strictly_after']))

        if _params.get('metadata') is not None:  # noqa: E501
            _query_params.append(('metadata[]', _params['metadata']))
            _collection_formats['metadata[]'] = 'csv'

        if _params.get('offer_metadata') is not None:  # noqa: E501
            _query_params.append(('offer.metadata[]', _params['offer_metadata']))
            _collection_formats['offer.metadata[]'] = 'csv'

        if _params.get('nature') is not None:  # noqa: E501
            _query_params.append(('nature', _params['nature']))

        if _params.get('condition') is not None:  # noqa: E501
            _query_params.append(('condition', _params['condition']))

        if _params.get('shipping_allowed') is not None:  # noqa: E501
            _query_params.append(('shippingAllowed', _params['shipping_allowed']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['jwtPersonalKey', 'personaAuthKey', 'oauth']  # noqa: E501

        _response_types_map = {
            '200': "List[OfferCollectionRead]",
        }

        return self.api_client.call_api(
            '/offers', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_offers_post(self, offer_independent_write : Annotated[OfferIndependentWrite, Field(..., description="The new Offer resource")], **kwargs) -> OfferPostCreationRead:  # noqa: E501
        """Create an Offer and retrieve url  # noqa: E501

        Publish an offer so that you can safely retrieve a safe-checkout unique link from us  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_offers_post(offer_independent_write, async_req=True)
        >>> result = thread.get()

        :param offer_independent_write: The new Offer resource (required)
        :type offer_independent_write: OfferIndependentWrite
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OfferPostCreationRead
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_offers_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_offers_post_with_http_info(offer_independent_write, **kwargs)  # noqa: E501

    @validate_arguments
    def api_offers_post_with_http_info(self, offer_independent_write : Annotated[OfferIndependentWrite, Field(..., description="The new Offer resource")], **kwargs) -> ApiResponse:  # noqa: E501
        """Create an Offer and retrieve url  # noqa: E501

        Publish an offer so that you can safely retrieve a safe-checkout unique link from us  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_offers_post_with_http_info(offer_independent_write, async_req=True)
        >>> result = thread.get()

        :param offer_independent_write: The new Offer resource (required)
        :type offer_independent_write: OfferIndependentWrite
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OfferPostCreationRead, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'offer_independent_write'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_offers_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['offer_independent_write'] is not None:
            _body_params = _params['offer_independent_write']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['personaAuthKey', 'oauth']  # noqa: E501

        _response_types_map = {
            '422': "UnprocessableEntity",
            '201': "OfferPostCreationRead",
            '400': None,
        }

        return self.api_client.call_api(
            '/offers', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_offers_ulid_get(self, ulid : Annotated[StrictStr, Field(..., description="Offer identifier")], **kwargs) -> OfferRead:  # noqa: E501
        """Read an Offer  # noqa: E501

        Retrieves a Offer resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_offers_ulid_get(ulid, async_req=True)
        >>> result = thread.get()

        :param ulid: Offer identifier (required)
        :type ulid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OfferRead
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_offers_ulid_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_offers_ulid_get_with_http_info(ulid, **kwargs)  # noqa: E501

    @validate_arguments
    def api_offers_ulid_get_with_http_info(self, ulid : Annotated[StrictStr, Field(..., description="Offer identifier")], **kwargs) -> ApiResponse:  # noqa: E501
        """Read an Offer  # noqa: E501

        Retrieves a Offer resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_offers_ulid_get_with_http_info(ulid, async_req=True)
        >>> result = thread.get()

        :param ulid: Offer identifier (required)
        :type ulid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OfferRead, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ulid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_offers_ulid_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['ulid']:
            _path_params['ulid'] = _params['ulid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['jwtPersonalKey', 'personaAuthKey', 'oauth']  # noqa: E501

        _response_types_map = {
            '200': "OfferRead",
            '404': None,
        }

        return self.api_client.call_api(
            '/offers/{ulid}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_offers_ulidmedias_id_delete(self, ulid : StrictStr, id : StrictInt, **kwargs) -> None:  # noqa: E501
        """Removes the Media resource.  # noqa: E501

        Removes the Media resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_offers_ulidmedias_id_delete(ulid, id, async_req=True)
        >>> result = thread.get()

        :param ulid:  (required)
        :type ulid: str
        :param id:  (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_offers_ulidmedias_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_offers_ulidmedias_id_delete_with_http_info(ulid, id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_offers_ulidmedias_id_delete_with_http_info(self, ulid : StrictStr, id : StrictInt, **kwargs) -> ApiResponse:  # noqa: E501
        """Removes the Media resource.  # noqa: E501

        Removes the Media resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_offers_ulidmedias_id_delete_with_http_info(ulid, id, async_req=True)
        >>> result = thread.get()

        :param ulid:  (required)
        :type ulid: str
        :param id:  (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'ulid',
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_offers_ulidmedias_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['ulid']:
            _path_params['ulid'] = _params['ulid']

        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['jwtPersonalKey', 'personaAuthKey', 'oauth']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/offers/{ulid}/medias/{id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_offers_ulidmedias_post(self, ulid : StrictStr, file : Optional[Union[StrictBytes, StrictStr]] = None, **kwargs) -> MediaRead:  # noqa: E501
        """Upload a picture for a given Offer  # noqa: E501

        Creates a Media resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_offers_ulidmedias_post(ulid, file, async_req=True)
        >>> result = thread.get()

        :param ulid:  (required)
        :type ulid: str
        :param file:
        :type file: bytearray
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: MediaRead
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_offers_ulidmedias_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_offers_ulidmedias_post_with_http_info(ulid, file, **kwargs)  # noqa: E501

    @validate_arguments
    def api_offers_ulidmedias_post_with_http_info(self, ulid : StrictStr, file : Optional[Union[StrictBytes, StrictStr]] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Upload a picture for a given Offer  # noqa: E501

        Creates a Media resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_offers_ulidmedias_post_with_http_info(ulid, file, async_req=True)
        >>> result = thread.get()

        :param ulid:  (required)
        :type ulid: str
        :param file:
        :type file: bytearray
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(MediaRead, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ulid',
            'file'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_offers_ulidmedias_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['ulid']:
            _path_params['ulid'] = _params['ulid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        if _params['file']:
            _files['file'] = _params['file']

        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['personaAuthKey', 'oauth']  # noqa: E501

        _response_types_map = {
            '422': "UnprocessableEntity",
            '201': "MediaRead",
            '400': None,
        }

        return self.api_client.call_api(
            '/offers/{ulid}/medias', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_offers_ulidtransactions_get_collection(self, ulid : Annotated[StrictStr, Field(..., description="Offer identifier")], page : Annotated[Optional[StrictInt], Field(description="The collection page number")] = None, order_status : Optional[StrictStr] = None, metadata : Annotated[Optional[conlist(conlist(StrictStr))], Field(description="Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.")] = None, status : Annotated[Optional[StrictStr], Field(description="Filter on a limited subset of status")] = None, **kwargs) -> List[TransactionCollectionRead]:  # noqa: E501
        """Retrieve Payment Intents for Offer  # noqa: E501

        Retrieves the collection of Transaction resources.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_offers_ulidtransactions_get_collection(ulid, page, order_status, metadata, status, async_req=True)
        >>> result = thread.get()

        :param ulid: Offer identifier (required)
        :type ulid: str
        :param page: The collection page number
        :type page: int
        :param order_status: 
        :type order_status: str
        :param metadata: Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.
        :type metadata: List[str]
        :param status: Filter on a limited subset of status
        :type status: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[TransactionCollectionRead]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_offers_ulidtransactions_get_collection_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_offers_ulidtransactions_get_collection_with_http_info(ulid, page, order_status, metadata, status, **kwargs)  # noqa: E501

    @validate_arguments
    def api_offers_ulidtransactions_get_collection_with_http_info(self, ulid : Annotated[StrictStr, Field(..., description="Offer identifier")], page : Annotated[Optional[StrictInt], Field(description="The collection page number")] = None, order_status : Optional[StrictStr] = None, metadata : Annotated[Optional[conlist(conlist(StrictStr))], Field(description="Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.")] = None, status : Annotated[Optional[StrictStr], Field(description="Filter on a limited subset of status")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Retrieve Payment Intents for Offer  # noqa: E501

        Retrieves the collection of Transaction resources.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_offers_ulidtransactions_get_collection_with_http_info(ulid, page, order_status, metadata, status, async_req=True)
        >>> result = thread.get()

        :param ulid: Offer identifier (required)
        :type ulid: str
        :param page: The collection page number
        :type page: int
        :param order_status: 
        :type order_status: str
        :param metadata: Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.
        :type metadata: List[str]
        :param status: Filter on a limited subset of status
        :type status: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[TransactionCollectionRead], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ulid',
            'page',
            'order_status',
            'metadata',
            'status'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_offers_ulidtransactions_get_collection" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['ulid']:
            _path_params['ulid'] = _params['ulid']


        # process the query parameters
        _query_params = []
        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('order_status') is not None:  # noqa: E501
            _query_params.append(('order[status]', _params['order_status']))

        if _params.get('metadata') is not None:  # noqa: E501
            _query_params.append(('metadata[]', _params['metadata']))
            _collection_formats['metadata[]'] = 'csv'

        if _params.get('status') is not None:  # noqa: E501
            _query_params.append(('status', _params['status']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['jwtPersonalKey', 'oauth']  # noqa: E501

        _response_types_map = {
            '200': "List[TransactionCollectionRead]",
        }

        return self.api_client.call_api(
            '/offers/{ulid}/transactions', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_offers_ulidtransactions_idevaluations_post(self, ulid : Annotated[StrictStr, Field(..., description="Dispute identifier")], id : Annotated[StrictStr, Field(..., description="Transaction identifier")], evaluation_write : Annotated[EvaluationWrite, Field(..., description="The new Evaluation resource")], **kwargs) -> EvaluationRead:  # noqa: E501
        """Submit an Evaluation for the Offer  # noqa: E501

        **Only authenticated** buyer and seller **CAN** issue an evaluation **WHEN** the transaction reached a final state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_offers_ulidtransactions_idevaluations_post(ulid, id, evaluation_write, async_req=True)
        >>> result = thread.get()

        :param ulid: Dispute identifier (required)
        :type ulid: str
        :param id: Transaction identifier (required)
        :type id: str
        :param evaluation_write: The new Evaluation resource (required)
        :type evaluation_write: EvaluationWrite
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EvaluationRead
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_offers_ulidtransactions_idevaluations_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_offers_ulidtransactions_idevaluations_post_with_http_info(ulid, id, evaluation_write, **kwargs)  # noqa: E501

    @validate_arguments
    def api_offers_ulidtransactions_idevaluations_post_with_http_info(self, ulid : Annotated[StrictStr, Field(..., description="Dispute identifier")], id : Annotated[StrictStr, Field(..., description="Transaction identifier")], evaluation_write : Annotated[EvaluationWrite, Field(..., description="The new Evaluation resource")], **kwargs) -> ApiResponse:  # noqa: E501
        """Submit an Evaluation for the Offer  # noqa: E501

        **Only authenticated** buyer and seller **CAN** issue an evaluation **WHEN** the transaction reached a final state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_offers_ulidtransactions_idevaluations_post_with_http_info(ulid, id, evaluation_write, async_req=True)
        >>> result = thread.get()

        :param ulid: Dispute identifier (required)
        :type ulid: str
        :param id: Transaction identifier (required)
        :type id: str
        :param evaluation_write: The new Evaluation resource (required)
        :type evaluation_write: EvaluationWrite
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EvaluationRead, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ulid',
            'id',
            'evaluation_write'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_offers_ulidtransactions_idevaluations_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['ulid']:
            _path_params['ulid'] = _params['ulid']

        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['evaluation_write'] is not None:
            _body_params = _params['evaluation_write']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['personaAuthKey']  # noqa: E501

        _response_types_map = {
            '422': "UnprocessableEntity",
            '201': "EvaluationRead",
            '400': None,
        }

        return self.api_client.call_api(
            '/offers/{ulid}/transactions/{id}/evaluations', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_offers_ulidtransactions_post(self, ulid : Annotated[StrictStr, Field(..., description="Offer identifier")], body : Annotated[Dict[str, Any], Field(..., description="The new Transaction resource")], **kwargs) -> TransactionRead:  # noqa: E501
        """Create a Payment Intent for Offer  # noqa: E501

        Cannot be used outside of a Persona (buyer)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_offers_ulidtransactions_post(ulid, body, async_req=True)
        >>> result = thread.get()

        :param ulid: Offer identifier (required)
        :type ulid: str
        :param body: The new Transaction resource (required)
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransactionRead
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_offers_ulidtransactions_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_offers_ulidtransactions_post_with_http_info(ulid, body, **kwargs)  # noqa: E501

    @validate_arguments
    def api_offers_ulidtransactions_post_with_http_info(self, ulid : Annotated[StrictStr, Field(..., description="Offer identifier")], body : Annotated[Dict[str, Any], Field(..., description="The new Transaction resource")], **kwargs) -> ApiResponse:  # noqa: E501
        """Create a Payment Intent for Offer  # noqa: E501

        Cannot be used outside of a Persona (buyer)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_offers_ulidtransactions_post_with_http_info(ulid, body, async_req=True)
        >>> result = thread.get()

        :param ulid: Offer identifier (required)
        :type ulid: str
        :param body: The new Transaction resource (required)
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransactionRead, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ulid',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_offers_ulidtransactions_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['ulid']:
            _path_params['ulid'] = _params['ulid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['personaAuthKey']  # noqa: E501

        _response_types_map = {
            '422': "UnprocessableEntity",
            '201': "TransactionRead",
            '400': None,
        }

        return self.api_client.call_api(
            '/offers/{ulid}/transactions', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_personas_idoffers_delete(self, id : Annotated[StrictStr, Field(..., description="Persona identifier")], **kwargs) -> None:  # noqa: E501
        """Revoke an Offer for given Persona  # noqa: E501

        That goes without says, if that **Offer** have a _Transaction_ **that is ongoing**, you **MAY NOT** revoke the **Offer**.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_personas_idoffers_delete(id, async_req=True)
        >>> result = thread.get()

        :param id: Persona identifier (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_personas_idoffers_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_personas_idoffers_delete_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_personas_idoffers_delete_with_http_info(self, id : Annotated[StrictStr, Field(..., description="Persona identifier")], **kwargs) -> ApiResponse:  # noqa: E501
        """Revoke an Offer for given Persona  # noqa: E501

        That goes without says, if that **Offer** have a _Transaction_ **that is ongoing**, you **MAY NOT** revoke the **Offer**.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_personas_idoffers_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: Persona identifier (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_personas_idoffers_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['jwtPersonalKey', 'personaAuthKey', 'oauth']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/personas/{id}/offers', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_personas_idoffers_get_collection(self, id : Annotated[StrictStr, Field(..., description="Persona identifier")], page : Annotated[Optional[StrictInt], Field(description="The collection page number")] = None, title : Optional[StrictStr] = None, public_url : Optional[StrictStr] = None, public_url2 : Optional[conlist(StrictStr)] = None, unit_price : Optional[Union[StrictFloat, StrictInt]] = None, unit_price2 : Optional[conlist(Union[StrictFloat, StrictInt])] = None, item_count : Optional[StrictInt] = None, item_count2 : Optional[conlist(StrictInt)] = None, created_at_before : Optional[StrictStr] = None, created_at_strictly_before : Optional[StrictStr] = None, created_at_after : Optional[StrictStr] = None, created_at_strictly_after : Optional[StrictStr] = None, metadata : Annotated[Optional[conlist(conlist(StrictStr))], Field(description="Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.")] = None, offer_metadata : Annotated[Optional[conlist(conlist(StrictStr))], Field(description="Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.")] = None, nature : Annotated[Optional[StrictStr], Field(description="Filter on a limited subset of nature")] = None, condition : Annotated[Optional[StrictStr], Field(description="Filter on a limited subset of condition")] = None, shipping_allowed : Optional[StrictBool] = None, **kwargs) -> List[OfferCollectionRead]:  # noqa: E501
        """List or Search Offers for given Persona  # noqa: E501

        Retrieves the collection of Offer resources.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_personas_idoffers_get_collection(id, page, title, public_url, public_url2, unit_price, unit_price2, item_count, item_count2, created_at_before, created_at_strictly_before, created_at_after, created_at_strictly_after, metadata, offer_metadata, nature, condition, shipping_allowed, async_req=True)
        >>> result = thread.get()

        :param id: Persona identifier (required)
        :type id: str
        :param page: The collection page number
        :type page: int
        :param title: 
        :type title: str
        :param public_url: 
        :type public_url: str
        :param public_url2: 
        :type public_url2: List[str]
        :param unit_price: 
        :type unit_price: float
        :param unit_price2: 
        :type unit_price2: List[float]
        :param item_count: 
        :type item_count: int
        :param item_count2: 
        :type item_count2: List[int]
        :param created_at_before: 
        :type created_at_before: str
        :param created_at_strictly_before: 
        :type created_at_strictly_before: str
        :param created_at_after: 
        :type created_at_after: str
        :param created_at_strictly_after: 
        :type created_at_strictly_after: str
        :param metadata: Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.
        :type metadata: List[str]
        :param offer_metadata: Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.
        :type offer_metadata: List[str]
        :param nature: Filter on a limited subset of nature
        :type nature: str
        :param condition: Filter on a limited subset of condition
        :type condition: str
        :param shipping_allowed: 
        :type shipping_allowed: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[OfferCollectionRead]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_personas_idoffers_get_collection_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_personas_idoffers_get_collection_with_http_info(id, page, title, public_url, public_url2, unit_price, unit_price2, item_count, item_count2, created_at_before, created_at_strictly_before, created_at_after, created_at_strictly_after, metadata, offer_metadata, nature, condition, shipping_allowed, **kwargs)  # noqa: E501

    @validate_arguments
    def api_personas_idoffers_get_collection_with_http_info(self, id : Annotated[StrictStr, Field(..., description="Persona identifier")], page : Annotated[Optional[StrictInt], Field(description="The collection page number")] = None, title : Optional[StrictStr] = None, public_url : Optional[StrictStr] = None, public_url2 : Optional[conlist(StrictStr)] = None, unit_price : Optional[Union[StrictFloat, StrictInt]] = None, unit_price2 : Optional[conlist(Union[StrictFloat, StrictInt])] = None, item_count : Optional[StrictInt] = None, item_count2 : Optional[conlist(StrictInt)] = None, created_at_before : Optional[StrictStr] = None, created_at_strictly_before : Optional[StrictStr] = None, created_at_after : Optional[StrictStr] = None, created_at_strictly_after : Optional[StrictStr] = None, metadata : Annotated[Optional[conlist(conlist(StrictStr))], Field(description="Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.")] = None, offer_metadata : Annotated[Optional[conlist(conlist(StrictStr))], Field(description="Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.")] = None, nature : Annotated[Optional[StrictStr], Field(description="Filter on a limited subset of nature")] = None, condition : Annotated[Optional[StrictStr], Field(description="Filter on a limited subset of condition")] = None, shipping_allowed : Optional[StrictBool] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List or Search Offers for given Persona  # noqa: E501

        Retrieves the collection of Offer resources.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_personas_idoffers_get_collection_with_http_info(id, page, title, public_url, public_url2, unit_price, unit_price2, item_count, item_count2, created_at_before, created_at_strictly_before, created_at_after, created_at_strictly_after, metadata, offer_metadata, nature, condition, shipping_allowed, async_req=True)
        >>> result = thread.get()

        :param id: Persona identifier (required)
        :type id: str
        :param page: The collection page number
        :type page: int
        :param title: 
        :type title: str
        :param public_url: 
        :type public_url: str
        :param public_url2: 
        :type public_url2: List[str]
        :param unit_price: 
        :type unit_price: float
        :param unit_price2: 
        :type unit_price2: List[float]
        :param item_count: 
        :type item_count: int
        :param item_count2: 
        :type item_count2: List[int]
        :param created_at_before: 
        :type created_at_before: str
        :param created_at_strictly_before: 
        :type created_at_strictly_before: str
        :param created_at_after: 
        :type created_at_after: str
        :param created_at_strictly_after: 
        :type created_at_strictly_after: str
        :param metadata: Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.
        :type metadata: List[str]
        :param offer_metadata: Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.
        :type offer_metadata: List[str]
        :param nature: Filter on a limited subset of nature
        :type nature: str
        :param condition: Filter on a limited subset of condition
        :type condition: str
        :param shipping_allowed: 
        :type shipping_allowed: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[OfferCollectionRead], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'page',
            'title',
            'public_url',
            'public_url2',
            'unit_price',
            'unit_price2',
            'item_count',
            'item_count2',
            'created_at_before',
            'created_at_strictly_before',
            'created_at_after',
            'created_at_strictly_after',
            'metadata',
            'offer_metadata',
            'nature',
            'condition',
            'shipping_allowed'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_personas_idoffers_get_collection" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('title') is not None:  # noqa: E501
            _query_params.append(('title', _params['title']))

        if _params.get('public_url') is not None:  # noqa: E501
            _query_params.append(('publicUrl', _params['public_url']))

        if _params.get('public_url2') is not None:  # noqa: E501
            _query_params.append(('publicUrl[]', _params['public_url2']))
            _collection_formats['publicUrl[]'] = 'multi'

        if _params.get('unit_price') is not None:  # noqa: E501
            _query_params.append(('unitPrice', _params['unit_price']))

        if _params.get('unit_price2') is not None:  # noqa: E501
            _query_params.append(('unitPrice[]', _params['unit_price2']))
            _collection_formats['unitPrice[]'] = 'multi'

        if _params.get('item_count') is not None:  # noqa: E501
            _query_params.append(('itemCount', _params['item_count']))

        if _params.get('item_count2') is not None:  # noqa: E501
            _query_params.append(('itemCount[]', _params['item_count2']))
            _collection_formats['itemCount[]'] = 'multi'

        if _params.get('created_at_before') is not None:  # noqa: E501
            _query_params.append(('createdAt[before]', _params['created_at_before']))

        if _params.get('created_at_strictly_before') is not None:  # noqa: E501
            _query_params.append(('createdAt[strictly_before]', _params['created_at_strictly_before']))

        if _params.get('created_at_after') is not None:  # noqa: E501
            _query_params.append(('createdAt[after]', _params['created_at_after']))

        if _params.get('created_at_strictly_after') is not None:  # noqa: E501
            _query_params.append(('createdAt[strictly_after]', _params['created_at_strictly_after']))

        if _params.get('metadata') is not None:  # noqa: E501
            _query_params.append(('metadata[]', _params['metadata']))
            _collection_formats['metadata[]'] = 'csv'

        if _params.get('offer_metadata') is not None:  # noqa: E501
            _query_params.append(('offer.metadata[]', _params['offer_metadata']))
            _collection_formats['offer.metadata[]'] = 'csv'

        if _params.get('nature') is not None:  # noqa: E501
            _query_params.append(('nature', _params['nature']))

        if _params.get('condition') is not None:  # noqa: E501
            _query_params.append(('condition', _params['condition']))

        if _params.get('shipping_allowed') is not None:  # noqa: E501
            _query_params.append(('shippingAllowed', _params['shipping_allowed']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['jwtPersonalKey', 'personaAuthKey', 'oauth']  # noqa: E501

        _response_types_map = {
            '200': "List[OfferCollectionRead]",
        }

        return self.api_client.call_api(
            '/personas/{id}/offers', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_personas_idoffers_patch(self, id : Annotated[StrictStr, Field(..., description="Persona identifier")], offer_update : Annotated[OfferUpdate, Field(..., description="The updated Offer resource")], **kwargs) -> OfferRead:  # noqa: E501
        """Update an Offer for given Persona  # noqa: E501

        Updates the Offer resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_personas_idoffers_patch(id, offer_update, async_req=True)
        >>> result = thread.get()

        :param id: Persona identifier (required)
        :type id: str
        :param offer_update: The updated Offer resource (required)
        :type offer_update: OfferUpdate
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OfferRead
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_personas_idoffers_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_personas_idoffers_patch_with_http_info(id, offer_update, **kwargs)  # noqa: E501

    @validate_arguments
    def api_personas_idoffers_patch_with_http_info(self, id : Annotated[StrictStr, Field(..., description="Persona identifier")], offer_update : Annotated[OfferUpdate, Field(..., description="The updated Offer resource")], **kwargs) -> ApiResponse:  # noqa: E501
        """Update an Offer for given Persona  # noqa: E501

        Updates the Offer resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_personas_idoffers_patch_with_http_info(id, offer_update, async_req=True)
        >>> result = thread.get()

        :param id: Persona identifier (required)
        :type id: str
        :param offer_update: The updated Offer resource (required)
        :type offer_update: OfferUpdate
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OfferRead, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'offer_update'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_personas_idoffers_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['offer_update'] is not None:
            _body_params = _params['offer_update']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['jwtPersonalKey', 'personaAuthKey', 'oauth']  # noqa: E501

        _response_types_map = {
            '200': "OfferRead",
            '400': None,
            '422': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/personas/{id}/offers', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_personas_idoffers_post(self, id : Annotated[StrictStr, Field(..., description="Persona identifier")], offer_write : Annotated[OfferWrite, Field(..., description="The new Offer resource")], **kwargs) -> OfferPostCreationRead:  # noqa: E501
        """Create an Offer for given Persona  # noqa: E501

        Creates a Offer resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_personas_idoffers_post(id, offer_write, async_req=True)
        >>> result = thread.get()

        :param id: Persona identifier (required)
        :type id: str
        :param offer_write: The new Offer resource (required)
        :type offer_write: OfferWrite
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OfferPostCreationRead
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_personas_idoffers_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_personas_idoffers_post_with_http_info(id, offer_write, **kwargs)  # noqa: E501

    @validate_arguments
    def api_personas_idoffers_post_with_http_info(self, id : Annotated[StrictStr, Field(..., description="Persona identifier")], offer_write : Annotated[OfferWrite, Field(..., description="The new Offer resource")], **kwargs) -> ApiResponse:  # noqa: E501
        """Create an Offer for given Persona  # noqa: E501

        Creates a Offer resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_personas_idoffers_post_with_http_info(id, offer_write, async_req=True)
        >>> result = thread.get()

        :param id: Persona identifier (required)
        :type id: str
        :param offer_write: The new Offer resource (required)
        :type offer_write: OfferWrite
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OfferPostCreationRead, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'offer_write'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_personas_idoffers_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['offer_write'] is not None:
            _body_params = _params['offer_write']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['jwtPersonalKey', 'personaAuthKey', 'oauth']  # noqa: E501

        _response_types_map = {
            '422': "UnprocessableEntity",
            '201': "OfferPostCreationRead",
            '400': None,
        }

        return self.api_client.call_api(
            '/personas/{id}/offers', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_transactions_get_collection(self, page : Annotated[Optional[StrictInt], Field(description="The collection page number")] = None, order_status : Optional[StrictStr] = None, metadata : Annotated[Optional[conlist(conlist(StrictStr))], Field(description="Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.")] = None, status : Annotated[Optional[StrictStr], Field(description="Filter on a limited subset of status")] = None, **kwargs) -> List[TransactionCollectionRead]:  # noqa: E501
        """Retrieves the collection of Transaction resources.  # noqa: E501

        Retrieves the collection of Transaction resources.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_transactions_get_collection(page, order_status, metadata, status, async_req=True)
        >>> result = thread.get()

        :param page: The collection page number
        :type page: int
        :param order_status: 
        :type order_status: str
        :param metadata: Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.
        :type metadata: List[str]
        :param status: Filter on a limited subset of status
        :type status: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[TransactionCollectionRead]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_transactions_get_collection_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_transactions_get_collection_with_http_info(page, order_status, metadata, status, **kwargs)  # noqa: E501

    @validate_arguments
    def api_transactions_get_collection_with_http_info(self, page : Annotated[Optional[StrictInt], Field(description="The collection page number")] = None, order_status : Optional[StrictStr] = None, metadata : Annotated[Optional[conlist(conlist(StrictStr))], Field(description="Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.")] = None, status : Annotated[Optional[StrictStr], Field(description="Filter on a limited subset of status")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Retrieves the collection of Transaction resources.  # noqa: E501

        Retrieves the collection of Transaction resources.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_transactions_get_collection_with_http_info(page, order_status, metadata, status, async_req=True)
        >>> result = thread.get()

        :param page: The collection page number
        :type page: int
        :param order_status: 
        :type order_status: str
        :param metadata: Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \"null\" for desired value.
        :type metadata: List[str]
        :param status: Filter on a limited subset of status
        :type status: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[TransactionCollectionRead], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'page',
            'order_status',
            'metadata',
            'status'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_transactions_get_collection" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('order_status') is not None:  # noqa: E501
            _query_params.append(('order[status]', _params['order_status']))

        if _params.get('metadata') is not None:  # noqa: E501
            _query_params.append(('metadata[]', _params['metadata']))
            _collection_formats['metadata[]'] = 'csv'

        if _params.get('status') is not None:  # noqa: E501
            _query_params.append(('status', _params['status']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['jwtPersonalKey', 'oauth']  # noqa: E501

        _response_types_map = {
            '200': "List[TransactionCollectionRead]",
        }

        return self.api_client.call_api(
            '/transactions', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_transactions_uliddispute_delete(self, ulid : Annotated[StrictStr, Field(..., description="Transaction identifier")], **kwargs) -> None:  # noqa: E501
        """Abandon claims on Dispute  # noqa: E501

        **Only the buyer/complainant** can dismiss the case immediately. Otherwise, the support can but in a limited ranges of Dispute status.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_transactions_uliddispute_delete(ulid, async_req=True)
        >>> result = thread.get()

        :param ulid: Transaction identifier (required)
        :type ulid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_transactions_uliddispute_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_transactions_uliddispute_delete_with_http_info(ulid, **kwargs)  # noqa: E501

    @validate_arguments
    def api_transactions_uliddispute_delete_with_http_info(self, ulid : Annotated[StrictStr, Field(..., description="Transaction identifier")], **kwargs) -> ApiResponse:  # noqa: E501
        """Abandon claims on Dispute  # noqa: E501

        **Only the buyer/complainant** can dismiss the case immediately. Otherwise, the support can but in a limited ranges of Dispute status.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_transactions_uliddispute_delete_with_http_info(ulid, async_req=True)
        >>> result = thread.get()

        :param ulid: Transaction identifier (required)
        :type ulid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'ulid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_transactions_uliddispute_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['ulid']:
            _path_params['ulid'] = _params['ulid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['jwtPersonalKey', 'personaAuthKey', 'oauth']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/transactions/{ulid}/dispute', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_transactions_uliddispute_get(self, ulid : Annotated[StrictStr, Field(..., description="Transaction identifier")], **kwargs) -> DisputeRead:  # noqa: E501
        """Read Dispute from existing Transaction  # noqa: E501

        Retrieves a Dispute resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_transactions_uliddispute_get(ulid, async_req=True)
        >>> result = thread.get()

        :param ulid: Transaction identifier (required)
        :type ulid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DisputeRead
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_transactions_uliddispute_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_transactions_uliddispute_get_with_http_info(ulid, **kwargs)  # noqa: E501

    @validate_arguments
    def api_transactions_uliddispute_get_with_http_info(self, ulid : Annotated[StrictStr, Field(..., description="Transaction identifier")], **kwargs) -> ApiResponse:  # noqa: E501
        """Read Dispute from existing Transaction  # noqa: E501

        Retrieves a Dispute resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_transactions_uliddispute_get_with_http_info(ulid, async_req=True)
        >>> result = thread.get()

        :param ulid: Transaction identifier (required)
        :type ulid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DisputeRead, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ulid'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_transactions_uliddispute_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['ulid']:
            _path_params['ulid'] = _params['ulid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['jwtPersonalKey', 'personaAuthKey', 'oauth']  # noqa: E501

        _response_types_map = {
            '200': "DisputeRead",
            '404': None,
        }

        return self.api_client.call_api(
            '/transactions/{ulid}/dispute', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_transactions_uliddispute_patch(self, ulid : Annotated[StrictStr, Field(..., description="Transaction identifier")], dispute_update : Annotated[DisputeUpdate, Field(..., description="The updated Dispute resource")], **kwargs) -> DisputeRead:  # noqa: E501
        """Interact with a Dispute  # noqa: E501

        Only authenticated Persona can interact with a Dispute object. Usually through our web application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_transactions_uliddispute_patch(ulid, dispute_update, async_req=True)
        >>> result = thread.get()

        :param ulid: Transaction identifier (required)
        :type ulid: str
        :param dispute_update: The updated Dispute resource (required)
        :type dispute_update: DisputeUpdate
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DisputeRead
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_transactions_uliddispute_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_transactions_uliddispute_patch_with_http_info(ulid, dispute_update, **kwargs)  # noqa: E501

    @validate_arguments
    def api_transactions_uliddispute_patch_with_http_info(self, ulid : Annotated[StrictStr, Field(..., description="Transaction identifier")], dispute_update : Annotated[DisputeUpdate, Field(..., description="The updated Dispute resource")], **kwargs) -> ApiResponse:  # noqa: E501
        """Interact with a Dispute  # noqa: E501

        Only authenticated Persona can interact with a Dispute object. Usually through our web application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_transactions_uliddispute_patch_with_http_info(ulid, dispute_update, async_req=True)
        >>> result = thread.get()

        :param ulid: Transaction identifier (required)
        :type ulid: str
        :param dispute_update: The updated Dispute resource (required)
        :type dispute_update: DisputeUpdate
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DisputeRead, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ulid',
            'dispute_update'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_transactions_uliddispute_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['ulid']:
            _path_params['ulid'] = _params['ulid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['dispute_update'] is not None:
            _body_params = _params['dispute_update']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['jwtPersonalKey', 'personaAuthKey']  # noqa: E501

        _response_types_map = {
            '200': "DisputeRead",
            '400': None,
            '422': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/transactions/{ulid}/dispute', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_transactions_uliddispute_post(self, ulid : Annotated[StrictStr, Field(..., description="Transaction identifier")], dispute_write : Annotated[DisputeWrite, Field(..., description="The new Dispute resource")], **kwargs) -> DisputePostCreationRead:  # noqa: E501
        """Open a Dispute related to existing Transaction  # noqa: E501

        Creates a Dispute resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_transactions_uliddispute_post(ulid, dispute_write, async_req=True)
        >>> result = thread.get()

        :param ulid: Transaction identifier (required)
        :type ulid: str
        :param dispute_write: The new Dispute resource (required)
        :type dispute_write: DisputeWrite
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DisputePostCreationRead
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_transactions_uliddispute_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_transactions_uliddispute_post_with_http_info(ulid, dispute_write, **kwargs)  # noqa: E501

    @validate_arguments
    def api_transactions_uliddispute_post_with_http_info(self, ulid : Annotated[StrictStr, Field(..., description="Transaction identifier")], dispute_write : Annotated[DisputeWrite, Field(..., description="The new Dispute resource")], **kwargs) -> ApiResponse:  # noqa: E501
        """Open a Dispute related to existing Transaction  # noqa: E501

        Creates a Dispute resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_transactions_uliddispute_post_with_http_info(ulid, dispute_write, async_req=True)
        >>> result = thread.get()

        :param ulid: Transaction identifier (required)
        :type ulid: str
        :param dispute_write: The new Dispute resource (required)
        :type dispute_write: DisputeWrite
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DisputePostCreationRead, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ulid',
            'dispute_write'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_transactions_uliddispute_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['ulid']:
            _path_params['ulid'] = _params['ulid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['dispute_write'] is not None:
            _body_params = _params['dispute_write']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['jwtPersonalKey', 'personaAuthKey', 'oauth']  # noqa: E501

        _response_types_map = {
            '422': "UnprocessableEntity",
            '201': "DisputePostCreationRead",
            '400': None,
        }

        return self.api_client.call_api(
            '/transactions/{ulid}/dispute', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_transactions_ulidparcels_get_collection(self, ulid : StrictStr, page : Annotated[Optional[StrictInt], Field(description="The collection page number")] = None, **kwargs) -> List[object]:  # noqa: E501
        """Read shipments from Transaction  # noqa: E501

        Retrieves the collection of Parcel resources.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_transactions_ulidparcels_get_collection(ulid, page, async_req=True)
        >>> result = thread.get()

        :param ulid:  (required)
        :type ulid: str
        :param page: The collection page number
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[object]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_transactions_ulidparcels_get_collection_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_transactions_ulidparcels_get_collection_with_http_info(ulid, page, **kwargs)  # noqa: E501

    @validate_arguments
    def api_transactions_ulidparcels_get_collection_with_http_info(self, ulid : StrictStr, page : Annotated[Optional[StrictInt], Field(description="The collection page number")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Read shipments from Transaction  # noqa: E501

        Retrieves the collection of Parcel resources.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_transactions_ulidparcels_get_collection_with_http_info(ulid, page, async_req=True)
        >>> result = thread.get()

        :param ulid:  (required)
        :type ulid: str
        :param page: The collection page number
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[object], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ulid',
            'page'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_transactions_ulidparcels_get_collection" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['ulid']:
            _path_params['ulid'] = _params['ulid']


        # process the query parameters
        _query_params = []
        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['jwtPersonalKey', 'personaAuthKey']  # noqa: E501

        _response_types_map = {
            '200': "List[object]",
        }

        return self.api_client.call_api(
            '/transactions/{ulid}/parcels', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_transactions_ulidparcels_id_delete(self, ulid : StrictStr, id : StrictInt, **kwargs) -> None:  # noqa: E501
        """Withdraw shipment from Transaction  # noqa: E501

        No one except the support can do that manoeuvre.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_transactions_ulidparcels_id_delete(ulid, id, async_req=True)
        >>> result = thread.get()

        :param ulid:  (required)
        :type ulid: str
        :param id:  (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_transactions_ulidparcels_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_transactions_ulidparcels_id_delete_with_http_info(ulid, id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_transactions_ulidparcels_id_delete_with_http_info(self, ulid : StrictStr, id : StrictInt, **kwargs) -> ApiResponse:  # noqa: E501
        """Withdraw shipment from Transaction  # noqa: E501

        No one except the support can do that manoeuvre.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_transactions_ulidparcels_id_delete_with_http_info(ulid, id, async_req=True)
        >>> result = thread.get()

        :param ulid:  (required)
        :type ulid: str
        :param id:  (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'ulid',
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_transactions_ulidparcels_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['ulid']:
            _path_params['ulid'] = _params['ulid']

        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['jwtPersonalKey']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/transactions/{ulid}/parcels/{id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_transactions_ulidparcels_post(self, ulid : StrictStr, parcel_write : Annotated[ParcelWrite, Field(..., description="The new Parcel resource")], **kwargs) -> ParcelRead:  # noqa: E501
        """Manually declare package shipped for Transaction  # noqa: E501

        Creates a Parcel resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_transactions_ulidparcels_post(ulid, parcel_write, async_req=True)
        >>> result = thread.get()

        :param ulid:  (required)
        :type ulid: str
        :param parcel_write: The new Parcel resource (required)
        :type parcel_write: ParcelWrite
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ParcelRead
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_transactions_ulidparcels_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_transactions_ulidparcels_post_with_http_info(ulid, parcel_write, **kwargs)  # noqa: E501

    @validate_arguments
    def api_transactions_ulidparcels_post_with_http_info(self, ulid : StrictStr, parcel_write : Annotated[ParcelWrite, Field(..., description="The new Parcel resource")], **kwargs) -> ApiResponse:  # noqa: E501
        """Manually declare package shipped for Transaction  # noqa: E501

        Creates a Parcel resource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_transactions_ulidparcels_post_with_http_info(ulid, parcel_write, async_req=True)
        >>> result = thread.get()

        :param ulid:  (required)
        :type ulid: str
        :param parcel_write: The new Parcel resource (required)
        :type parcel_write: ParcelWrite
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ParcelRead, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ulid',
            'parcel_write'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_transactions_ulidparcels_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['ulid']:
            _path_params['ulid'] = _params['ulid']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['parcel_write'] is not None:
            _body_params = _params['parcel_write']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['jwtPersonalKey', 'oauth']  # noqa: E501

        _response_types_map = {
            '422': "UnprocessableEntity",
            '201': "ParcelRead",
            '400': None,
        }

        return self.api_client.call_api(
            '/transactions/{ulid}/parcels', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
